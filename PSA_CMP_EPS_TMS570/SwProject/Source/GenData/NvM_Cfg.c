/**********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2010 by Vctr Informatik GmbH.                                                  All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vctr Informatik GmbH.
 *                Vctr Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vctr Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -------------------------------------------------------------------------------------------------------------------
 *         File:  NvM_Cfg.c
 *      Project:  MemService_AsrNvM
 *       Module:  NvM - Submodule Cfg (configuration)
 *    Generator:  -
 *
 *  Description:  Configuration objects (Link-Time)
 *
 *  -------------------------------------------------------------------------------------------------------------------
 *  GENERATION INFORMATION
 *  -------------------------------------------------------------------------------------------------------------------
 *     Project:    EPS.ecuc
 *   Generated:  2018-03-08 08:39 am
 *    Licensee:   Nxtr Automotive Corporation (2502600608)
 
    This file is generated by DaVinci Configurator Pro - DAVINCICFG.EXE V4.0.67.0.
    Do not modify this file, otherwise the software may behave in unexpected way.
 *********************************************************************************************************************/

/**********************************************************************************************************************
 *  MODULE SWITCH
 *********************************************************************************************************************/
/* this switch enables the header file(s) to hide some parts. */
#define NVM_CONFIGURATION

/* Disable declaration of API in NvM.h, as it would collide with declaration in Rte_NvM.h          *
 * From NvM.h we just need the version info as well as the inclusion of NvM_Cfg.h                  */
#define NVM_SKIP_API_DECLARATIONS STD_ON

/**********************************************************************************************************************
 *  INCLUDES
 *********************************************************************************************************************/
#include "Std_Types.h"

/* Define RTE_MICROSAR_PIM_EXPORT is necessary only when serviceports are used */
#define RTE_MICROSAR_PIM_EXPORT

/**********************************************************************************************************************
 *  MODULE HEADER INCLUDES
 *********************************************************************************************************************/
/* only includes the public part of config */
#include "NvM.h"
#include "NvM_PrivateCfg.h"

#include "NvM_Crc.h"

/* This tag will only be replaced, if one or more callbacks via Service Ports had been configured */
/*<NVM_SERVICE_PORTS_INCLUDE/>*/

/**********************************************************************************************************************
 *  VERSION CHECKS
 *********************************************************************************************************************/
#if (     (NVM_CFG_MAJOR_VERSION != (3u)) \
       || (NVM_CFG_MINOR_VERSION != (7u)))
  #error "Version numbers of NvM_Cfg.c and NvM_Cfg.h are inconsistent!"
#endif

#if (     (NVM_PRIV_CFG_MAJOR_VERSION != NVM_CFG_MAJOR_VERSION) \
       || (NVM_PRIV_CFG_MINOR_VERSION != NVM_CFG_MINOR_VERSION))
  #error "Version numbers of NvM_Cfg.c and NvM_Cfg.h are inconsistent!"
#endif

#if ((NVM_SW_MAJOR_VERSION != NVM_CFG_MAJOR_VERSION) \
       || (NVM_SW_MINOR_VERSION != NVM_CFG_MINOR_VERSION))
  #error "Version numbers of NvM_Cfg.c and NvM.h are inconsistent!"
#endif

#if ((NVM_TYPES_MAJOR_VERSION != NVM_CFG_MAJOR_VERSION) \
       || (NVM_TYPES_MINOR_VERSION != NVM_CFG_MINOR_VERSION))
  #error "Version numbers of NvM_Cfg.c and NvM_Types.h are inconsistent!"
#endif

#include "Crc.h" /* always needed, since the config Block has a CRC */

/**** AUTOSAR Version Checks *********/

#if defined(CRC_VENDOR_ID)
#   if ((CRC_VENDOR_ID == NVM_VENDOR_ID) && \
        ((CRC_AR_MAJOR_VERSION != 3u) || (CRC_AR_MINOR_VERSION != 1)) && \
        ((CRC_AR_MAJOR_VERSION != 3u) || (CRC_AR_MINOR_VERSION != 0)) && \
        ((CRC_AR_MAJOR_VERSION != 2u) || (CRC_AR_MINOR_VERSION != 1)))
#       error "AUTOSAR Version of CRC module is not supported!"
#   endif
#endif

#if defined(MEMIF_VENDOR_ID)
#   if ((MEMIF_VENDOR_ID == NVM_VENDOR_ID) && \
        ((MEMIF_AR_MAJOR_VERSION != 1u) || (MEMIF_AR_MINOR_VERSION != 1)) && \
        ((MEMIF_AR_MAJOR_VERSION != 1u) || (MEMIF_AR_MINOR_VERSION != 2)))
#       error "AUTOSAR Version of MemIf module is not supported!"
#   endif
#endif

#if defined(DEM_VENDOR_ID)
#   if ((DEM_VENDOR_ID == NVM_VENDOR_ID) && \
        ((DEM_AR_MAJOR_VERSION != 2u) || (DEM_AR_MINOR_VERSION != 2)) && \
        ((DEM_AR_MAJOR_VERSION != 3u) || (DEM_AR_MINOR_VERSION != 1)))
#       error "AUTOSAR Version of DEM module is not supported!"
#   endif
#endif

/* check, if NvM has to declare PIM externals on its own */
#if (STD_ON == NVM_RTE_INCLUDED)
	#if (defined RTE_VENDOR_ID)
		#if (RTE_VENDOR_ID == (0x001Eu))
			#if ((RTE_SW_MAJOR_VERSION < 2) || ((RTE_SW_MAJOR_VERSION == 2) && (RTE_SW_MINOR_VERSION < 12)))
				#define NVM_USE_PIM_EXTERNALS
			#endif
		#else
			# define NVM_USE_PIM_EXTERNALS
		#endif
	#else
		#define NVM_USE_PIM_EXTERNALS
	#endif
#endif

/* include list of the callback definitions */
/*<NVM_CFG_CBK_INCLUDE_LIST>*/
#include "EcuM_Cbk.h"
#include "CDD_Data.h"
#include "Ap_StaMd_Cfg.h"
#include "Ap_DiagMgr.h"
#include "Dem.h"
#include "ApplCallbacks.h"
#include "Ap_DfltConfigData.h"
#include "EPS_DiagSrvcs_SrvcLUTbl.h"
#include "Crc.h"
#include "Cd_NvMProxy.h"
#include "Dem_Lcfg.h"
#include "DiagSvc.h"
/*</NVM_CFG_CBK_INCLUDE_LIST>*/

/* include configured file declaring or defining resource (un)locking service(s) */

#include "SchM_NvM.h"


#define NVM_SIZE_STANDARD_JOB_QUEUE     /*<NVM_SIZE_STANDARD_QUEUE/>*/ (8u)
#define NVM_SIZE_IMMEDIATE_JOB_QUEUE    /*<NVM_SIZE_IMMEDIATE_QUEUE/>*/ 0u

/* Just for your information:
 * NVRAM Blocks with CRC: 2
*/
/* the size of the CRC job queue in 32bitWords. It is a bit-string, one bit for each block */
#define NVM_SIZE_CRC_JOB_QUEUE ((NVM_TOTAL_NUM_OF_NVRAM_BLOCKS * 2 + NVM_CRC_QUEUE_BITINDEX_MASK) >> \
                                                                            NVM_CRC_QUEUE_ENTRY_SHIFT)

#define NVM_CFG_CHECK_RAM_BLOCK_LENGTHS /*<NVM_CFG_CHECK_RAM_BLOCK_LENGTHS/>*/ (STD_OFF)
#define NVM_CFG_CHECK_ROM_BLOCK_LENGTHS /*<NVM_CFG_CHECK_ROM_BLOCK_LENGTHS/>*/ (STD_OFF)

#define NVM_USE_CRC16 STD_ON
#define NVM_USE_CRC32 STD_OFF /* No Crc32 used */

/* initial crc value */
#define NVM_INITIAL_CRC_16_VALUE    0xFFFFu
#define NVM_INITIAL_CRC_32_VALUE    (0xFFFFFFFFuL ^ NVM_CRC32_XOR_VALUE)

#define NVM_CRC32_XOR_VALUE     0xFFFFFFFFu


#define NVM_START_SEC_CODE
#include "MemMap.h"

#if(NVM_USE_CRC16 == STD_ON)
    static FUNC(void, NVM_PRIVATE_CODE)  NvM_Crc_Crc16_Calculate(NvM_ConstRamAddressType, uint16, NvM_CrcValuePtrType);
    static FUNC(boolean, NVM_PRIVATE_CODE) NvM_Crc_Crc16_Compare      (NvM_CrcBufferConstPtrType, NvM_CrcValueRefType);
    static FUNC(void, NVM_PRIVATE_CODE) NvM_Crc_Crc16_CopyToBuffer (NvM_CrcBufferPtrType, NvM_CrcValueRefType);
#endif

#if(NVM_USE_CRC32 == STD_ON)
    static FUNC(void, NVM_PRIVATE_CODE)  NvM_Crc_Crc32_Calculate(NvM_ConstRamAddressType, uint16, NvM_CrcValuePtrType);
    static FUNC(boolean, NVM_PRIVATE_CODE) NvM_Crc_Crc32_Compare      (NvM_CrcBufferConstPtrType, NvM_CrcValueRefType);
    static FUNC(void, NVM_PRIVATE_CODE) NvM_Crc_Crc32_CopyToBuffer (NvM_CrcBufferPtrType, NvM_CrcValueRefType);
#endif

/*<NVM_CFG_BLOCK_INT_CBK_DECL/>*/


#define NVM_STOP_SEC_CODE
#include "MemMap.h"

/**********************************************************************************************************************
 *  PUBLIC CONSTANTS
 *********************************************************************************************************************/

#define NVM_START_SEC_CONST_8BIT
#include "MemMap.h"

    /* Number of write attempts: 1 + number of retries */
    CONST(uint8, NVM_PRIVATE_CONST) NvM_NoOfWrAttempts_u8 = 3u;

#define NVM_STOP_SEC_CONST_8BIT
#include "MemMap.h"


#define NVM_START_SEC_CONST_16BIT
#include "MemMap.h"

    /* maximum number of bytes to be processed in one crc calculation step */
    CONST(uint16, NVM_CONFIG_CONST) NvM_NoOfCrcBytes_u16 = 65535u;

	/* constant holding Crc quueue size value */
	CONST(uint16, NVM_PRIVATE_CONST) NvM_CrcQueueSize_u16 = NVM_TOTAL_NUM_OF_NVRAM_BLOCKS * 2;

#define NVM_STOP_SEC_CONST_16BIT
#include "MemMap.h"

/* close section, to ensure unique section ends */
#define NVM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"
    /* constants holding the compiled queue size values */
    CONST(NvM_QueueSizesType, NVM_PRIVATE_CONST) NvM_QueueSizes_t =
    {
        /* MISRA wants to define a operator precedence with parentheses */
        (NVM_SIZE_STANDARD_JOB_QUEUE + NVM_SIZE_IMMEDIATE_JOB_QUEUE) - 1u,
        NVM_SIZE_STANDARD_JOB_QUEUE
    };

#if(NVM_USE_CRC16 == STD_ON)
    static CONST(struct NvM_CrcHandlerClass, NVM_PRIVATE_CONST) NvM_Crc_Crc16Handler_t =
    {
        NvM_Crc_Crc16_Calculate,
        NvM_Crc_Crc16_Compare,
        NvM_Crc_Crc16_CopyToBuffer,
        NVM_INITIAL_CRC_16_VALUE, /* initial value */
        2  /* crc length */
    };
#else
#   define NvM_Crc_Crc16Handler_t NvM_Crc_NoCrcHandler_t
#endif

#if(NVM_USE_CRC32 == STD_ON)
static CONST(struct NvM_CrcHandlerClass, NVM_PRIVATE_CONST) NvM_Crc_Crc32Handler_t =
{
    NvM_Crc_Crc32_Calculate,
    NvM_Crc_Crc32_Compare,
    NvM_Crc_Crc32_CopyToBuffer,
    NVM_INITIAL_CRC_32_VALUE, /* initial value */
    4  /* crc length */
};
#else
#   define NvM_Crc_Crc32Handler_t NvM_Crc_NoCrcHandler_t
#endif

    CONST(NvM_CrcHandlerClassConstPtr, NVM_PRIVATE_CONST) NvM_CrcHandlerTable_at[4] =
    {
        &NvM_Crc_NoCrcHandler_t,
        &NvM_Crc_NoCrcHandler_t, /* reserved for CRC8 */
        &NvM_Crc_Crc16Handler_t,
        &NvM_Crc_Crc32Handler_t
    };

    /* Constants, holding the two DEM error codes, defined by DEM */

    CONST(Dem_EventIdType, NVM_PRIVATE_CONST) NvM_DemErrReqFailed       = NVM_E_REQ_FAILED;
    CONST(Dem_EventIdType, NVM_PRIVATE_CONST) NvM_DemErrIntegrityFailed = NVM_E_INTEGRITY_FAILED;


/* close section, to ensure unique section ends */
#define NVM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"

/* 8Bit Data section containing the CRC buffers, as well as the internal buffer */
#define NVM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"

static VAR(uint8, NVM_PRIVATE_DATA) ConfigBlock_RamBlock_au8[2];

#if(STD_ON == NVM_CRC_INT_BUFFER)
static VAR(uint8, NVM_PRIVATE_DATA) Rte_NvmBlock_Polarity_Polarity_Cnt_Str_Crc_au8[2];
static VAR(uint8, NVM_PRIVATE_DATA) NVM_BLOCK_SER_TUNINGSELECT_Crc_au8[2];


/* create the internal buffer of size NVM_INTERNAL_BUFFER_SIZE */
VAR(uint8, NVM_PRIVATE_DATA) NvM_InternalBuffer_au8[26];
#endif

/* create a test buffer of size 1 byte for testing readability of a block */
VAR(uint8, NVM_PRIVATE_DATA) NvM_TestBuffer_u8;

#define NVM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"


#if (defined NVM_USE_PIM_EXTERNALS)
/* Declare RAM Block symbols, provided by RTE (PIMs)
*  Note that these declarations are located intentionally outside any MemMap section.
*/


extern VAR(uint8, NVM_APPL_DATA) NTCStrgArray_Cnt_str[];
extern VAR(uint8, NVM_APPL_DATA) CDD_EOLSrlComSvcDft_Cnt_G_b32[];
extern VAR(uint8, NVM_APPL_DATA) TypeHData_Cnt_u08[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_Ap_CtrlPolarityBrshlss_Polarity_Cnt_Str[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_CurrParamComp_EOLNomMtrParam[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) Nvm_NMEC_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_EcuSrlNum_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_EpsSrlNum_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_EcuHwPn_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_NxtrManfScrpd_Cnt_u8[];
extern VAR(uint8, NVM_APPL_DATA) Nvm_IgnCntr_Cnt_u16[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_CloseCheck_Cnt_u32[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_DigMSB_DigMSBEOLData[];  /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NTCBlackBoxData_Cnt_str[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_BatteryVoltage_OvervoltageData[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_ThrmlDutyCycle_ThrmlDutyCycle_FltStVal[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) LatchCounter_Cnt_u16[];
extern VAR(uint8, NVM_APPL_DATA) FlashLogA_G_str[];
extern VAR(uint8, NVM_APPL_DATA) FlashLogB_G_str[];
extern VAR(uint8, NVM_APPL_DATA) SecurityViolation_Cnt_G_u08[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_VehDyn_MotPosReset[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) AuthenticationZone_G_str[];
extern CONST(uint8, NVM_APPL_CONST) D_AUTHENTICATIONZONEINIT_CNT_STR[];
extern VAR(uint8, NVM_APPL_DATA) ECUManufacturingDate_G_str[];
extern CONST(uint8, NVM_APPL_CONST) D_MANUFDATEINIT_CNT_STR[];
extern VAR(uint8, NVM_APPL_DATA) EMCStandardizationLabel_G_str[];
extern CONST(uint8, NVM_APPL_CONST) D_STDLABELINIT_CNT_STR[];
extern VAR(uint8, NVM_APPL_DATA) CustECUSrlNum_Cnt_G_u08[];
extern CONST(uint8, NVM_APPL_CONST) D_CUSTECUINIT_CNT_U08[];
extern VAR(uint8, NVM_APPL_DATA) SecurityKey_Cnt_G_u08[];
extern CONST(uint8, NVM_APPL_CONST) D_SECURITYKEYINIT_CNT_U08[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_SrlComInput_VVHTYPEData[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_SrlComInput_ElecIntData[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) TuningSelect_G_str[];
extern CONST(uint8, NVM_APPL_CONST) D_TUNINGSELECTINIT_CNT_STR[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_CmMtrCurr_ShCurrCal[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_TrqCanc_CogTrqCal[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_TrqCanc_CogTrqRplComp[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_LrnEOT_LearnedEOT[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_AvgFricLrn_AvgFricLrnData[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_CmMtrCurr_CurrTempOffset[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) Rte_FaultLog_FaultLog[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_SrlComInput_ShutdownTimeData[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_AbsHwPos_EOLVehCntrOffset[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_HwTqCorrln_HwTqCorrlnCh1CMCLPFSvData[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) PowerPackConfig_G_str[];
extern CONST(uint8, NVM_APPL_CONST) D_POWERPACKCONFIGINIT_CNT_STR[];
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_HwTqArbn_HwTqArbnEOLCh1OffsetTrimData[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_TrqCmdScl_TorqueCmdSF_Uls_f32[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_PsaAgArbn_PsaAgArbnLrndOffsData[]; /* NXTR MANUAL EDIT */
extern VAR(uint8, NVM_APPL_DATA) NvMP_Rte_ActivePull_PullCmpLTComp_HwNm_f32[]; /* NXTR MANUAL EDIT */

#endif

#define NVM_START_SEC_CONST_DESCRIPTOR_TABLE
#include "MemMap.h"

    CONST(NvM_BlockIdType, NVM_PUBLIC_CONST) NvM_NoOfBlockIds_t = NVM_TOTAL_NUM_OF_NVRAM_BLOCKS;

    CONST(NvM_CompiledConfigIdType, NVM_PUBLIC_CONST) NvM_CompiledConfigId_t = {(uint16)NVM_COMPILED_CONFIG_ID};


    /* define the multi block callback */
    CONST(NvM_MultiCbkPtrType, NVM_CONFIG_CONST) NvM_MultiBlockCbk = /*<NVM_MULTIBLOCK_CALLBACK/>*/ EcuM_CB_NfyNvMJobEnd;

    /* NvM_MultiBlockCbk(ServiceId, RequestResult) */

    /* block descriptor table that holds the static configuration parameters of the RAM, ROM and NVBlocks.
     * This table has to be adjusted according to the configuration of the NVManager.
     */
    CONST(NvM_BlockDescriptorType, NVM_CONFIG_CONST) NvM_BlockDescriptorTable_at[NVM_TOTAL_NUM_OF_NVRAM_BLOCKS] =
    {
        {   /* block descriptor for multiblock calls. This block id is
             * reserved as it is used to access the result of multiblock
             * requests. This block descriptor entry will not be used.
             */
            NULL_PTR,           /* pointer to the RAM data buffer */
            NULL_PTR,           /* pointer to the ROM default data block */

            NULL_PTR, /* pointer to the job End Callback function */
#if(STD_ON == NVM_CRC_INT_BUFFER)
            NULL_PTR,       	/* pointer to the CRC data buffer */
#endif
            1u,                 /* NvIdentifier dummy */
            0u,                 /* Length of the block in bytes */
            0u,                 /* Number of multiple blocks (depends on Mngmt type), don't care */
            0xFFu,              /* block write priorisation */
            0u,                 /* device id */
            NVM_BLOCK_NATIVE,   /* Management Type */
            NVM_BLOCK_USE_CRC_OFF, /* no CRC; don't care */
            0u,                 /* flags, don't care */
            0u                  /* default_pt is ROM Default block -> don't care */
        },
        {
            /*<NVM_CONFIG_BLOCK_DESCRIPTOR/>*/     
        /* block descriptor Config Id Block block ConfigBlock */
        (NvM_RamAddressType)ConfigBlock_RamBlock_au8,    /* pointer to the RAM data buffer */
        NULL_PTR,    /* No ROM default data block */
        NULL_PTR,    /* pointer to the Job End Callback function */
        NULL_PTR,    /* pointer to the CRC buffer */
        0x0002u,    /* NV block Base number (defined by FEE/EA) */
        2u,    /* Length of the block in bytes */
        2u,    /* Number of multiple blocks */
        127u,    /* Block Priority */
        MEMIF_Fee,                                /* Device Id (defined by MemIf) */
        NVM_BLOCK_REDUNDANT,    /* Management Type */
    NVM_BLOCK_CRC_16_ON,    /* CRC16 */
        (
            NVM_CALC_RAM_BLOCK_CRC_OFF |            /* Calc CRC on NvM_SetRamBlockStatus() */
            NVM_BLOCK_WRITE_PROT_OFF |            /* Initial write protection */
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |        /* Write Block once */
            NVM_RESISTANT_TO_CHANGED_SW_ON |        /* Resistant to Changed SW */
            NVM_SELECT_BLOCK_FOR_READALL_ON        /* Select this block for NvM_ReadAll() */
        ),
            0        /* Is ROM DefaultBlock -> irrelevant, since we don't have any default data */

        }

        /*<NVM_DESCRIPTOR_TABLE_CONFIG>*/
    
    /* block descriptor user block NVM_BLOCK_DIAGMGR_NTCSTRG */
    ,{
        (NvM_RamAddressType)&NTCStrgArray_Cnt_str /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0018u,     /* NV block Base number (defined by FEE/EA) */
        60u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_EPSDEFEATS */
    ,{
        (NvM_RamAddressType)&CDD_EOLSrlComSvcDft_Cnt_G_b32 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x000Au,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Deprecated_NVM_BLOCK_DEM_CTCSTRG */
    ,{
        (NvM_RamAddressType)NULL_PTR /* Non permanent RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0024u,     /* NV block Base number (defined by FEE/EA) */
        60u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_StaMd_TypeHRamBuffer */
    ,{
        (NvM_RamAddressType)&TypeHData_Cnt_u08 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0026u,     /* NV block Base number (defined by FEE/EA) */
        100u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_Polarity_Polarity_Cnt_Str */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_Ap_CtrlPolarityBrshlss_Polarity_Cnt_Str /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        Rte_NvmBlock_Polarity_Polarity_Cnt_Str_Crc_au8, /* Pointer to the CRC buffer */
        0x0004u,     /* NV block Base number (defined by FEE/EA) */
        8u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_ON |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_CurrParamComp_EOLNomMtrParam */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_CurrParamComp_EOLNomMtrParam /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0008u,     /* NV block Base number (defined by FEE/EA) */
        8u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_NXTRMEC */
    ,{
        (NvM_RamAddressType)&Nvm_NMEC_Cnt_u8 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x000Cu,     /* NV block Base number (defined by FEE/EA) */
        1u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_ECUSRLNUM */
    ,{
        (NvM_RamAddressType)&Nvm_EcuSrlNum_Cnt_u8 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x000Eu,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_EPSSRLNUM */
    ,{
        (NvM_RamAddressType)&Nvm_EpsSrlNum_Cnt_u8 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0010u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_ECUHWPN */
    ,{
        (NvM_RamAddressType)&Nvm_EcuHwPn_Cnt_u8 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0012u,     /* NV block Base number (defined by FEE/EA) */
        12u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_NXTRMANUFSCRATCHPAD */
    ,{
        (NvM_RamAddressType)&Nvm_NxtrManfScrpd_Cnt_u8 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0014u,     /* NV block Base number (defined by FEE/EA) */
        64u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_CMS_IGNCNTR */
    ,{
        (NvM_RamAddressType)&Nvm_IgnCntr_Cnt_u16 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0016u,     /* NV block Base number (defined by FEE/EA) */
        2u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_StaMd_CloseCheckData */
    ,{
        (NvM_RamAddressType)&NvMP_CloseCheck_Cnt_u32 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x001Eu,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_Sa_DigMSB_DigMSBEOLData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_DigMSB_DigMSBEOLData /* pointer to the RAM data buffer */,  /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0006u,     /* NV block Base number (defined by FEE/EA) */
        4102u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_DIAGMGR_BLACKBOX */
    ,{
        (NvM_RamAddressType)&NTCBlackBoxData_Cnt_str /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x001Au,     /* NV block Base number (defined by FEE/EA) */
        192u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_BatteryVoltage_OvervoltageData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_BatteryVoltage_OvervoltageData /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x001Cu,     /* NV block Base number (defined by FEE/EA) */
        6u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_ThrmlDutyCycle_ThrmlDutyCycle_FltStVal */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_ThrmlDutyCycle_ThrmlDutyCycle_FltStVal /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0020u,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_DIAGMGR_LATCHCNTRS */
    ,{
        (NvM_RamAddressType)&LatchCounter_Cnt_u16 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0022u,     /* NV block Base number (defined by FEE/EA) */
        16u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_FLASHLOGA */
    ,{
        (NvM_RamAddressType)&FlashLogA_G_str /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0028u,     /* NV block Base number (defined by FEE/EA) */
        50u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_FLASHLOGB */
    ,{
        (NvM_RamAddressType)&FlashLogB_G_str /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x002Au,     /* NV block Base number (defined by FEE/EA) */
        50u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_SECURITYVIOLATION */
    ,{
        (NvM_RamAddressType)&SecurityViolation_Cnt_G_u08 /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x002Cu,     /* NV block Base number (defined by FEE/EA) */
        1u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_VehDyn_MotPosReset */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_VehDyn_MotPosReset /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x002Eu,     /* NV block Base number (defined by FEE/EA) */
        5u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_AUTHENTICATIONZONE */
    ,{
        (NvM_RamAddressType)&AuthenticationZone_G_str /* pointer to the RAM data buffer */,
        &D_AUTHENTICATIONZONEINIT_CNT_STR /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0030u,     /* NV block Base number (defined by FEE/EA) */
        11u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_ECUMANUFACTURINGDATE */
    ,{
        (NvM_RamAddressType)&ECUManufacturingDate_G_str /* pointer to the RAM data buffer */,
        &D_MANUFDATEINIT_CNT_STR /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0032u,     /* NV block Base number (defined by FEE/EA) */
        3u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_EMCSTANDARDIZATIONLABEL */
    ,{
        (NvM_RamAddressType)&EMCStandardizationLabel_G_str /* pointer to the RAM data buffer */,
        &D_STDLABELINIT_CNT_STR /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0034u,     /* NV block Base number (defined by FEE/EA) */
        22u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_CUSTECUSRLNUM */
    ,{
        (NvM_RamAddressType)&CustECUSrlNum_Cnt_G_u08 /* pointer to the RAM data buffer */,
        &D_CUSTECUINIT_CNT_U08 /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0036u,     /* NV block Base number (defined by FEE/EA) */
        13u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_SECURITYKEY */
    ,{
        (NvM_RamAddressType)&SecurityKey_Cnt_G_u08 /* pointer to the RAM data buffer */,
        &D_SECURITYKEYINIT_CNT_U08 /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0038u,     /* NV block Base number (defined by FEE/EA) */
        3u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_SrlComInput_VVHTYPEData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_SrlComInput_VVHTYPEData /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x003Au,     /* NV block Base number (defined by FEE/EA) */
        1u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_SrlComInput_ElecIntData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_SrlComInput_ElecIntData /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x003Cu,     /* NV block Base number (defined by FEE/EA) */
        1u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_TUNINGSELECT */
    ,{
        (NvM_RamAddressType)&TuningSelect_G_str /* pointer to the RAM data buffer */,
        &D_TUNINGSELECTINIT_CNT_STR /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NVM_BLOCK_SER_TUNINGSELECT_Crc_au8, /* Pointer to the CRC buffer */
        0x003Eu,     /* NV block Base number (defined by FEE/EA) */
        24u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_CRC_16_ON,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Deprecated_NvmBlock_CmMtrCurr_CurrTempOffset */
    ,{
        (NvM_RamAddressType)NULL_PTR /* Non permanent RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0040u,     /* NV block Base number (defined by FEE/EA) */
        98u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_CmMtrCurr_ShCurrCal */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_CmMtrCurr_ShCurrCal /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0042u,     /* NV block Base number (defined by FEE/EA) */
        30u,    /* Length of the block in bytes */  /* NXTR MANUAL EDIT */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_TrqCanc_CogTrqCal */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_TrqCanc_CogTrqCal /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0044u,     /* NV block Base number (defined by FEE/EA) */
        1026u,    /* Length of the block in bytes */ /* NXTR MANUAL EDIT */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_TrqCanc_CogTrqRplComp */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_TrqCanc_CogTrqRplComp /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0046u,     /* NV block Base number (defined by FEE/EA) */
        22u,    /* Length of the block in bytes */ /* NXTR MANUAL EDIT */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Deprecated_Rte_NvmBlock_TrqCmdScl_TorqueCmdSF_Uls_f32 */
    ,{
        (NvM_RamAddressType)NULL_PTR /* Non permanent RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0048u,     /* NV block Base number (defined by FEE/EA) */
        8u,    /* Length of the block in bytes */ /* NXTR MANUAL EDIT */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Deprecated_NvmBlock_AbsHwPos_EOLVehCntrOffset */
    ,{
        (NvM_RamAddressType)NULL_PTR /* Non permanent RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x004Au,     /* NV block Base number (defined by FEE/EA) */
        10u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_LrnEOT_LearnedEOT */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_LrnEOT_LearnedEOT /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x004Cu,     /* NV block Base number (defined by FEE/EA) */
        14u,    /* Length of the block in bytes */ /* NXTR MANUAL EDIT */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_AvgFricLrn_AvgFricLrnData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_AvgFricLrn_AvgFricLrnData /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x004Eu,     /* NV block Base number (defined by FEE/EA) */
        206u,    /* Length of the block in bytes */ /* NXTR MANUAL EDIT */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_CmMtrCurr_CurrTempOffset */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_CmMtrCurr_CurrTempOffset /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0050u,     /* NV block Base number (defined by FEE/EA) */
        96u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Deprecated_Rte_NvmBlock_AbsHwPos_EOLVehCntrOffset */
    ,{
        (NvM_RamAddressType)NULL_PTR /* Non permanent RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0052u,     /* NV block Base number (defined by FEE/EA) */
        5u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_FaultLog_FaultLog */
    ,{
        (NvM_RamAddressType)&Rte_FaultLog_FaultLog /* pointer to the RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0054u,     /* NV block Base number (defined by FEE/EA) */
        1200u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Deprecated_BLOCK_DEM_CTCSTRG1 */
    ,{
        (NvM_RamAddressType)NULL_PTR /* Non permanent RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0056u,     /* NV block Base number (defined by FEE/EA) */
        1151u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_SrlComInput_ShutdownTimeData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_SrlComInput_ShutdownTimeData /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0058u,     /* NV block Base number (defined by FEE/EA) */
        5u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_DEM_CTCSTRG */
    ,{
        (NvM_RamAddressType)&Dem_NvData /* pointer to the RAM data buffer */,
        Dem_NvDataInit,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x005Au,     /* NV block Base number (defined by FEE/EA) */
        1225u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            0        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_AbsHwPos_EOLVehCntrOffset */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_AbsHwPos_EOLVehCntrOffset /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x005Cu,     /* NV block Base number (defined by FEE/EA) */
        6u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_HwTqCorrln_HwTqCorrlnCh1CMCLPFSvData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_HwTqCorrln_HwTqCorrlnCh1CMCLPFSvData /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x005Eu,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Deprecated_Rte_NvmBlock_HwTqArbn_HwTqArbnEOLCh1OffsetTrimData */
    ,{
        (NvM_RamAddressType)NULL_PTR /* Non permanent RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0060u,     /* NV block Base number (defined by FEE/EA) */
        7u,    /* Length of the block in bytes */ /* NXTR MANUAL EDIT */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block NVM_BLOCK_SER_POWERPACKCONFIG */
    ,{
        (NvM_RamAddressType)&PowerPackConfig_G_str /* pointer to the RAM data buffer */,
        &D_POWERPACKCONFIGINIT_CNT_STR /* pointer to the ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0062u,     /* NV block Base number (defined by FEE/EA) */
        3u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Deprecated_Rte_NvmBlock_PsaAgArbn_PsaAgArbnLrndOffsData */
    ,{
        (NvM_RamAddressType)NULL_PTR /* Non permanent RAM data buffer */,
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0064u,     /* NV block Base number (defined by FEE/EA) */
        10u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_OFF
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_HwTqArbn_HwTqArbnEOLCh1OffsetTrimData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_HwTqArbn_HwTqArbnEOLCh1OffsetTrimData /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0066u,     /* NV block Base number (defined by FEE/EA) */
        10u,    /* Length of the block in bytes */ /* NXTR MANUAL EDIT */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_TrqCmdScl_TorqueCmdSF_Uls_f32 */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_TrqCmdScl_TorqueCmdSF_Uls_f32 /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x0068u,     /* NV block Base number (defined by FEE/EA) */
        8u,    /* Length of the block in bytes */ /* NXTR MANUAL EDIT */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_PsaAgArbn_PsaAgArbnLrndOffsData */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_PsaAgArbn_PsaAgArbnLrndOffsData /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x006Au,     /* NV block Base number (defined by FEE/EA) */
        10u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
    
    /* block descriptor user block Rte_NvmBlock_ActivePull_PullCmpLTComp_HwNm_f32 */
    ,{
        (NvM_RamAddressType)&NvMP_Rte_ActivePull_PullCmpLTComp_HwNm_f32 /* pointer to the RAM data buffer */, /* NXTR MANUAL EDIT */
        NULL_PTR /* no ROM default data block */,
        NULL_PTR, /* no Job End notification callback */
        NULL_PTR, /* Pointer to the CRC buffer */
        0x006Cu,     /* NV block Base number (defined by FEE/EA) */
        4u,    /* Length of the block in bytes */
        1u,    /* Number of multiple blocks (depends on Mngmt type) */
        127u,/* Block Priority */
        MEMIF_Fee,                                 /* Device Id (defined by MemIf) */
        NVM_BLOCK_NATIVE,/* Management Type */
            NVM_BLOCK_USE_CRC_OFF,
        ( /* Flags */
            NVM_CALC_RAM_BLOCK_CRC_OFF |      
            NVM_BLOCK_WRITE_PROT_OFF |         
            NVM_BLOCK_WRITE_BLOCK_ONCE_OFF |  
            NVM_RESISTANT_TO_CHANGED_SW_ON |  
            NVM_SELECT_BLOCK_FOR_READALL_ON
        ), /* Flags */
            1        /* Is ROM DefaultBlock */
    }
/*</NVM_DESCRIPTOR_TABLE_CONFIG>*/
    };

#if(NVM_CFG_CHECK_RAM_BLOCK_LENGTHS == STD_ON)
   /* The table containing each RAM block's effective (i.e. CRC size subtracted, if necessary) length.
      Since, for very small RAM block's this length may become negative, it is signed.
      A value smaller than -128 indicates: Don't check this block (no RAM block given).
    */
   static CONST(sint32, NVM_CONFIG_CONST) NvM_RamBlockLengthTable_at[NVM_TOTAL_NUM_OF_NVRAM_BLOCKS] =
    {
        -128
/*<NVM_CONFIG_RAMBLOCK_SIZE/>*/

    };
#endif

#if(NVM_CFG_CHECK_ROM_BLOCK_LENGTHS == STD_ON)
   /* The table containing each ROM block's length.
      Though these lengths are alway positive, the type is signed (because of RAM block lengths).
      A value equal to or smaller than -128 indicates: Don't check this block (no RAM block given).
    */
    static CONST(sint32, NVM_CONFIG_CONST) NvM_RomBlockLengthTable_at[NVM_TOTAL_NUM_OF_NVRAM_BLOCKS] =
    {
        -128,
        -128 /* ConfigBlock */

    };
#endif

#define NVM_STOP_SEC_CONST_DESCRIPTOR_TABLE
#include "MemMap.h"

#define NVM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"
    #if(NVM_API_CONFIG_CLASS != NVM_API_CONFIG_CLASS_1)

            /* Job Queue used for normal and high prio jobs */
            VAR(NvM_QueueEntryType, NVM_PRIVATE_DATA)
                NvM_JobQueue_at[NVM_SIZE_STANDARD_JOB_QUEUE + NVM_SIZE_IMMEDIATE_JOB_QUEUE];

    #endif

      /* Crc job queue. It's just a bit string */
    VAR(NvM_CrcQueueEntryType, NVM_CONFIG_DATA) NvM_CrcQueue_at[NVM_SIZE_CRC_JOB_QUEUE];

#define NVM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"

#define NVM_START_SEC_VAR_POWER_ON_INIT_UNSPECIFIED
#include "MemMap.h"

    /* array of RAM Block Management areas, defined to be usable in block descriptor table */
    VAR(NvM_RamMngmtAreaType, NVM_CONFIG_DATA) NvM_BlockMngmtArea_at[NVM_TOTAL_NUM_OF_NVRAM_BLOCKS];

	/* management area for DCM blocks */
    VAR(NvM_RamMngmtAreaType, NVM_CONFIG_DATA) NvM_DcmBlockMngmt_t;

#define NVM_STOP_SEC_VAR_POWER_ON_INIT_UNSPECIFIED
#include "MemMap.h"


#define NVM_START_SEC_CODE
#include "MemMap.h"

/*!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!   Function name: NvM_EnterCriticalSection()
!
!-----------------------------------------------------------------------------
!   Function Description: Lock resources
!-----------------------------------------------------------------------------
!   Module Global:  none
!   Parameter:      none
!   Returnvalue:    none
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
FUNC(void, NVM_PRIVATE_CODE) NvM_EnterCriticalSection(void)
{
    /* do what ever was defined to do for locking the resourcees */
    /*<NVM_LOCK_RESOURCE/>*/ SchM_Enter_NvM(NVM_EXCLUSIVE_AREA_0);
}


/*!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!   Function name: NvM_ExitCriticalSection()
!
!-----------------------------------------------------------------------------
!   Function Description: Unlock resources
!-----------------------------------------------------------------------------
!   Module Global:  none
!   Parameter:      none
!   Returnvalue:    none
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
FUNC(void, NVM_PRIVATE_CODE) NvM_ExitCriticalSection(void)
{
    /* do what ever was defined to do for unlocking the resourcees */
    /*<NVM_UNLOCK_RESOURCE/>*/ SchM_Exit_NvM(NVM_EXCLUSIVE_AREA_0);
}

#if(NVM_USE_CRC16 == STD_ON)
    static FUNC(void, NVM_PRIVATE_CODE)  NvM_Crc_Crc16_Calculate(NvM_ConstRamAddressType data_pt, uint16 length, NvM_CrcValuePtrType currCrc)
    {
        /* Pointer cast is necessary for efficiency reasons. 
         * We cast to a "smaller" type with less alignment requirements; it is harmless */
        typedef P2VAR(uint16, AUTOMATIC, NVM_CRC_BUFFER_PTR_CLASS) NvM_Crc16PtrType;
        *(NvM_Crc16PtrType)currCrc = Crc_CalculateCRC16(data_pt, length, *(NvM_Crc16PtrType)currCrc);
    }

    static FUNC(boolean, NVM_PRIVATE_CODE) NvM_Crc_Crc16_Compare(NvM_CrcBufferConstPtrType crc1, NvM_CrcValueRefType crc2)
    {
        return ((crc1[0] == crc2[0]) && (crc1[1] == crc2[1]));
    }

    static FUNC(void, NVM_PRIVATE_CODE) NvM_Crc_Crc16_CopyToBuffer (NvM_CrcBufferPtrType dest, NvM_CrcValueRefType src)
    {
        dest[0] = src[0];
        dest[1] = src[1];
    }
#endif

#if(NVM_USE_CRC32 == STD_ON)
    static FUNC(void, NVM_PRIVATE_CODE)  NvM_Crc_Crc32_Calculate(NvM_ConstRamAddressType data_pt, uint16 length, NvM_CrcValuePtrType currCrc)
    {
        *currCrc = Crc_CalculateCRC32(data_pt, length, (*currCrc) ^ NVM_CRC32_XOR_VALUE);
    }

    static FUNC(boolean, NVM_PRIVATE_CODE) NvM_Crc_Crc32_Compare(NvM_CrcBufferConstPtrType crc1, NvM_CrcValueRefType crc2)
    {
        return ((crc1[0] == crc2[0]) && (crc1[1] == crc2[1]) && (crc1[2] == crc2[2]) && (crc1[3] == crc2[3]));
    }

    static FUNC(void, NVM_PRIVATE_CODE) NvM_Crc_Crc32_CopyToBuffer (NvM_CrcBufferPtrType dest, NvM_CrcValueRefType src)
    {
        dest[0] = src[0];
        dest[1] = src[1];
        dest[2] = src[2];
        dest[3] = src[3];
    }
#endif


/*<NVM_CFG_BLOCK_INT_CBK_DEF/>*/



#define NvM_LengthCheck(nvBlockLen, ramRomLen) ((nvBlockLen) == (ramRomLen))

#if(NVM_DEV_ERROR_DETECT == STD_ON)
#if((NVM_CFG_CHECK_ROM_BLOCK_LENGTHS == STD_ON) || (NVM_CFG_CHECK_RAM_BLOCK_LENGTHS == STD_ON))
    static FUNC(uint8_least, NVM_PRIVATE_CODE) NvM_CfgCheckBlockLengthsGeneric(P2CONST(sint32, AUTOMATIC, NVM_CONFIG_CONST));

    static FUNC(uint8_least, NVM_PRIVATE_CODE) NvM_CfgCheckBlockLengthsGeneric(
                                                    P2CONST(sint32, AUTOMATIC, NVM_CONFIG_CONST) refLengths)
    {
        uint8_least retVal = FALSE; /* initialize retVal to FALSE (not failed) */

        uint16_least blockId = NVM_TOTAL_NUM_OF_NVRAM_BLOCKS;

        do
        {
            --blockId;
            /* don't check block's length, if the reference length is 0 */
            if(refLengths[blockId] > -128)
            {
                const uint16_least NvLength = NvM_BlockDescriptorTable_at[blockId].NvBlockLength_u16;

                if(!NvM_LengthCheck(NvLength, refLengths[blockId]))
                {
                    /* don't leave the loop, this shall ease debugging */
                    retVal = TRUE; /* check FAILED */
                }
            }
        } while(blockId > 0);

        return retVal;
    }
#endif


    FUNC(uint8_least, NVM_PRIVATE_CODE) NvM_CfgCheckRamBlockLengths(void)
    {
#if(NVM_CFG_CHECK_RAM_BLOCK_LENGTHS == STD_ON)
        return NvM_CfgCheckBlockLengthsGeneric(NvM_RamBlockLengthTable_at);
#else
        return FALSE; /* check not failed */
#endif
    }

    FUNC(uint8_least, NVM_PRIVATE_CODE) NvM_CfgCheckRomBlockLengths(void)
    {
#if(NVM_CFG_CHECK_ROM_BLOCK_LENGTHS == STD_ON)
        return NvM_CfgCheckBlockLengthsGeneric(NvM_RomBlockLengthTable_at);
#else
        return FALSE; /* check not failed */
#endif
    }
#endif

#define NVM_STOP_SEC_CODE
#include "MemMap.h"


/* ---- End of File ------------------------------------------------------- */
