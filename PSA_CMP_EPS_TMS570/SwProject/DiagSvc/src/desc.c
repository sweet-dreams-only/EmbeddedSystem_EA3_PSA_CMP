/* -----------------------------------------------------------------------------
  Filename:    desc.c
  Description: Implementation of CANdesc.
                
                Manufacturer: PSA
                EcuDocFile:   C:\Components\PSA_CMP\PSA_CMP_EPS_TMS570\Tools\AsrProject\Config\System\PSA_BMPV.cdd
                Variant:      CommonDiagnostics

  Generated by CANdelaGen, Mon Apr 30 08:11:20 2018
 
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2001-2012 by Vctr Informatik GmbH. All rights reserved.
 
  This software is copyright protected and proprietary to Vctr Informatik 
  GmbH.
  
  Vctr Informatik GmbH grants to you only those rights as set out in the 
  license conditions.
  
  All other rights remain with Vctr Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
    &&&~ Includes
 ----------------------------------------------------------------------------- */

/* Physical layer specific API */
#include "v_inc.h"
/* -- V_NULL Definition -- */
#if !defined(V_NULL)
# define V_NULL                                                      0
#endif

#include "desc.h"
#include "appdesc.h"

/*lint -function(exit,ApplDescFatalError)*/

#if defined (DESC_ENABLE_DOBT_SUPPORT)
/* include of DOBT (Diagnostic Onboard Tester) prototypes */
# include "dobt.h"
#endif



/* -----------------------------------------------------------------------------
    &&&~ Configuration switches
 ----------------------------------------------------------------------------- */

/* Default settings */
#if !defined(DESC_ENABLE_EXTERNAL_CHECK_TA) && \
    !defined(DESC_DISABLE_EXTERNAL_CHECK_TA)
# define DESC_DISABLE_EXTERNAL_CHECK_TA
#endif

#define DESC_DISABLE_MULTI_TP_CHANNEL_SUPPORT
/* By default there is need of this switch */
#if !(defined (DESC_ENABLE_OEM_MH_MULTI_CALL_PROTECTION) || \
    defined (DESC_DISABLE_OEM_MH_MULTI_CALL_PROTECTION))
# define DESC_ENABLE_OEM_MH_MULTI_CALL_PROTECTION
#endif

#if defined (DESC_ENABLE_PID_LIST_MODE) || \
    defined (DESC_ENABLE_SIM_PID_LIST_MODE) || \
    defined (DESC_ENABLE_PERIODIC_MODE) || \
    defined (DESC_ENABLE_ROUTINE_CONTROL_MODE) || \
    defined (DESC_ENABLE_MEMORY_BY_ADDRESS_MODE)
# define DESC_ENABLE_PROCESSING_DONE_REDIRECTOR
#else
# define DESC_DISABLE_PROCESSING_DONE_REDIRECTOR
#endif



/* -----------------------------------------------------------------------------
    &&&~ Preprocessor constants (defines)
 ----------------------------------------------------------------------------- */

#define DESC_MAIN_VERSION                                            0x05
#define DESC_SUB_VERSION                                             0x07
#define DESC_BUGFIX_VERSION                                          0x44
/* Compatibility for older versions */
#if !defined(VSTDLIB__COREHLL_VERSION)
# define VSTDLIB__COREHLL_VERSION                                    0x00
#endif

#if (VSTDLIB__COREHLL_VERSION >= 0x216) && \
    defined (VSTD_ENABLE_INTCTRL_HANDLING)
/* VStdLib will be used */
# define DescInterruptDisable()                                      VStdSuspendAllInterrupts()
# define DescInterruptRestore()                                      VStdResumeAllInterrupts()
#else
# define DescInterruptDisable()                                      (CanGlobalInterruptDisable())
# define DescInterruptRestore()                                      (CanGlobalInterruptRestore())
#endif

#ifndef V_BOOL_EXPR
# define V_BOOL_EXPR(exp)                                            ((DescBool)((exp)?kDescTrue:kDescFalse))
#endif

/* This magic number provides inter CANdesc generation process consistency check.All CANdesc files must have the same one. */
#define DESC_IMPLEMENTATION_MAGIC_NUMBER                             13716

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# define kDescDebugPatternLen                                        2
#else
# define kDescDebugPatternLen                                        0
#endif

/* patterns for owerwrite tests */
#define kDescAssertBufferLenPattern0                                 (vuint8)0xbe
#define kDescAssertBufferLenPattern1                                 (vuint8)0xda

/* Generation consitency check */
#if (DESC_PUBLIC_INTERFACE_MAGIC_NUMBER != DESC_IMPLEMENTATION_MAGIC_NUMBER)
# error "desc.h doesn't match the desc.c generation time!"
#endif

#if (DESC_APPLICATION_INTERFACE_MAGIC_NUMBER != DESC_IMPLEMENTATION_MAGIC_NUMBER)
# error "appdesc.h doesn't match the desc.c generation time!"
#endif

#if defined(VGEN_ENABLE_VSTDLIB) || defined(V_ENABLE_VSTDLIB)
/* VStdLib is available */
#else
# error "Error in File v_cfg.h: V_ENABLE_VSTDLIB (VGEN_ENABLE_VSTDLIB) must be defined!"
#endif

#if defined(DESC_ENABLE_PID_NRC_ALL_ON_WRONG_SESSION) && \
    !defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION)
# error "Required switch DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION not set!"
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define kDescTpNumContexts                                          2
#else
# define kDescTpNumContexts                                          1
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define DESC_TPCONTEXT_PARAM_TYPE_ONLY                              vuint8
# define DESC_TPCONTEXT_PARAM_TYPE_FIRST                             vuint8,
# define DESC_TPCONTEXT_PARAM_VALUE                                  tpContext
# define DESC_TPCONTEXT_PARAM_ONLY                                   tpContext
# define DESC_TPCONTEXT_PARAM_FIRST                                  tpContext,
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY                        DESC_TPCONTEXT_PARAM_TYPE_ONLY DESC_TPCONTEXT_PARAM_ONLY
# define DESC_TPCONTEXT_PARAM_DEF_LOCAL                              DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY;
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_FIRST                       DESC_TPCONTEXT_PARAM_TYPE_ONLY DESC_TPCONTEXT_PARAM_ONLY,
# define DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(contextConst)             contextConst
# define DESC_TPCONTEXT_PARAM_WRAPPER_FIRST(contextConst)            contextConst,
# define DESC_TPCONTEXT_PARAM_WRAPPER_INDEX(contextConst)            contextConst
# define DESC_TPCONTEXT_PARAM_DUMMY_USE                              DESC_IGNORE_UNREF_PARAM(DESC_TPCONTEXT_PARAM_ONLY)
#else
# define DESC_TPCONTEXT_PARAM_TYPE_ONLY                              void
# define DESC_TPCONTEXT_PARAM_TYPE_FIRST
# define DESC_TPCONTEXT_PARAM_VALUE                                  ((vuint8)0)
# define DESC_TPCONTEXT_PARAM_ONLY
# define DESC_TPCONTEXT_PARAM_FIRST
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY                        void
# define DESC_TPCONTEXT_FORMAL_PARAM_DEF_FIRST
# define DESC_TPCONTEXT_PARAM_DEF_LOCAL
# define DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(contextConst)
# define DESC_TPCONTEXT_PARAM_WRAPPER_FIRST(contextConst)
# define DESC_TPCONTEXT_PARAM_WRAPPER_INDEX(contextConst)            0
# define DESC_TPCONTEXT_PARAM_DUMMY_USE
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
# define kDescDebugNeedTpRxChannel_BusyRepReq                        1
# define kDescDebugNeedTpTxChannel_BusyRepReq                        1
#else
# define kDescDebugNeedTpRxChannel_BusyRepReq                        0
# define kDescDebugNeedTpTxChannel_BusyRepReq                        0
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define kDescDebugNeedTpRxChannel_ParallelObd                       1
# define kDescDebugNeedTpTxChannel_ParallelObd                       1
#else
# define kDescDebugNeedTpRxChannel_ParallelObd                       0
# define kDescDebugNeedTpTxChannel_ParallelObd                       0
#endif

/* Check if TP has enough communication channels */
#define kDescNeededRxTpChannels                                      (kDescDebugNeedTpRxChannel_BusyRepReq + kDescDebugNeedTpRxChannel_ParallelObd + 1)
#define kDescNeededTxTpChannels                                      (kDescDebugNeedTpTxChannel_BusyRepReq + kDescDebugNeedTpTxChannel_ParallelObd + 1)

/* Use defaults */
/* CAN channel to TP-channel mapping */
#if !defined(kDescCan2TpChannel_0)
# define kDescCan2TpChannel_0                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_1)
# define kDescCan2TpChannel_1                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_2)
# define kDescCan2TpChannel_2                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_3)
# define kDescCan2TpChannel_3                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_4)
# define kDescCan2TpChannel_4                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_5)
# define kDescCan2TpChannel_5                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_6)
# define kDescCan2TpChannel_6                                        kTpNoChannel
#endif
#if !defined(kDescCan2TpChannel_7)
# define kDescCan2TpChannel_7                                        kTpNoChannel
#endif


#if defined (TP_ECU_NUMBER)
# define kDescEcuNumber                                              TP_ECU_NUMBER /* Use the simple macro */
#else
# define kDescEcuNumber                                              (TP_RX_ECU_NR(0))
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define kDescUsdtNetFuncInfPoolRef                                  (vuintx)(kTpRxChannelCount)
#else
# define kDescUsdtNetFuncInfPoolRef                                  kDescPrimContext
#endif
#define kDescUsdtNetSecInfoPool                                      (vuintx)(kDescNumContexts - 1)

#if defined (DESC_ENABLE_PARALLEL_OBD)
# define DescGetConnectionOfContext(tpContext)                       (g_descDescConnections[tpContext])
#else
# define DescGetConnectionOfContext(tpContext)                       kDescDiagConnection
#endif

#if defined (DESC_ENABLE_DOBT_SUPPORT)
# define DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_NAME, dataPtr, dataLen) (DOBTTransmit(TP_CHANNEL_TX_PARAM_FIRST (dataPtr), (dataLen)))
#else
# define DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_NAME, dataPtr, dataLen) (TpTransmit(TP_CHANNEL_TX_PARAM_FIRST (dataPtr), (dataLen)))
#endif

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# define TP_CHANNEL_RX_PARAM_VALUE                                   TP_CHANNEL_RX_PARAM_NAME
# define TP_CHANNEL_RX_PARAM_ONLY                                    TP_CHANNEL_RX_PARAM_NAME
# define TP_CHANNEL_RX_PARAM_FIRST                                   TP_CHANNEL_RX_PARAM_NAME,

# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
#  define TP_CHANNEL_TX_PARAM_VALUE                                  TP_CHANNEL_TX_PARAM_NAME
#  define TP_CHANNEL_TX_PARAM_ONLY                                   TP_CHANNEL_TX_PARAM_NAME
#  define TP_CHANNEL_TX_PARAM_FIRST                                  TP_CHANNEL_TX_PARAM_NAME,
# else
#  if defined(DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
#   define TP_CHANNEL_TX_PARAM_VALUE                                 TP_CHANNEL_TX_PARAM_NAME
#  else
#   define TP_CHANNEL_TX_PARAM_VALUE                                 0
#  endif
#  define TP_CHANNEL_TX_PARAM_ONLY                                   TP_CHANNEL_TX_PARAM_VALUE
#  define TP_CHANNEL_TX_PARAM_FIRST                                  TP_CHANNEL_TX_PARAM_VALUE,
# endif
#else
# define TP_CHANNEL_RX_PARAM_VALUE                                   0
# define TP_CHANNEL_RX_PARAM_ONLY
# define TP_CHANNEL_RX_PARAM_FIRST
# define TP_CHANNEL_TX_PARAM_VALUE                                   0
# define TP_CHANNEL_TX_PARAM_ONLY
# define TP_CHANNEL_TX_PARAM_FIRST
# define tpTxChannel                                                 0
# define tpRxChannel                                                 0
#endif
/* check TPMC settings */
#if defined (VGEN_ENABLE_TP_ISO_MC)
# if (kTpRxChannelCount < kDescNeededRxTpChannels)
#  error "Not enough TP channels, please increase the number of Rx channels under TP Options!"
# endif

# if (kTpTxChannelCount < kDescNeededTxTpChannels)
#  error "Not enough TP channels, please increase the number of Tx channels under TP Options!"
# endif
#endif

#if defined (TP_ENABLE_EXTENDED_ADDRESSING) && !defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
# error "Extended Addressing requires the a newer version of TPMC in combination with a newer GenTool"
#endif

#if defined( DESC_ENABLE_OVERRIDE_TP_MA_CHECK)
#else
# if defined(TP_ENABLE_MULTIPLE_ADDRESSING)
#  if defined(TP_ENABLE_MIXED_11_ADDRESSING) && \
      defined(TP_ENABLE_NORMAL_ADDRESSING)
/* OK */
#  else
#   error "Not supported yet!"
#  endif
# endif
#endif

#if defined(DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND) && defined (DESC_ENABLE_PARALLEL_OBD)
# error "Multi CAN workaround can not be used together with parallel OBD feature!"
#endif

/* All functions are internal - generate the static declarator. */
#define DESCNET_USDT_STATIC                                          static
/* Used for additional information about each network */
#define kDescUsdtNetInvalidDescContext                               (t_descHandle)(0xFF)

/* Current diagnostic connection status */
#define kDescDescConnectionStateIdle                                 ((vuint8)0x00)
#define kDescDescConnectionStateActive                               ((vuint8)0x01)

#if !defined (kDescNrcResponsePending)
# define kDescNrcResponsePending                                     0x78
#endif

#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE)
# define kDescReadDynPidConnStateActive                              ((vuint8)(kDescDescConnectionStateActive<<kDescReadDynPidContext))
#else
# define kDescReadDynPidConnStateActive                              ((vuint8)(0))
#endif
#if defined (DESC_ENABLE_ROE_SUPPORT)
# define kDescRoeConnStateActive                                     ((vuint8)((kDescDescConnectionStateActive<<kDescRoeHelperContext) | \
                                                                     (kDescDescConnectionStateActive<<kDescRoeProcessorContext)))
#else
# define kDescRoeConnStateActive                                     ((vuint8)(0))
#endif

/* Default setting for "response on request" (phys - yes, func - no) */
#define kDescDefaultResOnReq                                         0x01

/* TP wrapper states */
#define kDescMainReception                                           0x01
#define kDescMainTransmission                                        0x02
#define kDescAddReception                                            0x03
#define kDescAddTransmission                                         0x04


/* Current transfer mode */
#define kDescTxModeIdle                                              0x00
#define kDescTxModeRegularRes                                        0x01
#define kDescTxModeSpecialRes                                        0x02
#define kDescTxModeRcrRpRes                                          0x04
#define kDescTxModePeriodicRes                                       0x08
#define kDescTxModeRoeResponder                                      0x10

/* RCR-RP response descriptor */
#define kDescForcedRcrRpIdle                                         0x00
#define kDescForcedRcrRpCharged                                      0x01

/* Use the worst case for the first frame length (nromal addressing with 6Byte payload) */
#define kDescFirstFrameDataLength                                    6

/* Single frame length calculation (needed for the CopyToCan assertion check)*/
/* The FF has one byte for TP usage more, 
* so the data for SF are with one byte more */
#define kDescSingleFrameDataLength                                   ((vuint8)(kDescFirstFrameDataLength + 1))

#define kDescNumPhysReqParallel                                      1
#define kDescNumFuncReqContexts                                      0
#define kDescNumPhysReqContexts                                      1
/* Transport layer abstract transmission statuses */
#define kDescTxSuccess                                               ((vuint8)kDescUsdtNetworkOk)

/* Table offsets */
#define kDescTimingRefP2                                             0
#define kDescTimingRefP2Star                                         1

#define kDescNrcRejectStateSession                                   kDescNrcSubfunctionNotSupportedInActiveSession
#define kDescNrcRejectStateSecurityAccess                            kDescNrcAccessDenied
#define kDescStateGroupNumTransition                                  6
#define kDescStateNoTransition                                       ((DescSetStateIndex)kDescStateGroupNumTransition)

/* SecuredDataTransmission negative response code start number */
#define kDescNrcSecuredDataTransNrcOffset                            0x38

#define kDescNumSvcHeadConstGapBits                                  0
#define kDescNumSvcHeadSessionGapBits                                3
/* The biggest hexadecimal digit as a SID configured for this ECU. */
#define kDescMaxReqSid                                               0x3E
/* The size of the index search table. */
#define kDescSvcIdMapSize                                            63
/* SvcHead table size. */
#define kDescSvcHeadNumItems                                         12
/* SvcInst table size. */
#define kDescSvcInstNumItems                                         71
/* SvcInstHeadEx table size. */
#define kDescSvcInstHeadExtNumItems                                  145
/* Context modes */
#define kDescContextModeNormal                                       0x00
#define kDescContextModePidList                                      0x01
#define kDescContextModePeriodic                                     0x02
#define kDescContextModeRoutineControl                               0x03
#define kDescContextModeMemByAddr                                    0x04


#define kDescInvalidSvcHandle                                        (DescSvcHeadIndex)kDescSvcHeadNumItems
#define kDescInvalidSvcInstHandle                                    (DescSvcInstIndex)kDescSvcInstNumItems

/*  Negative response service ID */
#define kDescNegResSId                                               0x7F

/* Default settings for the bit structure */
#if defined(kDescNumStateSession)
#else
# define kDescNumStateSession                                        0
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# define DescExtractReqExtHeadLen(reqExtHeadLen)                     (reqExtHeadLen)
# define DescExtractResExtHeadLen(resExtHeadLen)                     (resExtHeadLen)
#else
# define DescExtractReqExtHeadLen(reqExtHeadLen)                     0
# define DescExtractResExtHeadLen(resExtHeadLen)                     0
#endif

#if !defined (kDescOemNrcParamIdNotSupportedInSession)
# define kDescOemNrcParamIdNotSupportedInSession                     kDescNrcRequestOutOfRange
#endif

#if !defined (kDescOemNrcParamIdNotSupportedInSecurityState)
# define kDescOemNrcParamIdNotSupportedInSecurityState               kDescNrcAccessDenied
#endif


/*  Length of negative response message */
#define kDescNegResLen                                               ((DescMsgLen)3)
/*  Positive response service ID offset */
#define kDescPosResIdOffset                                          ((vuint8)0x40)

#define kDescNumPostHandlers                                         7
/* Stores the reference of the SvcInstTable entry for the service which stops sessions (starts default session). */
#define kDescDefaultSessionSvcInstEntry                              0
/* The first entry of the SessionControl service is to be found at this position (g_descSvcHead table). */
#define kDescSvcHeadOffsetSDS                                        0
/* The first entry of the SessionControl service is to be found at this position (g_descSvcInst table). */
#define kDescSvcInstOffsetSDS                                        0
/* No NRCs additionally suppressed */
#define DESC_OEM_SUPPRESSED_FUNC_NRC                                 /* Fall through */
#define kDescOemNrcInvalidAddrMethod                                 kDescNrcConditionsNotCorrect

#define kDescNumPids                                                 73
/* Invalid handle after PID lookup */
#define kDescInvalidPidHandle                                        ((DescMemPidInstIndex)kDescNumPids)

/* Multiple PIDs processing specific NRC on too many PID in single request. */
#define kDescOemNrcTooManyPIDs                                       kDescNrcRequestOutOfRange
/* Multiple PIDs processing specific NRC on too long response. */
#define kDescOemNrcResponseTooLong                                   kDescNrcResponseTooLong
#define kDescNumMaxPidList                                           5
/* Precalculated bit field length (in bytes)*/
#define kDescNumPostHdlrQueueBytes                                   (((kDescNumMaxPidList - 1)/ 8) + 1)
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
/* Do not hide the PID */
# define kDescReservedBytesForPid                                    0
#else
/* Do hide the PID */
# define kDescReservedBytesForPid                                    2
#endif



/* -----------------------------------------------------------------------------
    &&&~ Datatype definitions
 ----------------------------------------------------------------------------- */

/*-- TP information types  --*/
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
typedef struct
{
  vuint8 resBuffer[3];
  vuint8 tpRxChannel;
} DescAddResBuffer;

typedef union
{
  vuint8           reqBuffer[7];
  DescAddResBuffer res;
} DescAddBuffer;

typedef struct
{
  vuint8        status;
  DescAddBuffer buffers;
} DescAddChannel;

typedef struct
{
  vuint8         count;
  DescAddChannel channel[kDescNumAddRequestChannels];
} DescAddChannelCtrl;

#endif /* defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)*/

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
typedef struct
{
  DescBitType type:4;
  DescBitType info:4;
} DescTpMemberCtrl;

typedef struct
{
  DescTpMemberCtrl rxPath[kTpRxChannelCount];
  DescTpMemberCtrl txPath[kTpTxChannelCount];
} DescTpCtrl;
#endif /* defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER) */

/* forward declaration of t_descUsdtNetInfoPool */
typedef struct t_descUsdtNetInfoPoolTag t_descUsdtNetInfoPool;
typedef struct t_descUsdtNetInfoPoolTag* t_descUsdtNetInfoPoolPtr;
/* Network dependent data type */
struct t_descUsdtNetInfoPoolTag
{
  t_descUsdtNetBus        busInfo;
  t_descUsdtNetReqType    reqType;
  t_descUsdtNetResType    resType;
  t_descUsdtNetBusHandle  busHandle;
  t_descHandle            descHandle;
  vuint16                 dataLength;

  DescUsdtNetMsg          reqDataPtr;
  DescUsdtNetMsg          resDataPtr;
};

/* ---- Context management state machine ---- */
typedef struct
{
  t_descUsdtNetResult txState;/* Tp ErrorCode */
  DescBitType         contextMode                :3;/* 0x00 - Normal, 0x01 - PIDListProcess */
  DescBitType         isApplError                :1;/* 0x00 - CANdesc NR, 0x01 - APPL NR */
  DescBitType         dummy                      :4;
} DescContextCtrl;

/* ---- Interrupt context management state machine ---- */
typedef struct
{
  t_descUsdtNetInfoPoolPtr infoPoolPtr;
  vuint8             activity                 ;/* 0x00 - Idle, 0x01 - ActiveRx, 0x02 - ActiveProcess, 0x04 - ActiveTxSingleResponse ,0x08 - ActiveTxPeriodicRes, 0x10 - ActiveTxRoeResponder */
#if defined (DESC_ENABLE_FORCE_RCR_RP)
  DescBitType        forcedRcrRpState       :2;/* 0x00 - Idle, 0x01 - Charged, 0x02 - WaitConfirmation */
#endif
  DescBitType        isContextLocked        :1;
} DescInterruptContextCtrl;

/* ---  Timer definitions with 8 Bit CPU optimization  --- */
/* Time T2: */
/* if at least 16 bit CPU - use always 16 bit variables */
/* Time S1: */
typedef vuint16 DescS1Timer;
/* Time T2: */
typedef vuint16 DescT2Timer;

#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT) || defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
/* type definition for Response pending limit timer */
typedef vuint16 DescRcrrpLimitTimer;
#endif

typedef struct DescStateInfoTag
{
  DescStateGroup stateSession : 5;
  DescStateGroup stateSecurityAccess : 2;
  DescStateGroup stateGap_0 : 1;
} DescStateInfo;
#if (kDescStateGroupNumTransition > 255)
  typedef vuint16    DescSetStateIndex;
#else
  typedef vuint8     DescSetStateIndex;
#endif

typedef vuint8 DescSvcHeadIndex; /* Typedef for the SvcHead table indexes- 8/16Bit depeding on its size. */
typedef vuint8_least DescSvcInstIndex; /* Type definition for the SvcInstTable indexes, depending on the SvcInstTable size. */
typedef vuint8 DescMemSvcInstIndex; /* Type definition for the DescMemSvcInstIndex indexes, depending on the SvcInstTable size. */
typedef vuint8 DescPostHandlerIndex; /* Type definition for the Post-handler reference table, depending on its size. */
typedef vuint8_least DescSvcInstHeadExtIndex; /* Type definition for the SvcInstHeadExtTable indexes, depending on the SvcInstTable size. */
typedef vuint8 DescMemSvcInstHeadExtIndex; /* Type definition for the DescMemSvcInstHeadExtIndex indexes, depending on the SvcInstTable size. */
/* Application callbacks (main handler is already defiend in  the desc.h (because of MSCall)) */
typedef void DESC_API_CALL_TYPE (*DescPreHandler)      (DESC_CONTEXT_PARAM_TYPE_ONLY);
typedef void DESC_API_CALL_TYPE (*DescPostHandler)     (DESC_CONTEXT_PARAM_TYPE_FIRST vuint8);

typedef struct
{
  DescBitType                reqHeadByteSpec   :8; /* Each bit represents sub-function/identifier - 0: identifier; 1: any subfunction */
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
  DescBitType                reqHeadExLen      :4; /* Request HeadEx length up to 7 Byte  */
  DescBitType                resHeadExLen      :4; /* Response HeadEx length up to 7 Byte */
#endif
  DescBitType                reqType           :2; /* 0x01: Phys 0x02: Func */
  DescBitType                resOnReq          :2; /* 0x01: Phys 0x02: Func */
  DescBitType                suppPosRes        :1; /* 0x00: No   0x01: Yes  */
  DescBitType                isReqHeadExtEchoed:1; /* 0x00: No   0x01: Yes  */
  DescBitType                isSubFuncInstanced:1; /* 0x00: No   0x01: Yes  */
  DescBitType                hasSubFunc        :1; /* 0x00: No   0x01: Yes  */
#if (kDescNumSvcHeadConstGapBits > 0)
  DescBitType                svcHeadPlaceHolder:kDescNumSvcHeadConstGapBits; /* Gap holder  */
#endif
#if (kDescNumStateSession > 0)
  DescStateGroup             checkSessionState :kDescNumStateSession;/* State group Session on SId level */
#endif
#if (kDescNumSvcHeadSessionGapBits > 0)
  DescBitType                sessionPlaceHolder:kDescNumSvcHeadSessionGapBits; /* Gap holder  */
#endif
#if defined (DESC_ENABLE_MIN_REQ_LEN_CHECK)
  vuint8                  minReqLength;
#endif
/* First item in Service Instance table */
  DescMemSvcInstIndex        svcInstFirstItem;
  DescMemSvcInstHeadExtIndex svcInstHeadExtFirstItem;
} DescSvcHead;

typedef struct
{
  DescMsgLen             reqLen;
  DescMsgAddInfo         msgAddInfo;
#if defined (DESC_ENABLE_AUTO_STATES)
  DescStateInfo          checkState;
# if (kDescStateGroupNumTransition > 0)
  DescSetStateIndex      setStateIndex;
# endif
#endif /* DESC_ENABLE_AUTO_STATES */
#if defined (DESC_ENABLE_PREHANDLER_USAGE)
  DescPreHandlerIndex    preHandlerRef;
#endif
#if defined (DESC_ENABLE_POSTHANDLER_USAGE)
  DescPostHandlerIndex   postHandlerRef;
#endif
  DescMainHandler        mainHandler;
} DescSvcInst;

typedef vuint8_least DescPidInstIndex;
typedef vuint8 DescMemPidInstIndex;
typedef enum
{
  pmAnalyseReasonNone = 0,
  pmAnalyseReasonSession,
  pmAnalyseReasonSecurityState,
  pmAnalyseReasonOther
}DescPidAnalyseFailureReason;

typedef enum
{
  pmClientReadOnce = 0,
  pmClientReadCycle,
  pmClientDynDefine
}DescPidClient;

typedef struct
{
#if defined (DESC_ENABLE_AUTO_STATES)
  DescStateInfo        checkState;
#endif /* DESC_ENABLE_AUTO_STATES */
#if defined (DESC_ENABLE_PID_PREHANDLER_USAGE)
  DescPreHandlerIndex  preHandlerRef;
#endif
  DescMsgAddInfo       msgAddInfo;
}DescPidTinyInfo;

typedef struct
{
  DescMemPidInstIndex  pidHandle;
  DescPidTinyInfo      tinyInfo;
}DescPidClientInfo;

typedef struct
{
  vuint16              reqPid;
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || \
    defined(DESC_ENABLE_PID_LIST_MODE)        || \
    defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
  DescMsgLen           resDataLen;
#endif
  DescPidTinyInfo      tinyInfo;
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
  DescPostHandlerIndex postHandlerRef;
#endif
  DescMainHandler      mainHandler;
} DescPidInst;

typedef struct
{
  DescBitType    pidCount            :8;
  DescBitType    curPid              :8;
  DescBitType    isPidReady          :1;
  DescBitType    isPidProcessed      :1;
  DescBitType    dummyGap            :6;
}DescPidProcessorState;



/* -----------------------------------------------------------------------------
    &&&~ Function prototypes
 ----------------------------------------------------------------------------- */

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
static void CheckTableConsistency(void);
#endif
#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
static void DescDebugIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif

DESCNET_USDT_STATIC void DescUsdtNetIsoTpInitPowerOn(void);
DESCNET_USDT_STATIC void DescUsdtNetIsoTpInit(void);

DESCNET_USDT_STATIC void DescUsdtNetIsoTpStateTask(void);

DESCNET_USDT_STATIC void DescUsdtNetIsoTpPrepareResponse(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void DescUsdtNetIsoTpTransmitResponse(t_descUsdtNetInfoPoolPtr infoPool);
DESCNET_USDT_STATIC void DescUsdtNetIsoTpReleaseInfoPool(t_descUsdtNetInfoPoolPtr infoPool);

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC vuint16 DescUsdtNetIsoTpGetRingBuffTxMinLen(t_descUsdtNetInfoPoolPtr infoPool);
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
static void DescBusyResponseHandler(void);
#endif
#if defined (DESC_ENABLE_PARALLEL_OBD)
static vuint8 DescDispatchServiceContext(vuint8 sid);
#endif
static void DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescUsdtNetIsoTpCopyToCan(TpCopyToCanInfoStructPtr infoStruct);

#if defined(DESC_USDTNET_ENABLE_LONGSERVICE_SUPPORT)
DESCNET_USDT_STATIC void                DescUsdtNetLSFinishReception         (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC void                DescUsdtNetLSFinishTransmission      (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetLSStartReception          (t_descUsdtNetInfoPoolPtr infoPool);
/* Copy data from ringbuffer into network layer */
# if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetLSRingBufferCopyRoutine   (t_descUsdtNetInfoPoolPtr infoPool, DescUsdtNetMsg pDestination, vuint8 dataLength);
# endif
#endif
/* Call backs */
DESCNET_USDT_STATIC void                DescUsdtNetAbsFinishReception         (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC void                DescUsdtNetAbsFinishTransmission      (t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status);
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsStartReception          (t_descUsdtNetInfoPoolPtr infoPool);
/* Copy data from ringbuffer into network layer */
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsRingBufferCopyRoutine   (t_descUsdtNetInfoPoolPtr infoPool, DescUsdtNetMsg pDestination, vuint8 dataLength);
#endif

static void DescNetworkIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#if defined (DESC_ENABLE_SPONTANEOUS_RES)
/* ---- Extended functionality ---- */
static DescBool DescSendSpontaneousResponse(DescMsg resData, DescMsgLen resLen, t_descUsdtNetBus* pBusInfo);
#endif

#if defined(DESC_ENABLE_ROE_USDT_TRANSMITTER)
static void DescDoRoeResponderPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult status);
#endif
#if defined (DESC_ENABLE_POS_RES_ON_SET_SPRMIB)
# define DescIsTesterPresent(infoPool)                               kDescFalse
#else
static DescBool DescIsTesterPresent(t_descUsdtNetInfoPoolPtr infoPool);
#endif

static void DescNetworkInitPowerOn(void);
static void DescNetworkInit(void);

static void DescTransmitRcrRp(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescReleaseContext(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescTimingOnceInit(void);
static void DescTimingIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
static void DescOemNpmTimer(void);
# endif
static void DescNpmProcessQueue(void);
static void DescNpmSetSleepInd(void);
#endif

#if defined(DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
static vuint8_least DescGetSessionStateBitPosition(DescStateGroup sessionState);
#endif
/* Internal interface of session transition 
 * shall be before the generated code which defines the macro to nothing if
 * if it doesn't exist.
 */
#if defined(DESC_ENABLE_AUTO_STATES)
static void DescOnTransitionStateSession(DescStateGroup newState, DescStateGroup currentState);
#endif

static void DescStateOnceInit(void);

/* ---- Providing interface between subcomponents Dispatch and Network ---- */
static void DescDoPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult status);
/* Internal API for INIT */
static void DescDispatcherIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
static DescSvcInstIndex DescFindSvcInst(DescConstPtr reqHeadPtr, V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, vuint8_least* failedByteMask);
#endif
static DescSvcHeadIndex DescFindSvc(DescMsgItem reqSvcId);

static void DescDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
static vuint8_least DescGetSvcInstHeadExtEntrySize(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead);
# if defined(C_COMP_NEC_78K0_AFCAN)
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
# else
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef);
# endif
#endif

#if defined (DESC_ENABLE_PROCESSING_DONE_REDIRECTOR)
static void DescFinalProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif

static void DescContextStateTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescResponseTimeoutTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DESC_API_CALLBACK_TYPE DescOemControlDefault_Session(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemControlProgramming_Session(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemControlExtended_Diagnostic_Session(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemControlRemote_Access_Session(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemControlNxtr_Session(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescReadDataByIdentifier(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemControlEnableRxAndTx(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescOemControlEnableRxAndDisableTx(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescGenSendTesterPresent(DescMsgContext* pMsgContext);
static void DESC_API_CALLBACK_TYPE DescPostReadDataByIdentifier(vuint8 status);
static void DESC_API_CALLBACK_TYPE DescOemPostCommonCommCtrlProcess(vuint8 status);
#if defined (DESC_ENABLE_ANY_PREHANDLER_USAGE)
static void DESC_API_CALL_TYPE DescDummyPreHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
#endif
#if defined (DESC_ENABLE_ANY_POSTHANDLER_USAGE)
static void DESC_API_CALL_TYPE DescDummyPostHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status);
#endif

static void DescOemCommonCommCtrlProcess(vuint8 reqInfo, DescMsgContext *pMsgContext);
static void DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_ONLY);
#if defined (DESC_ENABLE_DYN_COM_CTRL_PARAM)
static DescBool DescOemCheckAndExtractCommTypeParam(DescOemCommControlInfo * pCommControlInfo, DescMsgItem comType);
#endif

/* Function prototypes */
static void DescOemPrepareSessionControl(DescMsgContext *pMsgContext, DescStateGroup targetSession);
#if defined (DESC_ENABLE_COMMON_OEM_POST_HANDLER)
static void DescOemCommonSessionPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status, DescStateGroup newSession);
#endif

static DescPidInstIndex DescPmGetPidPoolHandle   (vuint16 pid);
static DescPidInstIndex DescPmGetAvailablePidHandle(vuint16 pid);
#if defined(DESC_ENABLE_PERIODIC_MODE)
static DescPidInstIndex DescPmGetSupportedPidClientHandle(vuint16 pid, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable);
#endif
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || defined(DESC_ENABLE_PERIODIC_MODE)
static DescPidInstIndex DescPmGetPidClientHandle (DescPidInstIndex pidInfoHandle, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable);
#endif
static DescPidAnalyseFailureReason DescPmAnalysePid(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST V_MEMROM1 DescPidTinyInfo V_MEMROM2 V_MEMROM3 * pRefTinyInfo);
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || \
    defined(DESC_ENABLE_PID_LIST_MODE)        || \
    defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
static DescMsgLen       DescPmGetPidResponseLen  (DescPidInstIndex pidHandle);
#endif

static void DescIterInitPidListProcessor(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);

static void DescPidProcessorTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescPidProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);
static void DescPidDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY);



/* -----------------------------------------------------------------------------
    &&&~ RAM definitions
 ----------------------------------------------------------------------------- */

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
static vuint8 g_descUsdtNetTpTxChannel[kDescTpNumContexts];
# endif
#endif
static t_descUsdtNetInfoPool  g_descUsdtNetInfoPoolIsoTp[kDescNumContexts];
#if defined (DESC_ENABLE_PARALLEL_OBD)
static t_descUsdtNetInfoPoolPtr g_busInfoPoolRxRef[kTpRxChannelCount + 1]; /* rx channels + one functional */
#endif
static t_descUsdtNetInfoPoolPtr g_busInfoPoolTxRef[kTpTxChannelCount];

DESC_USDTNET_PRVT_DEF_VAR_FAR(vuint8) g_descBuffer[kDescTpNumContexts][kDescPrimBufferLen];

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
/* Tp state controller  */
static DescTpCtrl g_descTpCtrl;
#endif
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
/* Parallel request responder state controller 
 use memory model specific define, since there are embedded Rx and Tx Buffers insider.
*/
DESC_USDTNET_PRVT_DEF_VAR_FAR(DescAddChannelCtrl) g_descAddChannelCtrl;
#endif

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
# if defined(C_COMP_COSMIC_MCS12X_MSCAN12) && \
     defined(V_ENABLE_USED_GLOBAL_VAR)
DESC_USDTNET_PRVT_DEF_VAR_FAR(vuint8) g_descCopyToCanData[7];
# endif
#endif

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
/* In:
* - single channel system - flag for already activated DPM user.
* - multi  channel system - bit mapped register for already activated DPM users (channel specific).
*/
static vuint8_least  g_descCanChannelMap;
/* The same meaning of the above bit-map, but used for DPM manipulation at task level */
static vuint8_least  g_descCanChannelMapQueue;
#endif
/* Global storage of the user response information */
#if defined (DESC_ENABLE_SPONTANEOUS_RES)
static t_descUsdtNetInfoPool  g_descUsdtNetSpontanResInfoPool;
#endif
/* Extra buffer for the "response pending" negative response */
DESC_PRVT_DEF_VAR_FAR(DescMsgItem) g_descRcrrpBuffer[kDescNumContexts][3];

#if (kDescNumContexts > 1)
/* Each bit represents a diagnostic connection activity (maximum n parallel (n = 8)):
* Bit[  0]: Physical_0
* ..........
* Bit[n-2]: Physical_0
* Bit[n-1]: Functional
*/
static vuint8 g_descActiveRequestsMask;
#endif

/* State machine of each received request */
static DescContextCtrl          g_descContextCtrl[kDescNumContexts];
static DescInterruptContextCtrl g_descInterruptContextCtrl[kDescNumContexts];
#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
static vuint8                   g_descTesterAddress[kDescNumContexts];
#endif

#if defined(DESC_ENABLE_ALL_RES_AFTER_RCRRP)
static DescBool  g_descRcrrpSent[kDescNumContexts];
#endif

#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT) || defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
/* Limitation timer/counter for maximal time window for "response pending" 
* negative responses that will be sent. */
static DescRcrrpLimitTimer g_descRcrrpLimitCounter[kDescNumContexts];
#endif

/* T2 timer for response pending support */
static DescT2Timer  g_descT2Timer[kDescNumContexts];
/* "Tester present" timer */
static DescS1Timer  g_descS1Timer;

#if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
# define kDescP2InitValue                                            (g_descP2TicksTable[g_descCurrSessionNumber][kDescTimingRefP2])
# define kDescP2ReloadValue                                          (g_descP2TicksTable[g_descCurrSessionNumber][kDescTimingRefP2Star])
#else
# define kDescP2InitValue                                            kDescP2Ticks
# define kDescP2ReloadValue                                          kDescP2StarTicks
#endif

#if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
/* Global variable to store the converted session number value */
static vuint8 g_descCurrSessionNumber;
#endif

/* Timer reload event flag */
static DescBool g_descDoReloadS1Timer;

#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
static vuint16 g_descNpmTimer;
#endif

/* State machine of CANdesc described by CANdelaStudio */
static DescStateInfo g_descCurState;

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL) && \
    defined (DESC_ENABLE_OEM_MH_MULTI_CALL_PROTECTION)
static DescBool g_descIsOemMainHdlrAlreadyCalled;
#endif

/* Store the service entry index for the current request */
static DescSvcHeadIndex      g_descCurReqSvc[kDescNumContexts];

/* Store the instance entry index for the current request */
static DescMemSvcInstIndex   g_descCurReqSvcInst[kDescNumContexts];

/* Context information to accompany the complete request processing */
static DescMsgContext     g_descMsgContext[kDescNumContexts];

/* Store detected diagnostic error */
static DescNegResCode     g_descNegResCode[kDescNumContexts];

#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
/* Pointer of main handlers */
static DescMainHandler    g_descRecallHandler[kDescNumContexts];
#endif

#if defined(DESC_ENABLE_GENERIC_USER_POST_HANDLER_SUPPORT)
/* Store the SID byte for the application if the post-handler is used */
static DescMsgItem        g_descUserSIdBackup[kDescNumContexts];
#endif


/* Shared communication control info */
static DescOemCommControlInfo  g_descCommControlInfo;

/* Local context information storing (for each DID) */
static DescMsgContext        g_descPidMsgContext[kDescNumContexts];
static DescPidProcessorState g_descPidProcessorState[kDescNumContexts];
/* The current list of PID references */
static DescMemPidInstIndex   g_descPidList[kDescNumContexts][kDescNumMaxPidList];
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
/* Bit-mapped post handler queue */
static vuint8                g_descPidPostHdlrQueue[kDescNumPostHdlrQueueBytes];
#endif



/* -----------------------------------------------------------------------------
    &&&~ ROM definitions
 ----------------------------------------------------------------------------- */

/* Version information */
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 g_descMainVersion     = (vuint8) DESC_MAIN_VERSION;
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 g_descSubVersion      = (vuint8) DESC_SUB_VERSION;
V_MEMROM0 V_MEMROM1 vuint8 V_MEMROM2 g_descBugFixVersion   = (vuint8) DESC_BUGFIX_VERSION;

#if defined(DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descCan2TpChannelMap[kDescNumCommChannels] =
{
# if (kDescNumCommChannels >= 1)
  kDescCan2TpChannel_0
# endif
# if (kDescNumCommChannels >= 2)
  ,kDescCan2TpChannel_1
# endif
# if (kDescNumCommChannels >= 3)
  ,kDescCan2TpChannel_2
# endif
# if (kDescNumCommChannels >= 4)
  ,kDescCan2TpChannel_3
# endif
# if (kDescNumCommChannels >= 5)
  ,kDescCan2TpChannel_4
# endif
# if (kDescNumCommChannels >= 6)
  ,kDescCan2TpChannel_5
# endif
# if (kDescNumCommChannels >= 7)
  ,kDescCan2TpChannel_6
# endif
# if (kDescNumCommChannels == 8)
  ,kDescCan2TpChannel_7
# endif
# if (kDescNumCommChannels > 8)
#  error "Too many CAN-channels!!!"
# endif
};
#endif

#if defined(DESC_ENABLE_PARALLEL_OBD)
V_MEMROM0 static V_MEMROM1 vuint8 V_MEMROM2 g_descDescConnections[kDescTpNumContexts] =
{
   kDescDiagConnection
  ,kDescDiagObdConnection
};
#endif

/* Table of all state transitions defined by CANdelaStudio. */
V_MEMROM0 static V_MEMROM1 DescStateInfo V_MEMROM2 g_descStateGroupTransition[kDescStateGroupNumTransition][2] = 
{
  { { 0x1F, 0x02, 0x00 }, { 0x01, 0x01, 0x00 } }, 
  { { 0x1F, 0x02, 0x00 }, { 0x02, 0x01, 0x00 } }, 
  { { 0x1D, 0x02, 0x00 }, { 0x04, 0x01, 0x00 } }, 
  { { 0x1D, 0x02, 0x00 }, { 0x08, 0x01, 0x00 } }, 
  { { 0x1D, 0x02, 0x00 }, { 0x10, 0x01, 0x00 } }, 
  { { 0x00, 0x01, 0x00 }, { 0x00, 0x02, 0x00 } }
};
/* &~MsgTables */
/* Table of reference indexes for fast SID look-up. */
V_MEMROM0 static V_MEMROM1 DescMsgItem V_MEMROM2 g_descSidMap[kDescSvcIdMapSize] = 
{
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x00, 0x01, 0xFF, 0xFF, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x08, 
  0xFF, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0A
};
/* Table of service ID relevant information. */
V_MEMROM0 static V_MEMROM1 DescSvcHead V_MEMROM2 g_descSvcHead[kDescSvcHeadNumItems] = 
{
  { 0x01, 1, 1, 0x03, 0x03, 1, 1, 1, 1, 0x1F, 0x00,  2,  0,  0 } /* $10 */, 
  { 0x01, 1, 1, 0x03, 0x03, 1, 1, 1, 1, 0x14, 0x00,  2,  5,  5 } /* $11 */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0, 0x15, 0x00,  1,  9,  9 } /* $14 */, 
  { 0x01, 1, 1, 0x03, 0x03, 0, 1, 1, 1, 0x1F, 0x00,  2, 10,  9 } /* $19 */, 
  { 0x01, 0, 0, 0x03, 0x03, 0, 1, 0, 0, 0x1F, 0x00,  1, 13, 12 } /* $22 */, 
  { 0x01, 1, 1, 0x01, 0x01, 1, 1, 1, 1, 0x14, 0x00,  2, 14, 12 } /* $27 */, 
  { 0x05, 2, 1, 0x03, 0x03, 1, 0, 1, 1, 0x10, 0x00,  3, 16, 14 } /* $28 */, 
  { 0x07, 2, 2, 0x01, 0x01, 0, 1, 0, 0, 0x14, 0x00,  4, 18, 20 } /* $2E */, 

  { 0x07, 3, 3, 0x01, 0x01, 0, 1, 0, 1, 0x10, 0x00,  4, 50, 84 } /* $2F */, 
  { 0x0D, 3, 3, 0x01, 0x01, 1, 1, 0, 1, 0x14, 0x00,  4, 54, 96 } /* $31 */, 
  { 0x01, 1, 1, 0x03, 0x03, 1, 1, 1, 1, 0x1F, 0x00,  2, 70, 144 } /* $3E */, 
  { 0x00, 0, 0, 0x00, 0x00, 0, 1, 0, 0, 0x00, 0x00,  1, 71, 145 } /* $FF */
};
/* Table of all configured (effectively used) post-handlers. */
V_MEMROM0 static V_MEMROM1 DescPostHandler V_MEMROM2 g_descPostHandlerTable[kDescNumPostHandlers] = 
{
  DescDummyPostHandler, 
  ApplDescPostECUResetHardReset, 
  ApplDescPostECUResetKeyOffOnReset, 
  ApplDescPostECUResetSoftReset, 
  DescOemPostCommonCommCtrlProcess, 
  DescPostReadDataByIdentifier, 
  ApplDescPostClearFaultMemory
};
/* Table of service (instance) relevant information. */
V_MEMROM0 static V_MEMROM1 DescSvcInst V_MEMROM2 g_descSvcInst[kDescSvcInstNumItems] = 
{
  {   2, { 0x03, 0x03, 0 }, { 0x1F, 0x03, 0x00 },                      0,    0, DescOemControlDefault_Session } /* $10 $1 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x1F, 0x03, 0x00 },                      1,    0, DescOemControlProgramming_Session } /* $10 $2 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x1D, 0x03, 0x00 },                      2,    0, DescOemControlExtended_Diagnostic_Session } /* $10 $3 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x1D, 0x03, 0x00 },                      3,    0, DescOemControlRemote_Access_Session } /* $10 $50 */, 
  {   2, { 0x01, 0x01, 0 }, { 0x1D, 0x03, 0x00 },                      4,    0, DescOemControlNxtr_Session } /* $10 $7E */, 
  {   2, { 0x03, 0x03, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    1, ApplDescECUResetHardReset } /* $11 $1 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    2, ApplDescECUResetKeyOffOnReset } /* $11 $2 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    3, ApplDescECUResetSoftReset } /* $11 $3 */, 

  {   2, { 0x03, 0x03, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescECUResetNxtrReset } /* $11 $60 */, 
  {   4, { 0x03, 0x03, 0 }, { 0x15, 0x03, 0x00 }, kDescStateNoTransition,    6, ApplDescClearFaultMemory } /* $14 */, 
  {   3, { 0x03, 0x03, 0 }, { 0x1D, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescRead_Number_of_DTC_By_StatusMaskFaultMemory } /* $19 $1 */, 
  {   3, { 0x03, 0x03, 0 }, { 0x1F, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescRead_by_MaskFaultMemory } /* $19 $2 */, 
  {   6, { 0x03, 0x03, 0 }, { 0x1D, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescRead_DTC_Snapshot_Data_by_DTC_NumberFaultMemory } /* $19 $4 */, 
  {   0, { 0x03, 0x03, 0 }, { 0x1F, 0x03, 0x00 }, kDescStateNoTransition,    5, DescReadDataByIdentifier } /* $22 */, 
  {   2, { 0x01, 0x01, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescSecurityAccessRequestSeedVariantCoding } /* $27 $3 */, 
  {   6, { 0x01, 0x01, 0 }, { 0x14, 0x03, 0x00 },                      5,    0, ApplDescSecurityAccessSendKeyVariantCoding } /* $27 $4 */, 

  {   3, { 0x03, 0x03, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    4, DescOemControlEnableRxAndTx } /* $28 $0 $3 */, 
  {   3, { 0x03, 0x03, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    4, DescOemControlEnableRxAndDisableTx } /* $28 $1 $3 */, 
  {  18, { 0x01, 0x01, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWrite_2101_Variant_Coding_Programmed } /* $2E $21 $1 */, 
  {  25, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteF080_Authentication_Zone } /* $2E $F0 $80 */, 
  {  26, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteF08F_EMC_Standardization_Label } /* $2E $F0 $8F */, 
  {  27, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteF0FE_Identification_Zone } /* $2E $F0 $FE */, 
  {   6, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteF18B_ECUManufacturingDateDataIdentifier } /* $2E $F1 $8B */, 
  {  16, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteF18C_ECUSerialNumberDataIdentifier } /* $2E $F1 $8C */, 

  {   7, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD02_Serial_Communication_Service_Active_Defeats } /* $2E $FD $2 */, 
  {  31, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD12_Current_Mode_Offset_and_Gain } /* $2E $FD $12 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD19_Nxtr_Manufacturing_Enable_Counter_MEC } /* $2E $FD $19 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD1B_Manual_Vehicle_speed_Overide } /* $2E $FD $1B */, 
  {   5, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD1E_Torque_Sensor_Diagnostic_Defeat } /* $2E $FD $1E */, 
  {   5, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD25_Motor_Torque_Scale_Factor } /* $2E $FD $25 */, 
  {   6, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD26_Average_Friction_Learning_Select } /* $2E $FD $26 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD27_Friction_Offset_Output_Defeat } /* $2E $FD $27 */, 

  {   5, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD29_Set_EOL_Friction_Learned } /* $2E $FD $29 */, 
  {   8, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFD30_End_of_Line_Torque_Trim_Value_Digital_SENT } /* $2E $FD $30 */, 
  {   7, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDA1_ECU_Serial_Number } /* $2E $FD $A1 */, 
  {   7, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDA2_EPS_Serial_Number } /* $2E $FD $A2 */, 
  {  15, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDA3_ECU_Hardware_Part_Number } /* $2E $FD $A3 */, 
  {  67, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDAC_Nxtr_Manufacturing_Scratchpad } /* $2E $FD $AC */, 
  {   5, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDAE_Ignition_Counter } /* $2E $FD $AE */, 
  { 259, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDB0_IPM_Cogging_Table_1 } /* $2E $FD $B0 */, 

  { 259, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDB1_IPM_Cogging_Table_2 } /* $2E $FD $B1 */, 
  { 259, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDB2_IPM_Cogging_Table_3 } /* $2E $FD $B2 */, 
  { 259, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDB3_IPM_Cogging_Table_4 } /* $2E $FD $B3 */, 
  {  11, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDB4_Current_Mode_Analog_Ke_R_Ld_Lq } /* $2E $FD $B4 */, 
  {   7, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDB5_Active_Pull_Set_Short_Term_Comp } /* $2E $FD $B5 */, 
  {   7, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDB6_Active_Pull_Set_LongTerm_Comp } /* $2E $FD $B6 */, 
  {  21, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDB7_IPM_Cogging_Table_5 } /* $2E $FD $B7 */, 
  {   7, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFDBA_End_of_Line_Polarity } /* $2E $FD $BA */, 

  {   6, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFEFC_Powerpack_Configuration } /* $2E $FE $FC */, 
  {   5, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescWriteFEFF_Application_Key } /* $2E $FE $FF */, 
  {   4, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescReturnControlFD0D_Motor_Torque_Command_I_O_Control } /* $2F $FD $D $0 */, 
  {   6, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescSetFD0D_Motor_Torque_Command_I_O_Control } /* $2F $FD $D $3 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescReturnControlFD11_Assist_Gain_Command_I_O_Control } /* $2F $FD $11 $0 */, 
  {   6, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescSetFD11_Assist_Gain_Command_I_O_Control } /* $2F $FD $11 $3 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartDF00_Permanent_Control } /* $31 $1 $DF $0 */, 
  {   6, { 0x01, 0x01, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartDF01_Temporary_Control } /* $31 $1 $DF $1 */, 

  {   7, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartF000_Manufacturing_Variables_Reset } /* $31 $1 $F0 $0 */, 
  {   6, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartF001_Clear_Diagnostic_Trouble_Code_NTC_CTC } /* $31 $1 $F0 $1 */, 
  {   5, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartF003_Position_Sensor_EOLCalibration } /* $31 $1 $F0 $3 */, 
  {   5, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartF004_Torque_Sensor_End_Of_Line_Calibration_Digital } /* $31 $1 $F0 $4 */, 
  {   6, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartF005_DTC_Status_By_Number } /* $31 $1 $F0 $5 */, 
  {   5, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartF008_Current_Mode_Current_Gain_Calc } /* $31 $1 $F0 $8 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartF009_Current_Mode_Current_Offset_Calc } /* $31 $1 $F0 $9 */, 
  {  10, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStartF0FF_MPU_Test_Interface } /* $31 $1 $F0 $FF */, 

  {   4, { 0x01, 0x01, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStopDF00_Permanent_Control } /* $31 $2 $DF $0 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStopDF01_Temporary_Control } /* $31 $2 $DF $1 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescStopF009_Current_Mode_Current_Offset_Calc } /* $31 $2 $F0 $9 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescResultsDF00_Permanent_Control } /* $31 $3 $DF $0 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x14, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescResultsDF01_Temporary_Control } /* $31 $3 $DF $1 */, 
  {   4, { 0x01, 0x01, 0 }, { 0x10, 0x03, 0x00 }, kDescStateNoTransition,    0, ApplDescResultsF009_Current_Mode_Current_Offset_Calc } /* $31 $3 $F0 $9 */, 
  {   2, { 0x03, 0x03, 0 }, { 0x1F, 0x03, 0x00 }, kDescStateNoTransition,    0, DescGenSendTesterPresent } /* $3E $0 */
};
/* Table of sub-service protocol information. */
V_MEMROM0 static V_MEMROM1 DescMsgItem V_MEMROM2 g_descSvcInstHeadExt[kDescSvcInstHeadExtNumItems] = 
{
  0x01, 0x02, 0x03, 0x50, 0x7E /* $10 */, 
  0x01, 0x02, 0x03, 0x60 /* $11 */, 
  0x01, 0x02, 0x04 /* $19 */, 
  0x03, 0x04 /* $27 */, 
  0x00, 0x03, 0x00, 0x01, 0x03, 0x01 /* $28 */, 
  0x21, 0x01, 0xF0, 0x80, 0xF0, 0x8F, 0xF0, 0xFE, 0xF1, 0x8B, 0xF1, 0x8C, 0xFD, 0x02, 0xFD, 0x12 /* $2E */, 
  0xFD, 0x19, 0xFD, 0x1B, 0xFD, 0x1E, 0xFD, 0x25, 0xFD, 0x26, 0xFD, 0x27, 0xFD, 0x29, 0xFD, 0x30 /* $2E */, 
  0xFD, 0xA1, 0xFD, 0xA2, 0xFD, 0xA3, 0xFD, 0xAC, 0xFD, 0xAE, 0xFD, 0xB0, 0xFD, 0xB1, 0xFD, 0xB2 /* $2E */, 

  0xFD, 0xB3, 0xFD, 0xB4, 0xFD, 0xB5, 0xFD, 0xB6, 0xFD, 0xB7, 0xFD, 0xBA, 0xFE, 0xFC, 0xFE, 0xFF /* $2E */, 
  0xFD, 0x0D, 0x00, 0xFD, 0x0D, 0x03, 0xFD, 0x11, 0x00, 0xFD, 0x11, 0x03 /* $2F */, 
  0x01, 0xDF, 0x00, 0x01, 0xDF, 0x01, 0x01, 0xF0, 0x00, 0x01, 0xF0, 0x01, 0x01, 0xF0, 0x03, 0x01, 0xF0, 0x04 /* $31 */, 
  0x01, 0xF0, 0x05, 0x01, 0xF0, 0x08, 0x01, 0xF0, 0x09, 0x01, 0xF0, 0xFF, 0x02, 0xDF, 0x00, 0x02, 0xDF, 0x01 /* $31 */, 
  0x02, 0xF0, 0x09, 0x03, 0xDF, 0x00, 0x03, 0xDF, 0x01, 0x03, 0xF0, 0x09 /* $31 */, 
  0x00 /* $3E */
};

#if defined ( C_ENABLE_MULTI_ECU_CONFIG )
# if (C_VERSION_REF_IMPLEMENTATION >= 0x150)
V_MEMROM0 extern V_MEMROM1 tVIdentityMsk V_MEMROM2 CanChannelIdentityAssignment[kCanNumberOfChannels];
# endif
#endif

/* Table of all PIDs' instances which can be read using SIMD procedure. */
V_MEMROM0 static V_MEMROM1 DescPidInst V_MEMROM2 g_descPIDInfo[kDescNumPids] = 
{
  { 0x0D01,    1, { { 0x1F, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRead_0D01_Size_ECUSerialNumberDataIdentifier }, 
  { 0x2100,   16, { { 0x1D, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRead_2100_Variant_Coding_Possibilities }, 
  { 0x2101,   15, { { 0x1D, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescRead_2101_Variant_Coding_Programmed }, 
  { 0xC002,    2, { { 0x1D, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadC002_Size_for_Multi }, 
  { 0xD403,    2, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD403_Vehicle_Speed }, 
  { 0xD404,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD404_Battery_Voltage }, 
  { 0xD405,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD405_ECU_Temperature }, 
  { 0xD407,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD407_Engine_State }, 

  { 0xD408,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD408_Ignition_On_Off }, 
  { 0xD409,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD409_Assist_State }, 
  { 0xD40A,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD40A_Assist_Mode }, 
  { 0xD40C,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD40C_State_Mode }, 
  { 0xD40D,    2, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD40D_Absolute_Handwheel_Angle }, 
  { 0xD40E,    2, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD40E_Handwheel_Angle }, 
  { 0xD40F,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD40F_Handwheel_Torque }, 
  { 0xD410,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD410_Final_Torque_Command }, 

  { 0xD412,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD412_Derating_Flag }, 
  { 0xD413,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD413_DMD_FCT_CPK }, 
  { 0xD414,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD414_CAUSE_DESACTIV_CPK }, 
  { 0xD415,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD415_ETAT_DAE_CPK }, 
  { 0xD417,    2, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD417_Steering_Wheel_Angle_Setpoint }, 
  { 0xD418,    2, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD418_Handwheel_Velocity }, 
  { 0xD419,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD419_LKA_Function_Request }, 
  { 0xD41A,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD41A_LXA_Trajectory_Correction_Factor }, 

  { 0xD41B,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD41B_EPS_State_LXA }, 
  { 0xD41C,    1, { { 0x1D, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadD41C_Active_Tuning_Set }, 
  { 0xF080,   22, { { 0x1F, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadF080_Authentication_Zone }, 
  { 0xF08A,   68, { { 0x1D, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadF08A_Multiplexed_CAN_HS_Network_Diagnostic }, 
  { 0xF08F,   23, { { 0x1F, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadF08F_EMC_Standardization_Label }, 
  { 0xF0FE,   24, { { 0x1F, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadF0FE_Identification_Zone }, 
  { 0xF180,   13, { { 0x1F, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadF180_bootSoftwareIdentification }, 
  { 0xF186,    1, { { 0x1F, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadF186_ActiveDiagnosticSessionControl }, 

  { 0xF18B,    3, { { 0x1F, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadF18B_ECUManufacturingDateDataIdentifier }, 
  { 0xF18C,   13, { { 0x1F, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadF18C_ECUSerialNumberDataIdentifier }, 
  { 0xFD01,    0, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD01_Internal_Software_Identifiers }, 
  { 0xFD02,    4, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD02_Serial_Communication_Service_Active_Defeats }, 
  { 0xFD0E,    8, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD0E_Motor_Stiffness_Check }, 
  { 0xFD10,   10, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD10_Nxtr_CCP_XCP_Transmit_and_Receive_IDs }, 
  { 0xFD12,   28, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD12_Current_Mode_Offset_and_Gain }, 
  { 0xFD13,   75, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD13_Read_Nxtr_DTCs }, 

  { 0xFD17,    2, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD17_Flash_Memory_Size }, 
  { 0xFD19,    1, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD19_Nxtr_Manufacturing_Enable_Counter_MEC }, 
  { 0xFD1A,    1, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD1A_System_state }, 
  { 0xFD1B,    1, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD1B_Manual_Vehicle_speed_Overide }, 
  { 0xFD1C,    3, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD1C_Manufacturing_Services_Version }, 
  { 0xFD1E,    2, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD1E_Torque_Sensor_Diagnostic_Defeat }, 
  { 0xFD20,    3, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD20_Read_Transient_Overvoltage_Data }, 
  { 0xFD25,    2, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD25_Motor_Torque_Scale_Factor }, 

  { 0xFD26,    3, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD26_Average_Friction_Learning_Select }, 
  { 0xFD27,    1, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD27_Friction_Offset_Output_Defeat }, 
  { 0xFD29,    2, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD29_Set_EOL_Friction_Learned }, 
  { 0xFD30,    5, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD30_End_of_Line_Torque_Trim_Value_Digital_SENT }, 
  { 0xFD31,   12, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFD31_Torque_Sensor_Value_Digital_SENT }, 
  { 0xFDA1,    4, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDA1_ECU_Serial_Number }, 
  { 0xFDA2,    4, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDA2_EPS_Serial_Number }, 
  { 0xFDA3,   12, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDA3_ECU_Hardware_Part_Number }, 

  { 0xFDAC,   64, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDAC_Nxtr_Manufacturing_Scratchpad }, 
  { 0xFDAD,    7, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDAD_Active_Pull_Compensation }, 
  { 0xFDAE,    2, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDAE_Ignition_Counter }, 
  { 0xFDAF,  176, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDAF_NTC_Snapshot_Data }, 
  { 0xFDB0,  256, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDB0_IPM_Cogging_Table_1 }, 
  { 0xFDB1,  256, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDB1_IPM_Cogging_Table_2 }, 
  { 0xFDB2,  256, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDB2_IPM_Cogging_Table_3 }, 
  { 0xFDB3,  256, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDB3_IPM_Cogging_Table_4 }, 

  { 0xFDB4,    8, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDB4_Current_Mode_Analog_Ke_R_Ld_Lq }, 
  { 0xFDB5,    4, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDB5_Active_Pull_Set_Short_Term_Comp }, 
  { 0xFDB6,    4, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDB6_Active_Pull_Set_LongTerm_Comp }, 
  { 0xFDB7,   18, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDB7_IPM_Cogging_Table_5 }, 
  { 0xFDBA,    4, { { 0x10, 0x03, 0x00 }, { 0x03, 0x03, 0 } }, ApplDescReadFDBA_End_of_Line_Polarity }, 
  { 0xFEFC,    3, { { 0x10, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadFEFC_Powerpack_Configuration }, 
  { 0xFEFD,    1, { { 0x10, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadFEFD_Vehicle_Speed_Type }, 
  { 0xFEFE,   56, { { 0x10, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadFEFE_Nxtr_Flash_Bootloader_Identification }, 

  { 0xFEFF,    2, { { 0x10, 0x03, 0x00 }, { 0x01, 0x01, 0 } }, ApplDescReadFEFF_Application_Key }
};


/* -----------------------------------------------------------------------------
    &&&~ Macro definitions
 ----------------------------------------------------------------------------- */

#define DescGetTicksOfMs(timeMs)                                     (vuint16)((timeMs)/(kDescCallCycleUs/1000))

#if (kDescNumContexts > 1)
# if defined (DESC_ENABLE_DEBUG_USER )
#  define DescAssertContext(p,e)                                     if (!(p)) {ApplDescFatalError(e, (vuint16)__LINE__);}
# else
#  define DescAssertContext(p,e)
# endif
#else
# define DescAssertContext(p,e)
#endif

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# define DescAssertCommon(p,e)                                       if (!(p)) {ApplDescFatalError(e, (vuint16)__LINE__);}
# define DescAssertCommonAlways(e)                                   (ApplDescFatalError((e), (vuint16)__LINE__))
#else
# define DescAssertCommon(p,e)
# define DescAssertCommonAlways(e)
#endif

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
# define DescAssertInternal(p,e)                                     if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescAssertInternalAlways(e)                                 (ApplDescFatalError((e), (vuint16)__LINE__))
#else
# define DescAssertInternal(p,e)
# define DescAssertInternalAlways(e)
#endif

#if defined (DESC_ENABLE_DEBUG_USER )
# define DescAssertUser(p,e)                                         if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescAssertUserAlways(e)                                     (ApplDescFatalError((e), (vuint16)__LINE__))
#else
# define DescAssertUser(p,e)
# define DescAssertUserAlways(e)
#endif

#if defined (DESC_ENABLE_DEBUG_INTERNAL )
# define DescSubcompOnceInitPowerOnDebug()                           (CheckTableConsistency())
#endif

  /* Save too many else cases :) */
#if !defined (DescSubcompOnceInitPowerOnDebug)
# define DescSubcompOnceInitPowerOnDebug()                           /* Not used */
#endif

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# define DescSubcompOnceInitDebug()                                  /* Not used */
# define DescSubcompIterInitDebug(iContext)                          (DescDebugIterInit(DESC_CONTEXT_PARAM_ONLY))
#else
# define DescSubcompOnceInitDebug()                                  /* Not used */
# define DescSubcompIterInitDebug(iContext)                          /* Not used */
#endif

#if defined (DESC_ENABLE_DEBUG_USER )
# define DescUsdtNetIsoTpAssertUser(p,e)                             if (!(p)) {ApplDescFatalError((e), (vuint16)__LINE__);}
# define DescUsdtNetIsoTpAssertUserAlways(e)                         do {ApplDescFatalError((e), (vuint16)__LINE__);}while(0)
#else
# define DescUsdtNetIsoTpAssertUser(p,e)                             /* Not used */
# define DescUsdtNetIsoTpAssertUserAlways(e)                         /* Not used */
#endif

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# define DescUsdtNetIsoTpAssertChannel(p,e)                          DescUsdtNetIsoTpAssertUser((p), (e))
#else
# define DescUsdtNetIsoTpAssertChannel(p,e)                          /* Not used */
#endif

/* Accept always */
#define DescOemCheckPhysTargetAddress(tgtAddress)                    kDescTrue
#define DescOemCheckFuncTargetAddress(tgtAddress)                    kDescTrue

/* Accept always */
#define DescOemCheckPhysSourceAddress(srcAddress)                    kDescTrue
#define DescOemCheckFuncSourceAddress(srcAddress)                    kDescTrue

#define DescUsdtNetInitPowerOn()                                     (DescUsdtNetIsoTpInitPowerOn())
#define DescUsdtNetInit()                                            (DescUsdtNetIsoTpInit())
#define DescUsdtNetStateTask()                                       (DescUsdtNetIsoTpStateTask())
#define DescUsdtNetTimerTask()
#define DescUsdtNetPrepareResponse(infoPool)                         (DescUsdtNetIsoTpPrepareResponse(infoPool))
#define DescUsdtNetTransmitResponse(infoPool)                        (DescUsdtNetIsoTpTransmitResponse(infoPool))
#define DescUsdtNetReleaseInfoPool(infoPool)                         (DescUsdtNetIsoTpReleaseInfoPool(infoPool))
#if defined(DESC_USDTNET_ENABLE_LONGSERVICE_SUPPORT)
# define DescUsdtNetFinishReception(infoPool, status)                (DescUsdtNetLSFinishReception((infoPool),(status)))
# define DescUsdtNetFinishTransmission(infoPool, status)             (DescUsdtNetLSFinishTransmission((infoPool),(status)))
# define DescUsdtNetStartReception(infoPool)                         (DescUsdtNetLSStartReception((infoPool)))
# define DescUsdtNetRingBufferCopyRoutine(infoPool, pDestination, dataLength) (DescUsdtNetLSRingBufferCopyRoutine((infoPool),(pDestination),(dataLength)))
#else
# define DescUsdtNetFinishReception(infoPool, status)                (DescUsdtNetAbsFinishReception((infoPool),(status)))
# define DescUsdtNetFinishTransmission(infoPool, status)             (DescUsdtNetAbsFinishTransmission((infoPool),(status)))
# define DescUsdtNetStartReception(infoPool)                         (DescUsdtNetAbsStartReception((infoPool)))
# define DescUsdtNetRingBufferCopyRoutine(infoPool, pDestination, dataLength) (DescUsdtNetAbsRingBufferCopyRoutine((infoPool),(pDestination),(dataLength)))
#endif

#define DescUudtNetInitPowerOn()                                     /* Not used */
#define DescUudtNetInit()                                            /* Not used */
#define DescUudtNetTimerTask()                                       /* Not used */
#define DescUudtNetStateTask()                                       /* Not used */

/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnNetwork()                          (DescNetworkInitPowerOn())

#if defined(DESC_ENABLE_NODE_POWER_CONTROL) || (kDescNumContexts > 1)|| defined(DESC_ENABLE_SPONTANEOUS_RES)
static void DescNetworkOnceInit(void);
# define DescSubcompOnceInitNetwork()                                (DescNetworkOnceInit())
#else
# define DescSubcompOnceInitNetwork()                                (DescNetworkInit())
#endif
#define DescSubcompIterInitNetwork(iContext)                         (DescNetworkIterInit(DESC_CONTEXT_PARAM_ONLY))

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
# define DescIntToBitMap(integer)                                    (0x01 << (integer))
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
#  define DescNpmSetSleepReady(channel)                              (__DescNpmSetSleepReady(channel))
#  define DescNpmSetKeepAwake(channel)                               (__DescNpmSetKeepAwake(channel))
#  define DescIsNpmOnCanChannelActive(canChannel, canMap)            ((vuint8)(DescIntToBitMap(canChannel) & (canMap)) != kDescFalse)
#  define DescSetNpmOnCanChannelActive(canChannel, canMap)           ((canMap) |= DescIntToBitMap(canChannel))
#  define DescResetNpmOnCanChannelActive(canChannel, canMap)         ((canMap) &= (vuintx)(~DescIntToBitMap(canChannel)))
# else
#  define DescNpmSetSleepReady(channel)                              (__DescNpmSetSleepReady(0))
#  define DescNpmSetKeepAwake(channel)                               (__DescNpmSetKeepAwake(0))
#  define DescIsNpmOnCanChannelActive(canChannel, canMap)            ((canMap) != 0)
#  define DescSetNpmOnCanChannelActive(canChannel, canMap)           ((canMap) =  1)
#  define DescResetNpmOnCanChannelActive(canChannel, canMap)         ((canMap) =  0)
# endif
#endif

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
#  define DescGetMirroredQueue(canMap, canMapMirror)                 (canMapMirror)
# else
#  define DescGetMirroredQueue(canMap, canMapMirror)                 (canMap)
# endif
#endif
/* S1 timer decrementation mask */
#if (kDescNumContexts > 1)
# define DescSetConnectionActive(iContext)                           (g_descActiveRequestsMask |= ((vuint8)(kDescDescConnectionStateActive<<iContext)))
/* No interrutp lock, because it is already used (see DescDoPostProcessing) */
# define DescResetConnectionActive(iContext)                         (DescInterruptDisable(),(g_descActiveRequestsMask &= (vuint8)~(vuint8)(kDescDescConnectionStateActive<<iContext)),DescInterruptRestore())
# define DescIsNoExtConnectionActive()                               ((g_descActiveRequestsMask & (vuint8)(~(vuint8)(kDescReadDynPidConnStateActive | kDescRoeConnStateActive))) == 0)
# define DescIsNoConnectionActive()                                  (g_descActiveRequestsMask == 0)
#else
# define DescSetConnectionActive(iContext)                           /* not used */
# define DescResetConnectionActive(iContext)                         /* not used */
# define DescIsNoExtConnectionActive()                               /* not used */
/* Check if the diagnostic layer is in Idle Mode (ignore the periodic responses - they must not avoid S1 timer decrementation) */
# define DescIsNoConnectionActive()                                  (g_descInterruptContextCtrl[kDescPrimContext].isContextLocked == 0)
#endif

#if defined(DESC_USDTNET_ENABLE_LONGSERVICE_SUPPORT)
# define DescUsdtNetAbsReleaseInfoPool(infoPool)                     (DescUsdtNetLSReleaseInfoPool((infoPool)))
# define DescUsdtNetAbsInitPowerOn()                                 (DescUsdtNetLSInitPowerOn())
# define DescUsdtNetAbsInit()                                        (DescUsdtNetLSInit())
# define DescUsdtNetAbsStateTask()                                   (DescUsdtNetLSStateTask())
# define DescUsdtNetAbsTimerTask()                                   (DescUsdtNetLSTimerTask())
# define DescUsdtNetAbsTransmitResponse(infoPool)                    (DescUsdtNetLSTransmitResponse((infoPool)))
# define DescUsdtNetAbsPrepareResponse(infoPool)                     (DescUsdtNetLSPrepareResponse((infoPool)))
#else
# define DescUsdtNetAbsReleaseInfoPool(infoPool)                     (DescUsdtNetReleaseInfoPool((infoPool)))
# define DescUsdtNetAbsInitPowerOn()                                 (DescUsdtNetInitPowerOn())
# define DescUsdtNetAbsInit()                                        (DescUsdtNetInit())
/* This is an optional API - may be an empty macro!!! Do not enclose in paranthesis */
# define DescUsdtNetAbsStateTask()                                   DescUsdtNetStateTask()
/* This is an optional API - may be an empty macro!!! Do not enclose in paranthesis */
# define DescUsdtNetAbsTimerTask()                                   DescUsdtNetTimerTask()
# define DescUsdtNetAbsTransmitResponse(infoPool)                    (DescUsdtNetTransmitResponse((infoPool)))
/* This is an optional API - may be an empty macro!!! Do not enclose in paranthesis */
# define DescUsdtNetAbsPrepareResponse(infoPool)                     DescUsdtNetPrepareResponse((infoPool))
#endif

#if defined(ApplDescOnBeginOfProcExt)
/* ok - some one needs it */
#else
# define ApplDescOnBeginOfProcExt()                                  /* Not used */
#endif

#if defined(ApplDescOnEndOfProcExt)
/* ok - some one needs it */
#else
# define ApplDescOnEndOfProcExt()                                    /* Not used */
#endif
#if defined (DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
# define DescGetAvailBufferLenByMsgContext(pMsgContext)              ((pMsgContext)->busInfo.availBufferLength)
# define DescGetAvailBufferLenByInfoPool(infoPool)                   ((infoPool)->busInfo.availBufferLength)
#else
# define DescGetAvailBufferLenByMsgContext(iContext)                 kDescPrimBufferLen
# define DescGetAvailBufferLenByInfoPool(infoPool)                   kDescPrimBufferLen
#endif
#define DescNetGetAvailBufferLenByIContext(iContext)                 (DescGetAvailBufferLenByInfoPool(g_descInterruptContextCtrl[(iContext)].infoPoolPtr))

#define DescOemOnTxFrame()                                           /* Not used */
#define DescOemOnRxErrorInd(status)                                  /* Not used */
#define DescOemOnTxErrorInd(status)                                  /* Not used */
#define DescOemOnRxStart(infoPool)                                   /* Not used */
#define DescOemOnReqInd(iContext)                                    /* Not used */
/* Activate the S1 timer if necessary (Not in default session) */
#define DescOemOnConfirmation(iContext,status)                       /* Not used */

/* T2 timer macros */
#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT) || defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
# define DescActivateLimiter(iContext)                               (g_descRcrrpLimitCounter[iContext] = kDescRcrrpMaxTicks)
# define DescDeactivateLimiter(iContext)                             (g_descRcrrpLimitCounter[iContext] = 0)
#else
# define DescActivateLimiter(iContext)                               /* Not used */
# define DescDeactivateLimiter(iContext)                             /* Not used */
#endif

#define DescActivateT2Timer(iContext)                                (g_descT2Timer[iContext] = kDescP2InitValue)
#define DescReloadT2TimerWithP3maxTime(iContext)                     (g_descT2Timer[iContext] = kDescP2ReloadValue)
#define DescDeactivateT2Timer(iContext)                              (g_descT2Timer[iContext] = 0)

/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnTiming()                           /* Not used */

#define DescSubcompOnceInitTiming()                                  (DescTimingOnceInit())
#define DescSubcompIterInitTiming(iContext)                          (DescTimingIterInit(DESC_CONTEXT_PARAM_ONLY))

/* S1 timer macros */
#define DescActivateS1Timer()                                        (g_descS1Timer = kDescS1TimerTicks)
#define DescReloadS1Timer()                                          (g_descS1Timer = kDescS1TimerTicks)
#define DescDeactivateS1Timer()                                      (g_descS1Timer = 0)

/* Oem specific timers during service execution */
#define DescOemTaskTimer()                                           /* Not used */

#define DescOemPreActiveTimer(iContext)                              /* Not used */
#define DescOemPostActiveTimer(iContext)                             /* Not used */

/* Oem specific timers desc idle mode */
#define DescOemDescIdleTimer()                                       /* Not used */

#define DescOemOnS1Timeout()                                         /* not used */

#define DescOemOnT2Timeout(iContext)                                 /* not used */
#define DescOemOnResPendingOvertime(iContext)                        /* not used */
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
# define DescOemOnResPendingOverrun(iContext)                        /* not used */
/* No else since the count limit disables the whole code */
#endif

/* Protocol specific initialization */
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL) && \
    defined (DESC_ENABLE_OEM_MH_MULTI_CALL_PROTECTION)
# define DescStateCompInitOnceGroup()                                (g_descIsOemMainHdlrAlreadyCalled = 0)
#endif
#if defined(DESC_ENABLE_AUTO_STATES)
# define DescOemOnTransitionSession(newState,currentState)           (DescOnTransitionStateSession((newState), (currentState)))
#endif

/* Internal API for INIT */
#if !defined(DescStateCompInitOnceOem)
# define DescStateCompInitOnceOem()                                  /* Not used */
#endif

#if !defined(DescStateCompInitOnceGroup)
# define DescStateCompInitOnceGroup()                                /* Not used */
#endif

#if defined(DESC_ENABLE_AUTO_STATES)
# define DescStateCompInitOnceCore()                                 (DescStateOnceInit())
#else
# define DescStateCompInitOnceCore()                                 /* Not used */
#endif


#define DescSubcompOnceInitPowerOnState()                            /* Not used */
#define DescSubcompOnceInitState()                                   {DescStateCompInitOnceCore(); DescStateCompInitOnceGroup(); DescStateCompInitOnceOem()}
#define DescSubcompIterInitState(iContext)                           /* Not used */

#if defined (DESC_ENABLE_AUTO_STATES)
# if (kDescStateGroupNumTransition > 0)
static void DescSetState(DescSvcInstIndex svcInstHandle);
# else
#  define DescSetState(svcInstHandle)                                /* Not used */
# endif
static DescNegResCode DescCheckState (V_MEMROM1 DescStateInfo V_MEMROM2 V_MEMROM3 * refState);
#else
# define DescCheckState(a)                                           /* Not used */
# define DescSetState(svcInstHandle)                                 /* Not used */
#endif

#if defined(DescOemOnTransitionSession)
#else
  #define DescOemOnTransitionSession(newState, formerState)
#endif

#if defined(DescOemOnTransitionSecurityAccess)
#else
  #define DescOemOnTransitionSecurityAccess(newState, formerState)
#endif

#define DescSvcIsSupportedInStateSession(refState)                   (((refState)->stateSession & g_descCurState.stateSession) != 0)
#define DescSvcIsSupportedInStateSecurityAccess(refState)            (((refState)->stateSecurityAccess & g_descCurState.stateSecurityAccess) != 0)
/* Going to the default session */
#if defined(DESC_ENABLE_COMM_CTRL)
# define DescOemOnTransitionToDefaultSession()                       (DescEnableCommunication())
#else
/* Avoid compiler errors leaving "();" */
# define DescOemOnTransitionToDefaultSession()                       /* not used */
#endif
/* Going to a non-default session */
#define DescOemOnTransitionToNonDefaultSession()                     /* not used */
/* Session Transition notification */
#define DescOemOnSessionTransition()                                 /* not used */

#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
/* Prototype exists in desc.h */
# if (kDescNumContexts > 1)
#  define _DescStartRepeatedServiceCall(iContext,mainHandler)        (DescStartRepeatedServiceCall(iContext, mainHandler))
# else
#  define _DescStartRepeatedServiceCall(iContext,mainHandler)        (DescStartRepeatedServiceCall(mainHandler))
# endif
#else
  /* Preprocessor workaround */
# define _DescStartRepeatedServiceCall(iContext,mainHandler)         /* Not active */
#endif
#define DescSubcompOnceInitPowerOnDispatcher()                       /* Not used */

#define DescSubcompOnceInitDispatcher()                              /* Not used */
#define DescSubcompIterInitDispatcher(iContext)                      (DescDispatcherIterInit(DESC_CONTEXT_PARAM_ONLY))

/* Extract the bit position from the handle and shift with one position more 
 * (start from 0x02 instead of 0x01) since the Bit0 is for the SId.
 */
#define DescGetSvcInstFailurePosMask(svcInstHandle)                  ((vuint8)(0x02<<((vuint8)((svcInstHandle)>>13))))

#define DescOemOnProcessingDone(iContext)                            /* Not used */
#define DescOemOnSvcNotFound(iContext)                               /* Not used */
#define DescOemOnSvcInstNotFound(iContext)                           /* Not used */
#define DescOemOnReqLengthNotMatched(iContext)                       /* Not used */
#define DescOemOnReqLengthTooSmall(iContext)                         /* Not used */
#define DescOemOnInvalidSidSession(iContext)                         /* Not used */
#define DescOemOnInvalidAddrMethod(iContext)                         /* Not used */
#define DescOemOnInvalidEcuState(iContext)                           /* Not used */
#define DescOemOnValidService(iContext)                              /* Not used */

/* API for inter sub-component initialization */
#define DescSubcompOnceInitPowerOnController()                       /* Not used */
#define DescSubcompOnceInitController()                              /* Not used */
#define DescSubcompIterInitController(iContext)                      /* Not used */

#define DescOemOnPowerOnInit(initParam)                              /* Not used */
#define DescOemOnInit(initParam)                                     /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnProcessor()                        /* Not used */
#define DescSubcompOnceInitProcessor()                               /* Not used */
#define DescSubcompIterInitProcessor(iContext)                       /* Not used */

#define ApplDescGenericServiceConfirmation(status)
#define DescOemCustomizeComTypeParam(pCommCtrlInfo)                  /* Not used */

/* -- Communication layer adapter -- */
/* Part offline function handler prototype */
#if defined (C_MULTIPLE_RECEIVE_CHANNEL)
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
#  if defined ( C_ENABLE_MULTI_ECU_CONFIG )
#   define DescCommSetTxOnline(channel, msgGroup)                    do { if ( (CanChannelIdentityAssignment[channel] & V_ACTIVE_IDENTITY_MSK) != (tVIdentityMsk)0 ) {CanPartOnline((channel), (msgGroup));} } while (0)
#   define DescCommSetTxOffline(channel, msgGroup)                   do { if ( (CanChannelIdentityAssignment[channel] & V_ACTIVE_IDENTITY_MSK) != (tVIdentityMsk)0 ) {CanPartOffline((channel), (msgGroup));} } while (0)
#  else
/* Code-doubled systems are excluded up to now */
#   define DescCommSetTxOnline(channel, msgGroup)                    CanPartOnline((CanChannelHandle)(channel), (vuint8)(msgGroup))
#   define DescCommSetTxOffline(channel, msgGroup)                   CanPartOffline((CanChannelHandle)(channel), (vuint8)(msgGroup))
#  endif
# else
#  define DescCommSetTxOnline(channel, msgGroup)                     CanPartOnline(0, (vuint8)(msgGroup))
#  define DescCommSetTxOffline(channel, msgGroup)                    CanPartOffline(0, (vuint8)(msgGroup))
# endif
#else
# define DescCommSetTxOnline(channel, msgGroup)                      CanPartOnline((vuint8)(msgGroup))
# define DescCommSetTxOffline(channel, msgGroup)                     CanPartOffline((vuint8)(msgGroup))
#endif
#if defined (DESC_ENABLE_RX_COMM_CONTROL)
# define DescMakeCommCtrlParam(txState,rxState)                      ((vuint8)(((rxState) << 2)|(txState)))
#else
# define DescMakeCommCtrlParam(txState,rxState)                      ((vuint8)(txState))
#endif

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnFaultMemory()                      /* Not used */
#define DescSubcompOnceInitFaultMemory()                             /* Not used */
#define DescSubcompIterInitFaultMemory(iContext)                     /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnSecurityAccess()                   /* Not used */
#define DescSubcompOnceInitSecurityAccess()                          /* Not used */
#define DescSubcompIterInitSecurityAccess(iContext)                  /* Not used */
#define DescOemOnInvalidRequest(iContext)                            /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnPidManager()                       /* Not used */
#define DescSubcompOnceInitPidManager()                              /* Not used */
#define DescSubcompIterInitPidManager(iContext)                      /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnRidManager()                       /* Not used */
#define DescSubcompOnceInitRidManager()                              /* Not used */
#define DescSubcompIterInitRidManager(iContext)                      /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnScheduled()                        /* Not used */
#define DescSubcompOnceInitScheduled()                               /* Not used */
#define DescSubcompIterInitScheduled(iContext)                       /* Not used */

/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnPidListProcessor()                 /* Not used */
#define DescSubcompOnceInitPidListProcessor()                        /* Not used */
#define DescSubcompIterInitPidListProcessor(iContext)                (DescIterInitPidListProcessor(DESC_CONTEXT_PARAM_ONLY))

#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
# define DescPidMod8(value)                                          ((vuint8_least)((value) & (8-1)))
# if (kDescNumPostHdlrQueueBytes > 1)
#  define DescPidDiv8(value)                                         ((vuint8_least)((value) >> 3))
# else
#  define DescPidDiv8(value)                                         0
# endif
/* Queue the current reference of PID */
# define DescPidDoQueuePostHandlerAt(pidRef)                         (g_descPidPostHdlrQueue[DescPidDiv8(pidRef)] |= (vuint8)(0x01 << DescPidMod8(pidRef)))
# define DescPidIsPostHandlerQueuedAt(pidRef)                        ((g_descPidPostHdlrQueue[DescPidDiv8(pidRef)] & (0x01 << DescPidMod8(pidRef))) != 0)
#endif

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnDynDefinePid()                     /* Not used */
#define DescSubcompOnceInitDynDefinePid()                            /* Not used */
#define DescSubcompIterInitDynDefinePid(iContext)                    /* Not used */

/* Hook functions for PID manager */
#define DescPmClientCheckPid(result, pid)                            (result)
#define DescPmClientGetResLength(pidHandle)                          ((vuint8)0)


/* Internal API for INIT */
#define DescSubcompOnceInitPowerOnDynDefineDpid()                    /* Not used */
#define DescSubcompOnceInitDynDefineDpid()                           /* Not used */
#define DescSubcompIterInitDynDefineDpid(iContext)                   /* Not used */

/* Default internal API for INIT - not used */
#define DescSubcompOnceInitPowerOnRoeProcessor()                     /* Not used */
#define DescSubcompOnceInitRoeProcessor()                            /* Not used */
#define DescSubcompIterInitRoeProcessor(iContext)                    /* Not used */



/* -----------------------------------------------------------------------------
    &&&~ Implementation
 ----------------------------------------------------------------------------- */

/* Check if this feature is enabled */
#if defined (GEN_MAGIC_NUMBER_V_CFG) && \
    defined (kDescIntegrationMagicNumber)
/* begin Fileversion check */
# if (GEN_MAGIC_NUMBER_V_CFG != kDescIntegrationMagicNumber)
#  error "The magic number of the generated header v_cfg.h is different! Check time and date of generated files!"
# endif
#endif

/******************************************************************************
* All necessary preprocessor directives existence checks
******************************************************************************/
#if !defined(DESC_ENABLE_RES_PENDING_TIME_LIMIT) && \
    !defined(DESC_DISABLE_RES_PENDING_TIME_LIMIT)
# error "Missing switch DESC_XXXABLE_RES_PENDING_TIME_LIMIT!"
#endif

#if !defined(DESC_ENABLE_RES_PENDING_COUNT_LIMIT) && \
    !defined(DESC_DISABLE_RES_PENDING_COUNT_LIMIT)
# error "Missing switch DESC_XXXABLE_RES_PENDING_COUNT_LIMIT!"
#endif

#if defined (kDescNumContexts)
# if (kDescNumContexts == 0)
#  error "No diagnostic connection will be available!"
# endif
#else
# error "Missing kDescNumContexts define!"
#endif
/******************************************************************************
*  Conditional checks
******************************************************************************/
#if defined(DESC_ENABLE_MULTI_TP)
# if defined(DESC_ENABLE_SINGLE_TP_OPTIMIZED)
#  error "Could not be used both transport layers types!"
# endif
#elif defined(DESC_DISABLE_MULTI_TP)
# if defined(DESC_DISABLE_SINGLE_TP_OPTIMIZED)
#  error "At least one transport layer type must be selected!"
# endif
#else
# error "Missing switch DESC_XXXABLE_MULTI_TP!"
#endif

#if !defined(DESC_ENABLE_SINGLE_TP_OPTIMIZED) && \
    !defined(DESC_DISABLE_SINGLE_TP_OPTIMIZED)
# error "Missing switch DESC_XXXABLE_SINGLE_TP_OPTIMIZED!"
#endif

#if defined(DESC_ENABLE_RES_PENDING_TIME_LIMIT) && \
    defined(DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
# error "Both type of response pending limitations are not possible at the same time!"
#endif

#if defined (C_MULTIPLE_RECEIVE_CHANNEL) || defined (C_SINGLE_RECEIVE_CHANNEL)
/* config ok */
#else
/* code doubled system */
# if (kDescNumCommChannels > 1)
#  if defined (kDescCanChannel)
/* config ok */
#  else
#   error "Missing kDescCanChannel define!"
#  endif
# endif
#endif

#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
# if defined (TP_USE_EXTENDED_ADDRESSING)
#  if (TP_USE_EXTENDED_ADDRESSING == kTpOn)
#   define DESC_TP_USE_EXTENDED_ADDRESSING
#  endif
# endif

# if defined (DESC_TP_USE_EXTENDED_ADDRESSING) || \
     defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
     defined (TP_FUNC_ENABLE_EXTENDED_ADDRESSING) || \
     defined (TP_ENABLE_MIXED_29_ADDRESSING)
# else
#  error "Access to the tester address is supported only non normal addressing TP classes!"
# endif
#endif


#if defined (DESC_ENABLE_DEBUG_INTERNAL)
/*******************************************************************************
* NAME:              CheckIndexTableConsistency
*
* CALLED BY:         DescInitPowerOn
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs check if the table relations are consistent, and 
*                    if all main handler functions are not V_NULL.
*
*******************************************************************************/
static void CheckTableConsistency(void)
{
# if defined( C_COMP_IAR_M16C )
#  if defined ( _NEAR_ )
  static vuint8  sidCnt;
  static DescSvcInstIndex i;
#  else
  vuint8  sidCnt;
  DescSvcInstIndex i;
#  endif
# else
  vuint8  sidCnt;
  DescSvcInstIndex i;
# endif
  /*--------------------------*/
  /*   Check SID references   */
  /*--------------------------*/
  sidCnt = 0;
  for (i = 0; i < kDescSvcIdMapSize; i++)
  {
    if (g_descSidMap[i] != 0xff)
    {
       /* Will be used for checking if all sid are referenced */
       sidCnt++;
        /* unexisting reference (-1 due to the dummy entry */
       DescAssertInternal((g_descSidMap[i] < (kDescSvcHeadNumItems - 1)),
                         kDescAssertIndexTableInvalidReference
                       );
    }
  }
  DescAssertInternal((sidCnt == (kDescSvcHeadNumItems - 1)),
                    kDescAssertSvcTableUnreachableItem
                  );
  /*--------------------------------*/
  /*  Check SID To SINST references */
  /*--------------------------------*/
  for (i = 0; i < (kDescSvcHeadNumItems - 1); i++)
  {
    DescAssertInternal((g_descSvcHead[i].svcInstFirstItem < kDescSvcInstNumItems),
                      kDescAssertSvcTableInvalidReference
                    );
  }
# if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
  /* Check the last line content (must be exactly the last line number of the svcInst table) */
  DescAssertInternal((g_descSvcHead[i].svcInstFirstItem == (kDescSvcInstNumItems - 1)),
                    kDescAssertSvcTableInvalidReference
                  );
# else
  /* Check the dummy line content */
  DescAssertInternal((g_descSvcHead[i].svcInstFirstItem == kDescSvcInstNumItems),
                    kDescAssertSvcTableInvalidReference
                  );
# endif
  /*--------------------------------*/
  /*  Check Main handler existence  */
  /*--------------------------------*/
  for (i = 0; i < kDescSvcInstNumItems; i++)
  {
    DescAssertInternal((g_descSvcInst[i].mainHandler != V_NULL), kDescAssertMissingMainHandler);
  }
}
#endif

#if defined (DESC_ENABLE_DEBUG_INTERNAL) || \
    defined (DESC_ENABLE_DEBUG_USER)
/*******************************************************************************
* NAME:              DescDebugIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the debug subcomponent context specific data.
*
*******************************************************************************/
static void DescDebugIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;
}
#endif

/******************************************************************************
* All necessary preprocessor directives existence checks
******************************************************************************/
#if !defined(DESC_ENABLE_ADDR_METHOD_CHECK_ON_SID) && \
    !defined(DESC_DISABLE_ADDR_METHOD_CHECK_ON_SID)
# error "Missing switch DESC_XXXABLE_ADDR_METHOD_CHECK_ON_SID!"
#endif

/* Node power management configuration validation*/
#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && \
    !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION) && \
    !defined (DESC_ENABLE_COMMON_OEM_POST_HANDLER)
# error "Enable OEM-post-handler support on service $10"
#endif

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpInitPowerOn
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Power on initialization
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpInitPowerOn(void)
{
  DescUsdtNetIsoTpInit();
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpInitContext
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Re-initialization 
*                    
*                    
*******************************************************************************/
static void DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
  vuint8  descTmpTxChannel;

  /* Find a channel for TP */
  descTmpTxChannel = TpTxGetConnectionStatus(DescGetConnectionOfContext(DESC_TPCONTEXT_PARAM_VALUE));
  if(descTmpTxChannel == kTpNoChannel)
  {
    if( (g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE] = TpTxGetFreeChannel(DescGetConnectionOfContext(DESC_TPCONTEXT_PARAM_VALUE))) != kTpNoChannel )
    {
      TpTxLockChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
#  if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      /* Initialize the transmission type */
      g_descTpCtrl.txPath[g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]].type = kDescMainTransmission;
#  endif
    }
  }
#  if defined (DESC_ENABLE_DEBUG_INTERNAL)
  else
  { /* The TX channel is still locked but is it the same as before? */
    DescUsdtNetIsoTpAssertChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE] == descTmpTxChannel, kDescAssertWrongTpTxChannel);
  }
#  endif
  DescUsdtNetIsoTpAssertChannel(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE] != kTpNoChannel, kDescAssertWrongTpTxChannel);
# endif
#endif

#if defined(DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.availBufferLength = kDescPrimBufferLen;
#endif
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext;
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resDataPtr = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
  g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resType = kDescUsdtResponseNone;
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpInit
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       Re-initialization 
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpInit(void)
{
  { /* Init tx resources */
    vuint8_least resIter = kTpTxChannelCount;
    while(resIter != 0)
    {
      resIter--;
      g_busInfoPoolTxRef[resIter] = V_NULL;
    }
  }

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  {
    vuint8_least addIter = kDescNumAddRequestChannels;

    g_descAddChannelCtrl.count = 0;
    while(addIter != 0)
    {
      --addIter;
      g_descAddChannelCtrl.channel[addIter].status = kDescContextIdle;
    }
  }
#endif

  DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(kDescPrimContext));
#if defined (DESC_ENABLE_PARALLEL_OBD)
  DescUsdtNetIsoTpInitContext(DESC_TPCONTEXT_PARAM_WRAPPER_ONLY(kDescObdContext));
#endif

#if defined(TP_FUNC_ENABLE_RECEPTION) && \
    (kDescNumFuncReqContexts > 0)
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].descHandle = kDescUsdtNetInvalidDescContext;
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].reqDataPtr = g_descSecBuffer;
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].resDataPtr = g_descSecBuffer;
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].resType = kDescUsdtResponseNone;
# if defined(DESC_USDTNET_ENABLE_DYNAMIC_BUFFER_LENGTH)
  g_descUsdtNetInfoPoolIsoTp[kDescUsdtNetSecInfoPool].busInfo.availBufferLength = kDescSecBufferLen;
# endif
#endif
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpStateTask
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       State Task of the IsoTp driver
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpStateTask(void)
{
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  /* Process additional requests */
  DescBusyResponseHandler();
#endif
}

#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY) && \
     defined (DESC_DISABLE_EXTERNAL_CHECK_TA)
/*******************************************************************************
* NAME:              DescCheckTA
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Target address evaluation.
*                    
*******************************************************************************/
t_ta_type DescCheckTA (vuint8 targetAddress)
{
  t_ta_type returnValue = kTpNone;

  if (targetAddress == TP_ECU_NUMBER)
  {
    returnValue = kTpPhysical;
  }
  else
  {
    if (targetAddress == kDescOemExtAddrFuncTargetAddr)
    {
      returnValue = kTpFunctional;
    }
  }
  return returnValue;
}
# endif
#endif

#if defined (DESC_ENABLE_PARALLEL_OBD)
/*******************************************************************************
* NAME:              DescDispatchServiceContext
*
* CALLED BY:         Desc start reception event
* PRECONDITIONS: 
*
* DESCRIPTION:       this function dispatches the parallel request reception target context
*******************************************************************************/
static vuint8 DescDispatchServiceContext(vuint8 sid)
{
  vuint8 result = kDescPrimContext; /* Main connection */

  /* OBD predispatching for request routing */
  if((sid > 0x00) && (sid < 0x10))
  {
    result = kDescObdContext;
  }
  return result;
}
#endif

/*******************************************************************************
* NAME:              DescGetBuffer
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       StartOfFrame reception function
*                    
*******************************************************************************/
TP_MEMORY_MODEL_DATA vuint8* DescGetBuffer(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint16 dataLength)
{
  DescUsdtNetMsg returnValue = V_NULL;

#if (defined (DESC_ENABLE_PHYSREQ_TA_CHECK) || defined (DESC_ENABLE_PHYSREQ_SA_CHECK))
  DescBool addressCheckResult;

# if defined (DESC_ENABLE_PHYSREQ_TA_CHECK)
  addressCheckResult = DescOemCheckPhysTargetAddress(TpGetTargetAddress(TP_CHANNEL_RX_PARAM_ONLY));
  if(addressCheckResult == kDescTrue)
# endif
  {
# if defined (DESC_ENABLE_PHYSREQ_SA_CHECK)
    addressCheckResult = DescOemCheckPhysSourceAddress(TpRxGetSourceAddress(TP_CHANNEL_RX_PARAM_ONLY));
# endif
  }

  if(addressCheckResult == kDescTrue)
#endif
  {
#if defined (DESC_ENABLE_PARALLEL_OBD)
    DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
    DESC_TPCONTEXT_PARAM_VALUE = DescDispatchServiceContext(TpRxGetCanBuffer(tpRxChannel)[0]);
#endif

    if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle == kDescUsdtNetInvalidDescContext)
    {
      if(dataLength > kDescPrimBufferLen)
#if defined (DESC_ENABLE_NEGRES_ON_MSG_TOO_LONG)
      {
        /* Force only one frame copy */
        TpRxSetBufferOverrun(TP_CHANNEL_RX_PARAM_ONLY);
      } /* no else required in that case - a valid reception has to be simulated */
#else
      {
# if ((TP_ISO15765_VERSION >= 0x0273) && defined (TP_ENABLE_ISO_15765_2_2))
#  if (TP_ISO15765_VERSION >= 0x0277)
        TpRxSetFCStatus(TP_CHANNEL_RX_PARAM_FIRST kTpFCStatusOverflow);
#  else
#   error "Incompatible TPMC Version - please use version 2.77+"
#  endif
# else
        /* returnValue = V_NULL; it is already default */
# endif
      } /* discard reception */
      else
#endif
      {
        t_descUsdtNetResult result;
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
        t_ta_type ta_type;
# endif
#endif
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.busType   = kDescUsdtNetBusTypeIsoTp;
#if (TP_USE_EXTENDED_ADDRESSING           == kTpOn)      || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress = TpRxGetSourceAddress(TP_CHANNEL_RX_PARAM_ONLY);
        /* Make the tester ID visible to the above layer */
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.testerId = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress;

    /* g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpRxGetReceivedTargetAddress (TP_CHANNEL_RX_PARAM_VALUE); */
#endif

#if ( kCanNumberOfChannels > 1 ) /* more than one canChannel ? */
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel = TpRxGetCanChannel(TP_CHANNEL_RX_PARAM_ONLY);
# else
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel = TpRxGetCanChannel();
# endif
        /* Make the communication channel ID visible to the above layer */
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.comChannel = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel;
#endif
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle         = TP_CHANNEL_RX_PARAM_VALUE;
#endif
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
        ta_type = TpRxGetTaType(TP_CHANNEL_RX_PARAM_ONLY);
        if (ta_type == kTpPhysical)
# endif
#endif
        {
          g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType         = kDescUsdtNetReqTypePhysical;
        }
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if defined (TP_DISABLE_CHECKTA_COMPATIBILITY)
        else
        {
          g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType         = kDescUsdtNetReqTypeFunctional;
        }
# endif
#endif
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].dataLength        = dataLength;
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle        = DESC_TPCONTEXT_PARAM_VALUE; /* Write used context */

        /* Check if Desc itself is free */
        result = DescUsdtNetStartReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE]);
        if(result == kDescUsdtNetworkOk)
        { /* it is */
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
          /* store the connection type */
          g_descTpCtrl.rxPath[tpRxChannel].type = kDescMainReception;
#endif
#if defined (DESC_ENABLE_PARALLEL_OBD)
          /* store the working context type */
          g_busInfoPoolRxRef[tpRxChannel] = &g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE];
#endif
          returnValue = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr;
        }
        else
        {
          g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext; /* Write used context */
        }
      }
    }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    else
    { /* check if an additional request channel is free */
      vuint8_least iter;
      iter = kDescNumAddRequestChannels;
      while( iter != 0 )
      {
        --iter;
        if(g_descAddChannelCtrl.channel[iter].status == kDescContextIdle)
        {
          g_descAddChannelCtrl.channel[iter].status = kDescContextActiveRx;
          /* Force only one frame copy */
          TpRxSetBufferOverrun(TP_CHANNEL_RX_PARAM_ONLY);
          g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_ONLY].type = kDescAddReception;
          g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_ONLY].info = (vuint8)iter;
          returnValue = g_descAddChannelCtrl.channel[iter].buffers.reqBuffer;
          /* Break */
          iter = 0;
        }
      }
    }
#endif
  }
  return returnValue;
}

/*******************************************************************************
* NAME:              DescPhysReqInd
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Rx path for physical requests.
*                    Function name must be entered to the CANgen OSEK-TP Options 
*                    dialog in the fields "RxIndication".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescPhysReqInd(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint16 dataLen)
{
  DESC_IGNORE_UNREF_PARAM(dataLen);

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].type)
  {
  case kDescMainReception:
#endif
    {
#if defined (DESC_ENABLE_PARALLEL_OBD)
      DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
      DESC_TPCONTEXT_PARAM_VALUE = g_busInfoPoolRxRef[TP_CHANNEL_RX_PARAM_VALUE]->descHandle;
#endif
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
      DescUsdtNetIsoTpAssertChannel(g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle == TP_CHANNEL_RX_PARAM_VALUE, kDescNetAssertWrongIsoTpRxChannel);
#endif
      /*-----------------------------*/
      /*Transport protocol management*/
      /*-----------------------------*/
#if defined (TP_ENABLE_DYNAMIC_CHANNELS)
# if defined (TP_ENABLE_NORMAL_ADDRESSING)       || \
     defined (TP_ENABLE_MIXED_11_ADDRESSING)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.ReceiveID = TpRxGetChannelID(TP_CHANNEL_RX_PARAM_ONLY);
#  if defined (TP_FUNC_ENABLE_RECEPTION)
      if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType == kDescUsdtNetReqTypeFunctional)
      {
        TpFuncSetResponse(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
      }
      else
#  endif
      {
        TpTxSetResponse(g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle, g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
      }
# endif
#endif
#if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpRxGetEcuNumber(TP_CHANNEL_RX_PARAM_ONLY);
#else
# if (TP_USE_EXTENDED_ADDRESSING == kTpOn) || \
     defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
     defined (TP_ENABLE_MIXED_29_ADDRESSING)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = kDescEcuNumber;
# endif
#endif
#if (TP_USE_EXTENDED_ADDRESSING == kTpOn)
# if (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.BaseAddress = TpRxGetBaseAddress(TP_CHANNEL_RX_PARAM_ONLY);
# endif
#endif
      /* Reception has finished */
      DescUsdtNetFinishReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE], kDescUsdtNetworkOk);
      /* Reset the channel */
      TpRxResetChannel(TP_CHANNEL_RX_PARAM_ONLY);
    }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    break;
  case kDescAddReception:
    /* Increase succesfully received additionally requests */
    DescUsdtNetIsoTpAssertUser((g_descAddChannelCtrl.count < kDescNumAddRequestChannels), kDescAssertIllegalAddRequestCount);

# if defined(DESC_ENABLE_NEG_RES_ON_SID_WITH_SET_BIT6)
    /* Process any SID */
# else
    /* Check for invalid SID (if bit6 set -> SID from the response ID page received. */
    if((g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.reqBuffer[0] & 0x40) == 0)
# endif
    {
      if(g_descAddChannelCtrl.count < kDescNumAddRequestChannels)
      {
        g_descAddChannelCtrl.count++;
      }
      /* Store tpRxChannel in buffer*/
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.tpRxChannel = TP_CHANNEL_RX_PARAM_VALUE;
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].status = kDescContextActiveProcess;
      /* write the negative response code */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.resBuffer[2] = 0x21;
      /* copy SID onto the right place */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.resBuffer[1] = g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.reqBuffer[0];
      /* write the negative response identifier */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].buffers.res.resBuffer[0] = 0x7f;
    }
# if defined(DESC_ENABLE_NEG_RES_ON_SID_WITH_SET_BIT6)
    /* nothing to do */
# else
    else
    {
      /* Reset the additional channel state */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].status = kDescContextIdle;
      TpRxResetChannel(TP_CHANNEL_RX_PARAM_VALUE);
    }
# endif
    break;
  default:
    /* Unknown type */
    DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
    break;
  }
#endif
}


/*******************************************************************************
* NAME:              DescRxErrorIndication
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Release the lock mechanism for Rx on error by receiving.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpXXXErrorIndication".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescRxErrorIndication(TP_CHANNEL_RX_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(status);
  TP_CHANNEL_RX_PARAM_IGNORE_UNREF;

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].type)
  {
    case kDescMainReception:
#endif
      {
#if defined (DESC_ENABLE_PARALLEL_OBD)
        DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
        DESC_TPCONTEXT_PARAM_VALUE = g_busInfoPoolRxRef[TP_CHANNEL_RX_PARAM_VALUE]->descHandle;
#endif
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        DescUsdtNetIsoTpAssertChannel(g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle == TP_CHANNEL_RX_PARAM_VALUE, kDescNetAssertWrongIsoTpRxChannel);
#endif
        /* reception error - notify CANdesc */
        DescUsdtNetFinishReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE], kDescUsdtNetworkAbort);
      }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      break;
    case kDescAddReception:
      /* reset the additional cahnnel status */
      g_descAddChannelCtrl.channel[g_descTpCtrl.rxPath[TP_CHANNEL_RX_PARAM_VALUE].info].status = kDescContextIdle;
      break;
    default:
      /* Unknown type */
      DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
      break;
  }
#endif
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpPrepareResponse
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS: 
*
* DESCRIPTION:       Prepare address info for response message
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpPrepareResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
#if (TP_USE_EXTENDED_ADDRESSING           == kTpOn)      || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
  vuint8 sourceAddress;

  DescUsdtNetIsoTpAssertUser(infoPool->busInfo.busType == kDescUsdtNetBusTypeIsoTp, kDescNetAssertWrongBusType);

  /* Swap Source- and TargetAddress */
  sourceAddress = infoPool->busInfo.addressingInfo.isoTp.SourceAddress;
  infoPool->busInfo.addressingInfo.isoTp.SourceAddress  = infoPool->busInfo.addressingInfo.isoTp.TargetAddress;
  infoPool->busInfo.addressingInfo.isoTp.TargetAddress = sourceAddress;
#else
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(infoPool);
#endif
}

/*******************************************************************************
* NAME:              DescTransmitResponse
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS: 
*
* DESCRIPTION:       Response transmission function
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpTransmitResponse(t_descUsdtNetInfoPoolPtr infoPool)
{
  vuint8 result;
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if ( defined (TP_ENABLE_DYNAMIC_CHANNELS) || defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND) )
  vuint8 tpTxChannel;
# endif
#endif
#if defined (DESC_ENABLE_PARALLEL_OBD)
  DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
#endif
  volatile t_descUsdtNetInfoPoolPtr* lBusInfoPoolTxRef;

  DescUsdtNetIsoTpAssertUser(infoPool->busInfo.busType == kDescUsdtNetBusTypeIsoTp, kDescNetAssertWrongBusType);

#if defined (DESC_ENABLE_PARALLEL_OBD)
  DESC_TPCONTEXT_PARAM_VALUE = infoPool->descHandle;
#endif


#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
  tpTxChannel = g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE];
  infoPool->busHandle = tpTxChannel;
# else
#  if defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
  tpTxChannel = g_descCan2TpChannelMap[DESC_COMM_CHANNEL_PARAM_WRAP_INDEX(infoPool->busInfo.comChannel)];
#  endif
# endif
#endif

  /* Avoid compiler optimization */
  lBusInfoPoolTxRef = &g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE];

  /* Busy ? */
  if(*lBusInfoPoolTxRef != V_NULL)
  {
    DescInterruptDisable();
    /* Still busy ? */
    if(*lBusInfoPoolTxRef != V_NULL)
    {
      t_descUsdtNetInfoPoolPtr lBusInfoPoolTxRefBackup;
      /* Push old content */
      lBusInfoPoolTxRefBackup = g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE];
      /* assign temporarly the new resource to be finalized */
      g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = infoPool;
      /* Cancel the transmission */
      DescConfirmation(TP_CHANNEL_TX_PARAM_FIRST kTpBusy);
      /* Pop old content */
      g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = lBusInfoPoolTxRefBackup;
      DescInterruptRestore();
      return;
    }
    DescInterruptRestore();
  }

  g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = infoPool;

#if defined (TP_ENABLE_EXTENDED_ADDRESSING)     || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
  TpTxSetTargetAddress (TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.testerId); /* use the abstract info for spontaneus responses */
#endif
#if ( kTpNumberOfCanChannels > 1 ) /* more than one canChannel ? */
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
  TpTxSetCanChannel(TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.comChannel);/* use the abstract info for spontaneus responses */
# endif
#endif
#if (TP_USE_EXTENDED_ADDRESSING           == kTpOn)      || \
    defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
    defined (TP_ENABLE_MIXED_29_ADDRESSING)
# if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
  TpTxSetEcuNumber(TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.addressingInfo.isoTp.SourceAddress);
# endif
#endif
#if defined (TP_ENABLE_EXTENDED_ADDRESSING)
# if (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
  TpTxSetBaseAddress(TP_CHANNEL_TX_PARAM_FIRST infoPool->busInfo.addressingInfo.isoTp.BaseAddress);
# endif
#endif

#if (!defined (TP_ENABLE_DYNAMIC_CHANNELS) && !defined (TP_ENABLE_SINGLE_CHANNEL_TP))
# if defined (DESC_ENABLE_DESC_ON_MULTI_CAN) && \
     !defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
/* In order to use CANdesc on multiple CANchannels, define DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND 
 * in your user config file and define the CAN to TPconnection association e.g.:
  #define kDescCan2TpChannel_0    1 - if CAN 0 corresponds to TPconnection 1 */
#  error "CANdesc on multiple CANchannels needs DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND!"
# endif
#endif

#if (!defined (TP_ENABLE_DYNAMIC_CHANNELS) && !defined (TP_ENABLE_SINGLE_CHANNEL_TP))
  /* Overwrite the 0xFE value to avoid assertions to be miscalled. */
  infoPool->busHandle = TP_CHANNEL_TX_PARAM_VALUE;
  /* CAN-channel to TP-channel */
  DescUsdtNetIsoTpAssertUser((TP_CHANNEL_TX_PARAM_VALUE != kTpNoChannel), kDescNetAssertWrongIsoTpTxChannel);

# if defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND)
  result = DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_VALUE, infoPool->resDataPtr, infoPool->dataLength);
# else
#  if defined(DESC_ENABLE_DOBT_SUPPORT)
#   error "DOBT on static multi TPMC is not supported!"
#  endif
  result = TpTransmitDiag(infoPool->resDataPtr, infoPool->dataLength);
# endif
#else
  result = DanisIsoTpTransmit(TP_CHANNEL_TX_PARAM_VALUE, infoPool->resDataPtr, infoPool->dataLength);
#endif
  if (result != kTpSuccess)
  { /* Cancel the transmission */
    DescConfirmation(TP_CHANNEL_TX_PARAM_FIRST result);
  }
}

#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
/*******************************************************************************
* NAME:              DescUsdtNetIsoTpGetRingBuffTxMinLen
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS:
*
* DESCRIPTION:       Get Minimum Length
*
*
*******************************************************************************/
DESCNET_USDT_STATIC vuint16 DescUsdtNetIsoTpGetRingBuffTxMinLen(t_descUsdtNetInfoPoolPtr infoPool)
{
  DESC_IGNORE_UNREF_PARAM(infoPool);
  return (vuint16) 0x06;
}
#endif

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpCopyToCan
*
* CALLED BY:         DescCopyToCAN
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides abstract copy functionality between CANdriver and DANIS.
*******************************************************************************/
static void DescUsdtNetIsoTpCopyToCan(TpCopyToCanInfoStructPtr infoStruct)
{
  vuint8_least i = infoStruct->Length;
  while(i--)
  {
    infoStruct->pDestination[i] = infoStruct->pSource[i];
  }
}

/*******************************************************************************
* NAME:              DescCopyToCAN
*
* CALLED BY:         Transport layer
* PRECONDITIONS:     
*
* DESCRIPTION:       Callback for filling the data into the Tx buffer.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpCopyToCan".
*******************************************************************************/
vuint8 TP_API_CALLBACK_TYPE DescCopyToCAN(TpCopyToCanInfoStructPtr infoStruct)
{
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
  vuint8 returnValue = kTpFailed;
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
#  if ( defined (TP_ENABLE_DYNAMIC_CHANNELS) || defined (DESC_ENABLE_MULTI_TP_MULTI_CAN_WORKAROUND) )
  vuint8 TP_CHANNEL_TX_PARAM_ONLY = infoStruct->Channel;
#  endif
# endif
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.txPath[infoStruct->Channel].type)
  {
    case kDescMainTransmission:
#endif
#if defined (DESC_USDTNET_ENABLE_RING_BUFFER)
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
      DescUsdtNetIsoTpAssertChannel(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->busHandle == TP_CHANNEL_TX_PARAM_VALUE, kDescNetAssertWrongIsoTpTxChannel);
# endif
      if (g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->resType == kDescUsdtResponseRingBuffer)
      {
        t_descUsdtNetResult result;
# if defined(C_COMP_COSMIC_MCS12X_MSCAN12) && \
     defined(V_ENABLE_USED_GLOBAL_VAR)
        result = DescUsdtNetRingBufferCopyRoutine(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE], &g_descCopyToCanData[0], (vuint8)infoStruct->Length);
# else
        result = DescUsdtNetRingBufferCopyRoutine(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE], (DescUsdtNetMsg)infoStruct->pDestination, (vuint8)infoStruct->Length);
# endif
        if (result == kDescUsdtNetworkOk)
        {
# if defined(C_COMP_COSMIC_MCS12X_MSCAN12) && \
     defined(V_ENABLE_USED_GLOBAL_VAR)
          infoStruct->pSource = &g_descCopyToCanData[0];
          DescUsdtNetIsoTpCopyToCan(infoStruct);
# endif
          returnValue = kTpSuccess;
        }
      }
      else
      {
        DescUsdtNetIsoTpCopyToCan(infoStruct);
        returnValue = kTpSuccess;
      }
      return returnValue;
#else
      {
        DescUsdtNetIsoTpCopyToCan(infoStruct);
        return kTpSuccess;
      }
#endif

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    case kDescAddTransmission:
      DescUsdtNetIsoTpCopyToCan(infoStruct);
      return kTpSuccess;   /*Everythings ok now*/
    default:
      /* Unknown type */
      break;
    }
    DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
    return kTpSuccess;   /*Everythings ok now*/
#endif
}

/*******************************************************************************
* NAME:              DescConfirmation
*
* CALLED BY:         Transport layer
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides the post transmission processing.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpConfirmation".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescConfirmation(TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  t_descUsdtNetResult result;
  TP_CHANNEL_TX_PARAM_IGNORE_UNREF;

#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
  switch (g_descTpCtrl.txPath[tpTxChannel].type)
  {
    case kDescMainTransmission:
#endif
      {
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
        DescUsdtNetIsoTpAssertChannel(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->busHandle == TP_CHANNEL_TX_PARAM_VALUE, kDescNetAssertWrongIsoTpTxChannel);
#endif
        /* Translate the TP parameter to the DESC_NET type */
        result = (status != kTpSuccess) ? kDescUsdtNetworkAbort:kDescUsdtNetworkOk;

        DescUsdtNetFinishTransmission(g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE], result);
      /* No response any more is reset by CANdesc (DescUsdtNetFinishTransmission) */
      /* g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->resType = kDescUsdtResponseNone;*/
      }
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      break;
    case kDescAddTransmission:
      /* Decrease pending count of additionally requests */
      DescUsdtNetIsoTpAssertUser((g_descAddChannelCtrl.count != 0), kDescAssertIllegalAddRequestCount);
      if(g_descAddChannelCtrl.count != 0)
      {
        g_descAddChannelCtrl.count--;
      }

      g_descAddChannelCtrl.channel[g_descTpCtrl.txPath[tpTxChannel].info].status = kDescContextIdle;
      break;
    default:
      /* Unknown type */
      DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
      break;
  }
#endif

  g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE] = V_NULL;
}

/*******************************************************************************
* NAME:              DescTxErrorIndication
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Release the lock mechanism for Tx on error by sending.
*                    Function name must be entered to the CANgen TP setup 
*                    dialog in the fields "TpXXXErrorIndication".
*******************************************************************************/
vuint8 TP_API_CALLBACK_TYPE DescTxErrorIndication(TP_CHANNEL_TX_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(status);
  TP_CHANNEL_TX_PARAM_IGNORE_UNREF;

#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
  if (g_busInfoPoolTxRef[TP_CHANNEL_TX_PARAM_VALUE]->busHandle == TP_CHANNEL_TX_PARAM_VALUE)
#endif
  {
    /* Flush the response */
    DescConfirmation(TP_CHANNEL_TX_PARAM_FIRST status);
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
    switch (g_descTpCtrl.txPath[tpTxChannel].type)
    {
      case kDescMainTransmission:
#endif
        return kTpHoldChannel;
#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
      case kDescAddTransmission:
        return kTpFreeChannel;
      default:
        /* Unknown type */
        DescUsdtNetIsoTpAssertUserAlways(kDescAssertUnknownTpTransmissionType);
        return kTpFreeChannel;
    }
#endif
  }
#if defined (DESC_USDTNET_ENABLE_MULTI_TP)
  else
  {
    return kTpFreeChannel;
  }
#endif
}

/*******************************************************************************
* NAME:              DescUsdtNetIsoTpReleaseInfoPool
*
* CALLED BY:         CANdesc (Dispatcher)
* PRECONDITIONS: 
*
* DESCRIPTION:       Release of infopool
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetIsoTpReleaseInfoPool(t_descUsdtNetInfoPoolPtr infoPool)
{
  DescUsdtNetIsoTpAssertUser(infoPool->busInfo.busType == kDescUsdtNetBusTypeIsoTp, kDescNetAssertWrongBusType);
  infoPool->descHandle = kDescUsdtNetInvalidDescContext;
}


#if defined (DESC_ENABLE_BUSY_REPEAT_RESPONDER)
/******************************************************************************
* NAME:              DescBusyResponseHandler
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Busy response handler for additional received requests
*
*******************************************************************************/
static void DescBusyResponseHandler(void)
{
  vuint8_least addIter;
  vuint8       tpTxChannel;

  /* */
  if (g_descAddChannelCtrl.count != 0)
  {
    addIter = kDescNumAddRequestChannels;
    while(addIter != 0)
    {
      --addIter;
      if(g_descAddChannelCtrl.channel[addIter].status == kDescContextActiveProcess)
      {
        tpTxChannel = TpTxGetFreeChannel(kDescDiagAddConnection);
        if (tpTxChannel != kTpNoChannel)
        {
          g_descTpCtrl.txPath[tpTxChannel].type = kDescAddTransmission;
          /* store additional request channel number */
          g_descTpCtrl.txPath[tpTxChannel].info = (vuint8)addIter;
          /* copy the TP addressinformations from rx channel to tx channel */
          /* tpRxChannel is stored in 6.th byte of dummy buffer */
          TpTxSetResponse(g_descAddChannelCtrl.channel[addIter].buffers.res.tpRxChannel, tpTxChannel);

          g_descAddChannelCtrl.channel[addIter].status = kDescContextActiveTx;

          if (DanisIsoTpTransmit(tpTxChannel, g_descAddChannelCtrl.channel[addIter].buffers.res.resBuffer, 3) == kTpSuccess)
          {
            TpRxResetChannel(g_descAddChannelCtrl.channel[addIter].buffers.res.tpRxChannel);
          }
          else
          { /* If we can not send the data, we have to terminate this channel and try it at next cycle */
            g_descAddChannelCtrl.channel[addIter].status = kDescContextActiveProcess;
            TpTxResetChannel(tpTxChannel);
          }
        }
      }
    }
  }
}
#endif

#if defined(TP_FUNC_ENABLE_RECEPTION) && \
    !defined (TP_ENABLE_EXTENDED_ADDRESSING)
/*******************************************************************************
* NAME:              DescGetFuncBuffer
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       StartOfFrame reception function
*                    
*******************************************************************************/
TP_MEMORY_MODEL_DATA vuint8* TP_API_CALLBACK_TYPE DescGetFuncBuffer(vuint16 dataLength)
{
  DescUsdtNetMsg returnValue = V_NULL;

# if (defined (DESC_ENABLE_FUNCREQ_TA_CHECK) || defined (DESC_ENABLE_FUNCREQ_SA_CHECK))
  DescBool addressCheckResult;

#  if defined (DESC_ENABLE_FUNCREQ_TA_CHECK)
  addressCheckResult = DescOemCheckFuncTargetAddress(TpFuncGetTargetAddress());
  if(addressCheckResult == kDescTrue)
#  endif
  {
#  if defined (DESC_ENABLE_FUNCREQ_SA_CHECK)
    addressCheckResult = DescOemCheckFuncSourceAddress(TpFuncGetSourceAddress());
#  endif
  }

  if(addressCheckResult == kDescTrue)
# endif
  {
# if defined (DESC_ENABLE_PARALLEL_OBD)
    DESC_TPCONTEXT_PARAM_DEF_LOCAL /* For OBD */
    DESC_TPCONTEXT_PARAM_VALUE = DescDispatchServiceContext(TpFuncGetCanBuffer()[0]);
# endif
    if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle == kDescUsdtNetInvalidDescContext)
    {
      t_descUsdtNetResult result;

      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.busType   = kDescUsdtNetBusTypeIsoTp;
# if ( kCanNumberOfChannels > 1 ) /* more than one canChannel ? */
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel = TpFuncGetCanChannel();
      /* Make the communication channel ID visible to the above layer */
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.comChannel = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.CanChannel;
# endif
# if defined (TP_ENABLE_EXTENDED_ADDRESSING)      || \
     defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING)  || \
     defined (TP_ENABLE_MIXED_29_ADDRESSING)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress = TpFuncGetSourceAddress();
      /* Make the tester ID visible to the above layer */
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.testerId = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.SourceAddress;

    /* g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpRxGetReceivedTargetAddress (TP_CHANNEL_RX_PARAM_VALUE); */
# endif
# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle         = 0xfe;
# endif
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqType           = kDescUsdtNetReqTypeFunctional;
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resType           = kDescUsdtResponseNone;
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr        = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].resDataPtr        = g_descBuffer[DESC_TPCONTEXT_PARAM_VALUE];
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].dataLength        = dataLength;
      g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle        = DESC_TPCONTEXT_PARAM_VALUE; /* Write used context */
      /* Check if Desc itself is free */
      result = DescUsdtNetStartReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE]);
      if(result == kDescUsdtNetworkOk)
      { /* it is */
        returnValue = g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].reqDataPtr;
# if defined (DESC_ENABLE_PARALLEL_OBD)
       /* store the working context type */
       g_busInfoPoolRxRef[kDescUsdtNetFuncInfPoolRef] = &g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE];
# endif
      }
      else
      {
        g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].descHandle = kDescUsdtNetInvalidDescContext;
      }
    }
  }
  /* discard reception */
  return returnValue;
}

/*******************************************************************************
* NAME:              DescFuncReqInd
*
* CALLED BY:         Transport layer
* PRECONDITIONS: 
*
* DESCRIPTION:       Rx path for physical requests.
*                    Function name must be entered to the CANgen OSEK-TP Options 
*                    dialog in the fields "RxIndication".
*******************************************************************************/
void TP_API_CALLBACK_TYPE DescFuncReqInd(vuint16 dataLen)
{
# if defined (DESC_ENABLE_PARALLEL_OBD)
  DESC_TPCONTEXT_PARAM_DEF_LOCAL
# endif

  /* Avoid warnings*/
  DESC_IGNORE_UNREF_PARAM(dataLen);

# if defined (DESC_ENABLE_PARALLEL_OBD)
   /* store the working context type */
  DESC_TPCONTEXT_PARAM_VALUE = g_busInfoPoolRxRef[kDescUsdtNetFuncInfPoolRef]->descHandle;
# endif

# if defined (DESC_USDTNET_ENABLE_MULTI_TP)
  if (g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busHandle == 0xfe)
# endif
  {
    /*-----------------------------*/
    /*Transport protocol management*/
    /*-----------------------------*/
# if defined (TP_ENABLE_DYNAMIC_CHANNELS)
#  if defined (TP_ENABLE_NORMAL_ADDRESSING)       || \
      defined (TP_ENABLE_MIXED_11_ADDRESSING)
    g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.ReceiveID = TpFuncGetReceiveCanID();
    TpFuncSetResponse(g_descUsdtNetTpTxChannel[DESC_TPCONTEXT_PARAM_VALUE]);
#  endif
# endif
# if (TP_USE_MULTIPLE_ECU_NR == kTpOn)
    g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = TpFuncGetTargetAddress();
# else
#  if (TP_USE_EXTENDED_ADDRESSING == kTpOn) || \
      defined (TP_ENABLE_NORMAL_FIXED_ADDRESSING) || \
      defined(TP_FUNC_ENABLE_EXTENDED_ADDRESSING) || \
      defined (TP_ENABLE_MIXED_29_ADDRESSING)
    g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.TargetAddress = kDescEcuNumber;
#  endif
# endif
# if (TP_USE_EXTENDED_ADDRESSING == kTpOn)
#  if (TP_USE_MULTIPLE_BASEADDRESS == kTpOn)
    g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE].busInfo.addressingInfo.isoTp.BaseAddress = TpFuncGetBaseAddress();
#  endif
# endif
    /* Reception has finished */
    DescUsdtNetFinishReception(&g_descUsdtNetInfoPoolIsoTp[DESC_TPCONTEXT_PARAM_VALUE], kDescUsdtNetworkOk);
    /* Reset the channel */
    TpFuncResetChannel();
  }
}
#endif

#if defined(DESC_ENABLE_NODE_POWER_CONTROL) || (kDescNumContexts > 1) || defined(DESC_ENABLE_SPONTANEOUS_RES)
/*******************************************************************************
* NAME:              DescNetworkOnceInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the network subcomponent specific data.
*
*******************************************************************************/
static void DescNetworkOnceInit(void)
{
# if (kDescNumContexts > 1)
  g_descActiveRequestsMask = 0;
# endif

# if defined(DESC_ENABLE_NODE_POWER_CONTROL)
#  if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  g_descNpmTimer = 0;
#  endif

  /* Not necessary since the timer is not running 
   * g_descDoReloadNpmTimer = 0;
   */

  /* Reset channel map and queue */
  g_descCanChannelMap = 0;
  g_descCanChannelMapQueue = 0;
# endif
# if defined (DESC_ENABLE_SPONTANEOUS_RES)
  /* Initialization of the spontaneous pool */
  g_descUsdtNetSpontanResInfoPool.resType = kDescUsdtResponseNone;
  /* will be done at transmission time:
  g_descUsdtNetSpontanResInfoPool.descHandle = kDescPrimContext;
  g_descUsdtNetSpontanResInfoPool.reqDataPtr = V_NULL; 
  g_descUsdtNetSpontanResInfoPool.busInfo.busType = kDescUsdtNetBusTypeIsoTp;
  */
# endif
  /* Don't forget the USDT NET */
  DescNetworkInit();
}
#endif

/*******************************************************************************
* NAME:              DescNetworkIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the network subcomponent context specific data.
*
*******************************************************************************/
static void DescNetworkIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Init the buffer state mashine */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].txState = kDescUsdtNetworkOk;
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError = 0;
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;

  /* Interrupt context controller */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextIdle;
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].isContextLocked = 0;
#if defined (DESC_ENABLE_FORCE_RCR_RP)
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpIdle;
#endif

  /* Prepare for RCR-RP negative response - the SID will be filled 
  when the T2 timer expires */
  g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE][0] = kDescNegResSId;
  g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE][2] = kDescNrcResponsePending;

#if defined (DESC_ENABLE_RES_RINGBUFFER)
  DescRingBufferIterInit(DESC_CONTEXT_PARAM_ONLY);
#endif

}

/*******************************************************************************
* NAME:              DescReleaseContext
*
* CALLED BY:         CANdesc
* PRECONDITIONS: 
*
* DESCRIPTION:       releases the RX path and manages the S1 timer
*******************************************************************************/
static void DescReleaseContext(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_ENABLE_DESCICN_SUPPORT)
  /* Check if this instance is a internal request */
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqType != kDescUsdtNetReqTypeInternal)
#endif
  {
    /* Force reloading the S1 timer (will affect only if timer active) */
    g_descDoReloadS1Timer = kDescTrue;
    /* Notify the application */
    ApplDescOnEndOfProcExt();
  }
  /* Deactivate the connection */
  DescResetConnectionActive(DESC_CONTEXT_PARAM_VALUE);
  /* Release context */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].isContextLocked = 0;
  /* Release the network resource */
  DescUsdtNetAbsReleaseInfoPool(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr );
}

#if defined (DESC_ENABLE_SPONTANEOUS_RES)
/*******************************************************************************
* NAME:              DescSendSpontaneousResponse
*
* CALLED BY:         Desc internal
* PRECONDITIONS: 
*
* DESCRIPTION:       Any time can make the application a single frame response.
*******************************************************************************/
static DescBool DescSendSpontaneousResponse(DescMsg resData, DescMsgLen resLen, t_descUsdtNetBus* pBusInfo)
{
  if(g_descUsdtNetSpontanResInfoPool.resType == kDescUsdtResponseNone)
  {
    DescInterruptDisable();
    if(g_descInterruptContextCtrl[kDescPrimContext].activity == kDescContextIdle)
    {
      /* Lock the component for RX */
      g_descInterruptContextCtrl[kDescPrimContext].isContextLocked = 1;
      DescInterruptRestore();

      /* Store into the global variables */
      g_descUsdtNetSpontanResInfoPool.descHandle = kDescPrimContext;
      g_descUsdtNetSpontanResInfoPool.reqDataPtr = V_NULL;
      g_descUsdtNetSpontanResInfoPool.resDataPtr = resData;
      g_descUsdtNetSpontanResInfoPool.busInfo = *pBusInfo;
      g_descUsdtNetSpontanResInfoPool.dataLength = resLen;
      g_descUsdtNetSpontanResInfoPool.resType = kDescUsdtResponseSpontaneous;

      DescUsdtNetAbsTransmitResponse(&g_descUsdtNetSpontanResInfoPool);
      return kDescTrue;
    }
    /* Ignore */
    DescInterruptRestore();
  }
  return kDescFalse;
}
#endif

#if defined (DESC_ENABLE_ROE_USDT_TRANSMITTER)
/*******************************************************************************
* NAME:              DescRoeResponderIsFree
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
vuint8 DescRoeResponderIsFree(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
# if 0
  DescInterruptDisable();
  /* Check if currently no request will be processed */
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextIdle)
  {
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTxRoeResponder;
    DescInterruptRestore();
    return kDescOk;
  }
  DescInterruptRestore();
# endif
  return kDescFailed;
}

/*******************************************************************************
* NAME:              DescRoeResponderTransmit
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
vuint8 DescRoeResponderTransmit(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8* dataPtr, vuint16 dataLength)
{
# if 0
  vuint8 result;
  /* The response message is already filled with the necessary information */
  /* Check if currently no request will be processed */
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveTxRoeResponder)
  {
    result = DescTransmit(dataPtr, dataLength);
    if (result == kDescUsdtNetworkOk)
    {
      DescTxStateTask();
      return kDescOk;
    }
  }
# endif
  return kDescFailed;
}

/*******************************************************************************
* NAME:              DescRoeResponderReset
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
void DescRoeResponderReset(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
# if 0
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextIdle;
# endif
}

/*******************************************************************************
* NAME:              DescDoRoeResponderPostProcessing
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static void DescDoRoeResponderPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult status)
{
  vuint8 result;
  /* Interpret the status */
  result = ((status == kDescUsdtNetworkOk)?kDescOk:kDescFailed);
  /* Confirm the forced RCR-RP resposne transmission */
  ApplDescRoeResponderConfirmation(DESC_CONTEXT_PARAM_FIRST result);
  /* Release the context */
  DescRoeResponderReset(DESC_CONTEXT_PARAM_ONLY);
}
#endif

#if defined (DESC_ENABLE_POS_RES_ON_SET_SPRMIB)
/* Not needed */
#else
/*******************************************************************************
* NAME:              DescIsTesterPresent
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescBool DescIsTesterPresent(t_descUsdtNetInfoPoolPtr infoPool)
{
  DescBool returnValue = kDescFalse;

  if ((infoPool->reqType == kDescUsdtNetReqTypeFunctional) && /* Only for functional request */
      (infoPool->reqDataPtr[0] == 0x3e) &&                /* Is it a TesterPresent? */
      (infoPool->reqDataPtr[1] == 0x80) &&                /* Is the SPRIMB set?*/
      (infoPool->dataLength == 0x02))                     /* Do little format check */
  {
    /* Reloading the S1 timer (will affect only if timer active) will be performed at DescReleaseContect call */
    returnValue = kDescTrue;
  }
  return returnValue;
}
#endif

#if defined(DESC_ENABLE_PERIODIC_MODE) && defined (DESC_ENABLE_SCHEDULER_UUDT_TRANSMITTER)
/*******************************************************************************
* NAME:              DescUudtNetFinishTransmission
*
* CALLED BY:         Transport layer
* PRECONDITIONS:     
*
* DESCRIPTION:       Provides the post transmission processing.
*                    The used resources should be freed  
*                    
*******************************************************************************/
DESCNET_UUDT_STATIC void DescUudtNetFinishTransmission(t_descUudtNetInfoPoolPtr infoPool, t_descUudtNetResult status)
{
  DESC_IGNORE_UNREF_PARAM(infoPool);
  DESC_IGNORE_UNREF_PARAM(status);
  DescDoSchedulePostProcessing();
}
#endif

/*******************************************************************************
* NAME:              DescNetworkInitPowerOn
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the current state of the CANdesc component
*
*******************************************************************************/
static void DescNetworkInitPowerOn(void)
{
  DescUsdtNetAbsInitPowerOn();
  DescUudtNetInitPowerOn();
}


/*******************************************************************************
* NAME:              DescNetworkInit
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the current state of the CANdesc component
*
*******************************************************************************/
static void DescNetworkInit(void)
{
  DescUsdtNetAbsInit();
  DescUudtNetInit();
}

/*******************************************************************************
* NAME:              DescGetActivityState
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Reports the current state of the CANdesc component
*
*******************************************************************************/
vuint8 DESC_API_CALL_TYPE DescGetActivityState(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity;
}

#if defined(DESC_ENABLE_DESCICN_SUPPORT)
/*******************************************************************************
* NAME:              DescICNRxMsgInd
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescICNRxMsgInd(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  switch(infoPool->busInfo.addressingInfo.descICN.Client)
  {
# if defined(DESC_ENABLE_DYN_DEFINED_DID_CLIENT)
    case kDescIcnClientDynDefDid:
      DescDynDefinedDidRxMsgInd(infoPool, status);
      break;
# endif
# if defined(DESC_ENABLE_DYN_DEFINED_DPID_CLIENT)
    case kDescIcnClientDynDefDpid:
      DescDynDefinedDpidRxMsgInd(infoPool, status);
      break;
# endif
# if defined(DESC_ENABLE_ROE_CLIENT)
    case kDescIcnClientRoe:
      DescRoeRxMsgInd(infoPool, status);
      break;
# endif
    default:
      DescAssertInternalAlways(kDescAssertInvalidDescICNClient);
      break;
  }
}
#endif


/*******************************************************************************
* NAME:              DescUsdtNetAbsStartReception
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       StartOfFrame reception function
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC t_descUsdtNetResult DescUsdtNetAbsStartReception(t_descUsdtNetInfoPoolPtr infoPool)
{
  t_descUsdtNetResult returnValue = kDescUsdtNetworkFailed;

  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].isContextLocked == 0)
  {
#if defined (DESC_ENABLE_CHECK_MSG_RX_ACCEPTANCE)
    if(DescOemCheckAcceptance(infoPool) != kDescFalse)
#endif
    {
      /* Lock the buffer */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].isContextLocked = 1;
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].activity |= kDescContextActiveRxBegin;

      /* Store infoPool reference */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].infoPoolPtr = infoPool;

      /* Set connection active for S1 timer check */
      DescSetConnectionActive(infoPool->descHandle);

#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
      DescSetNpmOnCanChannelActive(infoPool->busInfo.comChannel, g_descCanChannelMapQueue);
#endif
#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
      /* Store the ISO TP Source Address */
      g_descTesterAddress[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)] = infoPool->busInfo.testerId;
#endif
      /* Notify the application */
#if defined (DESC_ENABLE_DESCICN_SUPPORT)
      /* Check if this instance is a internal request */
      if(infoPool->reqType != kDescUsdtNetReqTypeInternal)
#endif
      {
        ApplDescOnBeginOfProcExt();
      }
      /* Notify the implementation */
      DescOemOnRxStart(infoPool);
      returnValue = kDescUsdtNetworkOk;
    }
  }
  return returnValue;
}


/*******************************************************************************
* NAME:              DescUsdtNetAbsFinishReception
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       reception has finished
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetAbsFinishReception(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  /* Clear this state always!!! (in error case lefts ContextIdle then) */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].activity &= (DescContextActivity)(~kDescContextActiveRxBegin);
  if ((status == kDescUsdtNetworkOk) &&
      (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].infoPoolPtr == infoPool))
  {
    /* Check if a TesterPresent is requested with SuppresPosBit set to not lock Desc */
    DescBool result = DescIsTesterPresent(infoPool);
    if (result == kDescFalse)
    {
      /* On physical requested message actions (for S1 timer normally)*/
      DescOemOnReqInd(infoPool->descHandle);

      g_descMsgContext[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].busInfo = infoPool->busInfo;

      DescUsdtNetAbsPrepareResponse(infoPool);

      /* Sets indication flag for cyclic task */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(infoPool->descHandle)].activity |= kDescContextActiveRxEnd;
      /*TBD: DescSetEvent(DescDSDTask, descRequestReceived)*/
      return;
    }
  }
  else
  { /* Reception error had happened */
    DescOemOnRxErrorInd(status);
  }
  DescReleaseContext(DESC_CONTEXT_PARAM_WRAPPER_ONLY(infoPool->descHandle));
}

/*******************************************************************************
* NAME:              DescUsdtNetAbsFinishTransmission
*
* CALLED BY:         Desc Network Layer
* PRECONDITIONS: 
*
* DESCRIPTION:       transmission has finished
*                    
*                    
*******************************************************************************/
DESCNET_USDT_STATIC void DescUsdtNetAbsFinishTransmission(t_descUsdtNetInfoPoolPtr infoPool, t_descUsdtNetResult status)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL

#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_ONLY = infoPool->descHandle;
#endif

  if (status == kDescUsdtNetworkOk)
  {
    /* nothing to do */
  }
  else
  {
    DescOemOnTxErrorInd(status);
  }

  switch (infoPool->resType)
  {
  case kDescUsdtResponsePositive:
    /* fall through */
  case kDescUsdtResponseNegative:
    /* fall through */
  case kDescUsdtResponseRingBuffer:
    /* Make post processing not always success (if called from the error indication)*/
    DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST status);
#if defined(DESC_ENABLE_SPONTANEOUS_RES)
    /* fall through */
  case kDescUsdtResponseSpontaneous:
# if defined (DESC_ENABLE_PROTOCOL_UDS)
#  if defined (DESC_ENABLE_ROE_SUPPORT)
    if(infoPool->resType == kDescUsdtResponseSpontaneous)
    {
      /* Notify the ROE handler */
      DescRoeResponseConfirmation();
    }
#  endif
    /* Release context here */
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].isContextLocked = 0;
# endif
#endif
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
    if (infoPool->resDataPtr != infoPool->reqDataPtr )
    {
      DescUsdtNetReleaseTransmissionObj(infoPool);
    }
#endif
    break;
#if defined (DESC_ENABLE_FORCE_RCR_RP)
  case kDescUsdtResponseNegativeApplRCR_RP:
    {
      vuint8 result;
      /* Interpret the status */
      result = (vuint8)((status == kDescUsdtNetworkOk)?kDescOk:kDescFailed);
      /* Confirm the forced RCR-RP resposne transmission */
      ApplDescRcrRpConfirmation(DESC_CONTEXT_PARAM_FIRST result);
      /* no break - fall through */
    }
#endif
    /* fall through */
  case kDescUsdtResponseNegativeRCR_RP:
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
    if (infoPool->resDataPtr != g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE])
    {
      infoPool->resDataPtr = V_NULL;
      DescUsdtNetReleaseTransmissionObj(infoPool);
    }
#endif
    break;
#if defined(DESC_ENABLE_ROE_USDT_TRANSMITTER)
  case kDescUsdtResponseRoe:
    DescDoRoeResponderPostProcessing(DESC_CONTEXT_PARAM_FIRST status);
    break;
#endif
#if defined (DESC_ENABLE_SCHEDULER_USDT_TRANSMITTER)
  case kDescUsdtResponsePeriodic:
    DescDoSchedulePostProcessing();
    break;
#endif
  default:
    break;
  }
  /* Reset response type */
  infoPool->resType = kDescUsdtResponseNone;
}

/*******************************************************************************
* NAME:              DescTransmitRcrRp
*
* CALLED BY:         Desc
* PRECONDITIONS:     
*
* DESCRIPTION:       Transmission of RCR-RP
*
*******************************************************************************/
static void DescTransmitRcrRp(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
  /* Save code */
#else
  /* The response message is already filled with the necessary information */
  if (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr == V_NULL)
  {
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = DescUsdtNetGetTransmissionPtr(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
    memcpy(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr,g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE],3);
  }
  else
#endif
  {
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE];
  }
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength = kDescNegResLen;

  DescUsdtNetAbsTransmitResponse(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
  DescReloadT2TimerWithP3maxTime(DESC_CONTEXT_PARAM_VALUE);
  /* Custom management in case of timeout of T2 */
  DescOemOnT2Timeout(DESC_CONTEXT_PARAM_VALUE);
#if defined (DESC_ENABLE_ALL_RES_AFTER_RCRRP)
  g_descRcrrpSent[DESC_CONTEXT_PARAM_VALUE] = kDescTrue;
#endif
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
  g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE]--;
#endif
}

#if defined (DESC_ENABLE_ACCESS_TESTER_ADDRESS_API)
/*******************************************************************************
* NAME:              DescGetTesterAddress
*
* CALLED BY:         Application
* PRECONDITIONS: 
*
* DESCRIPTION:       Returns the tester address of the last request.
*******************************************************************************/
vuint8 DESC_API_CALL_TYPE DescGetTesterAddress(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return g_descTesterAddress[DESC_CONTEXT_PARAM_VALUE];
}
#endif

/*******************************************************************************
* NAME:              DescGetCurrentBusInfo
*
* CALLED BY:         Application
* PRECONDITIONS: 
*
* DESCRIPTION:       Returns the current communication parameters.
*******************************************************************************/
t_descUsdtNetBus* DESC_API_CALL_TYPE DescGetCurrentBusInfo (DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return &(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].busInfo);
}

/*******************************************************************************
* NAME:              DescTimingIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the timing subcomponent context data.
*
*******************************************************************************/
static void DescTimingIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
  DescDeactivateLimiter(DESC_CONTEXT_PARAM_VALUE);
}

#if defined (DESC_ENABLE_FORCE_RCR_RP)
/*******************************************************************************
* NAME:              DescForceRcrRpResponse
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Forces the CANdesc to send immediately a RCR-RP response.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescForceRcrRpResponse(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* Check if allowed such force RCR-RP to be used) 
   * To be able to send RCR-RP teh requested service must be a service which will send a response. */
  DescAssertUser(((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq & g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0), kDescAssertInvalidUsageOfForceRcrRpApi);
  /* Mark that a RCR-RP shall be sent immediately */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpCharged;
}
#endif

/* Functions */
/*******************************************************************************
* NAME:              DescTimingOnceInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the network subcomponent common data.
*
*******************************************************************************/
static void DescTimingOnceInit(void)
{
#if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
  /* Set the default session reference timings */
  g_descCurrSessionNumber = 0;
#endif

  /* Clear the flag to avoid one DescTask callcycle time S1 timeout jitter */
  g_descDoReloadS1Timer = kDescFalse;
  /* Deactivate the timers */
  DescDeactivateS1Timer();
}

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
/*******************************************************************************
* NAME:              DescNpmSetSleepInd
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Timer which will be running only when DESC not idle mode
*
*******************************************************************************/
static void DescNpmSetSleepInd(void)
{
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
  vuint8_least channel = kDescNumCommChannels;
  while(channel > 0)
  {
    channel--;
# endif
    if(DescIsNpmOnCanChannelActive(channel, g_descCanChannelMap))
    {
      DescNpmSetSleepReady(channel);
    }
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
  }
# endif
  /* Reset channel map */
  g_descCanChannelMap = 0;
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  /* Stop always here (even in dpmTimeout) */
  g_descNpmTimer = 0;
# endif
}
#endif

#if defined (DESC_ENABLE_NODE_POWER_CONTROL)
/*******************************************************************************
* NAME:              DescNpmProcessQueue
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Timer which will be running only when DESC not idle mode
*
*******************************************************************************/
static void DescNpmProcessQueue(void)
{
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  vuint8_least canChannelMapMirror;
  /* Something in the queue */
  if(g_descCanChannelMapQueue != 0)
  {
    /* Activate / reload the DPM timer (it is not running during reception and service processing) */
    g_descNpmTimer = kDescNpmTimerTicks;

    /* Make a safe copy of the queue */
    DescInterruptDisable();
    canChannelMapMirror = g_descCanChannelMapQueue;
    DescInterruptRestore();
# endif
    /* Merge queued and already active channels => leave only the new CAN channels */
    DescGetMirroredQueue(g_descCanChannelMapQueue, canChannelMapMirror) &= (vuintx)(~g_descCanChannelMap);
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
    {
      vuint8_least channel = kDescNumCommChannels;
      while(channel != 0)
      {
        channel--;
# endif
        if(DescIsNpmOnCanChannelActive(channel, DescGetMirroredQueue(g_descCanChannelMapQueue, canChannelMapMirror)))
        {
          DescNpmSetKeepAwake(channel);
        }
# if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
      }
    }
# endif
    /* Merge the queued channel to the activity map */
    g_descCanChannelMap |= DescGetMirroredQueue(g_descCanChannelMapQueue, canChannelMapMirror);
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
    DescInterruptDisable();
# endif
    /* Clear already processed flags */
    g_descCanChannelMapQueue &= (vuint8_least)(~g_descCanChannelMap);
# if defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
    DescInterruptRestore();
  }
# endif
}
#endif

#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
/*******************************************************************************
* NAME:              DescOemNpmTimer
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Timer which will be running only in DESC idle mode and default session active
*
*******************************************************************************/
static void DescOemNpmTimer(void)
{
  /* ----------------*/
  /* Activity Timeout*/
  /* ----------------*/
  if(g_descNpmTimer != 0)
  {
    /* Decrement timer */
    g_descNpmTimer--;
    /* Check for timeout */
    if(g_descNpmTimer == 0)
    {
      /* The same behavior as in a non-default session timeout */
      DescNpmSetSleepInd();
    }
  }
}
#endif

/*******************************************************************************
* NAME:              DescStateOnceInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the state subcomponent common data.
*
*******************************************************************************/
static void DescStateOnceInit(void)
{
  DescStateInit();
}

void DESC_API_CALL_TYPE DescStateInit(void)
{
  g_descCurState.stateSession = kDescStateSessionDefault;
  g_descCurState.stateSecurityAccess = kDescStateSecurityAccessLocked;
}


DescStateGroup DESC_API_CALL_TYPE DescGetStateSession(void)
{
  return g_descCurState.stateSession;
}


void DESC_API_CALL_TYPE DescSetStateSession(DescStateGroup descState)
{
  /* The new state shall not be zero */
  DescAssertCommon((descState != 0), kDescAssertZeroStateValue);
  DescOemOnTransitionSession(descState, g_descCurState.stateSession);
  ApplDescOnTransitionSession(descState, g_descCurState.stateSession);
  g_descCurState.stateSession = CANBITTYPE_CAST descState;
}


DescStateGroup DESC_API_CALL_TYPE DescGetStateSecurityAccess(void)
{
  return g_descCurState.stateSecurityAccess;
}


void DESC_API_CALL_TYPE DescSetStateSecurityAccess(DescStateGroup descState)
{
  /* The new state shall not be zero */
  DescAssertCommon((descState != 0), kDescAssertZeroStateValue);
  DescOemOnTransitionSecurityAccess(descState, g_descCurState.stateSecurityAccess);
  ApplDescOnTransitionSecurityAccess(descState, g_descCurState.stateSecurityAccess);
  g_descCurState.stateSecurityAccess = CANBITTYPE_CAST descState;
}


static DescNegResCode DescCheckState(V_MEMROM1 DescStateInfo V_MEMROM2 V_MEMROM3* refState)
{
  if((refState->stateSession & g_descCurState.stateSession) == 0)
  {
    return kDescNrcRejectStateSession;
  }
  if((refState->stateSecurityAccess & g_descCurState.stateSecurityAccess) == 0)
  {
    return kDescNrcRejectStateSecurityAccess;
  }
  return kDescNrcNone;
}


static void DescSetState(DescSvcInstIndex svcInstHandle)
{
  V_MEMROM1 DescStateInfo V_MEMROM2 V_MEMROM3* curRefState;
  if(g_descSvcInst[svcInstHandle].setStateIndex != kDescStateNoTransition)
  {
    curRefState = &g_descStateGroupTransition[g_descSvcInst[svcInstHandle].setStateIndex][0];
    DescInterruptDisable();
    if((g_descCurState.stateSession & curRefState->stateSession) != 0)
    {
      DescSetStateSession((curRefState+1)->stateSession);
    }
    if((g_descCurState.stateSecurityAccess & curRefState->stateSecurityAccess) != 0)
    {
      DescSetStateSecurityAccess((curRefState+1)->stateSecurityAccess);
    }
    DescInterruptRestore();
  }
}


#if defined(DESC_ENABLE_AUTO_STATES)
/*******************************************************************************
* NAME:              DescOnTransitionStateSession
*
* CALLED BY:         SetState
* PRECONDITIONS:     
*
* DESCRIPTION:       Special processing for the state group session.
*
*******************************************************************************/
static void DescOnTransitionStateSession(DescStateGroup newState, DescStateGroup currentState)
{
  /* On any transition */
  DescOemOnSessionTransition();

# if defined (DESC_ENABLE_SECURITY_ACCESS)
  /* Restore the security sequence */
  DescSecurityOnceInit();
# endif

# if defined (DESC_ENABLE_ROE_SUPPORT)
  DescClearRoeEvents();
# endif
  /* S1 Timer managment */
  if(currentState == kDescStateSessionDefault)
  {
    if(newState != kDescStateSessionDefault)
    {
      DescActivateS1Timer();
# if defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
      DescNpmProcessQueue();
# endif
      DescOemOnTransitionToNonDefaultSession();
    }
  }
  else
  {
    if(newState == kDescStateSessionDefault)
    {
      DescDeactivateS1Timer();
# if defined (DESC_ENABLE_PERIODIC_MODE)
      /* Clear the Scheduler */
      DescSchedulerInit();
# endif
# if defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
      DescNpmSetSleepInd();
# endif
      /* OEM implementation for this transition */
      DescOemOnTransitionToDefaultSession();
    }
  }
# if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
  /* In case of dynamical P2 timings - set the new session reference */
  g_descCurrSessionNumber = (vuint8)DescGetSessionStateBitPosition(newState);
# endif
}
#endif

#if defined(DESC_ENABLE_AUTO_STATES)
/*******************************************************************************
* NAME:              DescGetSessionStateOfSessionId
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Converts Session ID to its state.
*
*******************************************************************************/
DescStateGroup DESC_API_CALL_TYPE DescGetSessionStateOfSessionId(DescMsgItem sessionId)
{
  vuint8_least iter;
  vuint8_least scanner;
  vuint8_least step;
  V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * pReqHeadExt;
  DescStateGroup returnValue;
  step = DescGetSvcInstHeadExtEntrySize(&g_descSvcHead[kDescSvcHeadOffsetSDS]);

  /* First entry */
  pReqHeadExt = DescGetSvcInstReqHeadExt(&g_descSvcHead[kDescSvcHeadOffsetSDS], kDescSvcInstOffsetSDS);

  iter = 0;
  scanner = 0;
  while(iter < kDescNumStateSession)
  {
    if(pReqHeadExt[scanner] == sessionId)
    {
      break;
    }
    scanner+=step;
    iter++;
  }

  /* Check if found */
  DescAssertCommon((iter < kDescNumStateSession), kDescAssertInvalidStateParameterValue);

  /* Convert to bit mask */
  if(g_descSvcInst[iter + kDescSvcInstOffsetSDS].setStateIndex != kDescStateNoTransition)
  {
    returnValue = g_descStateGroupTransition[g_descSvcInst[iter + kDescSvcInstOffsetSDS].setStateIndex][1].stateSession;
  }
  else
  {
    /* Would mean illegal state was found */
    DescAssertCommonAlways(kDescAssertInvalidStateParameterValue);
    /*lint --e(527) */
    returnValue = kDescStateValueInvalid;
  }
  return returnValue;
}
#endif

#if defined(DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
/*******************************************************************************
* NAME:              DescGetSessionStateBitPosition
*
* CALLED BY:         SetState
* PRECONDITIONS:     
*
* DESCRIPTION:       Gathers the set bit number (0,1,...).
*
*******************************************************************************/
static vuint8_least DescGetSessionStateBitPosition(DescStateGroup sessionState)
{
  vuint8_least stateNumber = 1;

  /* Must be non-zero value */
  DescAssertCommon((sessionState != 0), kDescAssertZeroStateValue);
  while((sessionState>>stateNumber)!= 0)
  {
    stateNumber++;
  }
  /* correct the zero offset */
  stateNumber--;

  /* Must be one of the legal state values */
  DescAssertCommon((stateNumber < kDescNumStateSession), kDescAssertInvalidStateParameterValue);
  return stateNumber;
}
#endif

#if defined(DESC_ENABLE_AUTO_STATES)
/*******************************************************************************
* NAME:              DescGetSessionIdOfSessionState
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Converts given session state into its corresponding sub-function Id.
*
*******************************************************************************/
DescMsgItem DESC_API_CALL_TYPE DescGetSessionIdOfSessionState(DescStateGroup sessionState)
{
  vuint8_least iter;

  iter = kDescSvcInstOffsetSDS;
  while (iter < (kDescSvcInstOffsetSDS + kDescNumStateSession))
  {
    if(g_descSvcInst[iter].setStateIndex != kDescStateNoTransition)
    {
      if((DescStateGroup) (g_descStateGroupTransition[g_descSvcInst[iter].setStateIndex][1].stateSession) == sessionState)
      {
        return *DescGetSvcInstReqHeadExt(&g_descSvcHead[kDescSvcHeadOffsetSDS], iter);
      }
    }
    iter++;
  }

  /* Check if not found */
  DescAssertCommonAlways(kDescAssertInvalidStateParameterValue);

  return (DescMsgItem)0xFF;
}
#endif

#if defined(DESC_ENABLE_AUTO_STATES)
/*******************************************************************************
* NAME:              DescGetSessionTimings
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns the session specific P2/P2* timings
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescGetSessionTimings(DescStateGroup sessionState, vuint16* p2Time_1ms, vuint16* p2ExTime_10ms)
{
# if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
  vuint8_least    bitPos;
# endif

# if defined (DESC_ENABLE_DYNAMICAL_P2_TIMINGS)
  bitPos = DescGetSessionStateBitPosition(sessionState);
  /* Set P2 Time for the response */
  *p2Time_1ms = g_descP2TimingsTable[bitPos][kDescTimingRefP2];
  /* Set P2* Time for the response */
  *p2ExTime_10ms = g_descP2TimingsTable[bitPos][kDescTimingRefP2Star];
# else
  DESC_IGNORE_UNREF_PARAM(sessionState);
  /* Set P2 Time for the response */
  *p2Time_1ms = kDescTimeValueP2;
  /* Set P2* Time for the response */
  *p2ExTime_10ms = kDescTimeValueP2Star;
# endif
}
#endif

#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
/*******************************************************************************
* NAME:              DescStartRepeatedServiceCall
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Enables the multicall feature for the current service.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescStartRepeatedServiceCall(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescMainHandler mainHandler)
{
  /* Initialize the required function handler */
  g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE] = mainHandler;
}
#endif

/*******************************************************************************
* NAME:              DescSetNegResponse
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Sets the error.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescSetNegResponse(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST DescNegResCode errorCode)
{
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* Ignore setting an error if already set */
  if (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
  {
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = errorCode;
  }
}

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
/******************************************************************************
* NAME:              DescGetSvcInstHeadExtEntrySize
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
static vuint8_least DescGetSvcInstHeadExtEntrySize(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead)
{
  return (vuint8_least)((pSvcHead->isReqHeadExtEchoed != 0)?
                  (pSvcHead->reqHeadExLen):(pSvcHead->reqHeadExLen + pSvcHead->resHeadExLen));
}
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
/******************************************************************************
* NAME:              DescGetSvcInstResHeadExt
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
# if defined(C_COMP_NEC_78K0_AFCAN)
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# else
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstResHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# endif
{
  vuint8_least offset = 0;
  if(pSvcHead->isReqHeadExtEchoed == 0)
  {
    offset = pSvcHead->reqHeadExLen;
  }
  return (DescGetSvcInstReqHeadExt(pSvcHead, svcInstAbsRef) + offset);
}
#endif

#if defined (DESC_ENABLE_SUB_SVC_USAGE)
/******************************************************************************
* NAME:              DescGetSvcInstReqHeadExt
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
# if defined(C_COMP_NEC_78K0_AFCAN)
static V_MEMROM1 V_MEMROM2 DescMsgItem V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# else
static V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * DescGetSvcInstReqHeadExt(V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, DescSvcInstIndex svcInstAbsRef)
# endif
{
  vuint16_least offset = DescGetSvcInstHeadExtEntrySize(pSvcHead);
  offset *= (vuint16)(svcInstAbsRef - pSvcHead->svcInstFirstItem);

  return &g_descSvcInstHeadExt[pSvcHead->svcInstHeadExtFirstItem + offset];
}
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# if defined(DESC_ENABLE_BINARY_SVCINST_SEARCH)
/******************************************************************************
* NAME:              DescFindSvcInst
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Binary search for service instance.
*
*******************************************************************************/
static DescSvcInstIndex DescFindSvcInst(DescConstPtr reqHeadPtr, V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, vuint8_least* failedByteMask)
{
  V_MEMROM1 DescMsgItem V_MEMROM2 V_MEMROM3 * headEx;
  DescSvcInstIndex        loIdx;
  DescSvcInstIndex        hiIdx;
  DescSvcInstIndex        idx;
  DescSvcInstIndex        reqSvcInstHandle;
  vuint8_least            currColFound;
  DescBool                isEqual;

  loIdx = pSvcHead->svcInstFirstItem;
  /* Calculate search elements */
  hiIdx = (DescSvcInstIndex)((pSvcHead + 1)->svcInstFirstItem - 1);

  /* Mark subserviceInstance handle as invalid */
  reqSvcInstHandle = kDescInvalidSvcInstHandle;

  /* No error still found */
  *failedByteMask = 0;
  do
  {
    /* Examine one concrete serviceInstanceHeader */
    /* ------------------------------------------ */
    idx = (DescSvcInstIndex)(((vuint16)((vuint16)hiIdx + (vuint16)loIdx)) >> 1);

    headEx = DescGetSvcInstReqHeadExt(pSvcHead, idx);
    currColFound = 0;

    do
    {
      isEqual = V_BOOL_EXPR(reqHeadPtr[currColFound] == headEx[currColFound]);
      currColFound++;
    }
    while((currColFound < pSvcHead->reqHeadExLen)&&(isEqual != kDescFalse));

    if(isEqual != kDescFalse)
    {
      reqSvcInstHandle = idx;
      break;
    }
    else
    {
      /* Compensate post increment */
      currColFound--;
      /* Check for deepest error column */
      if(currColFound > *failedByteMask)
      {
        *failedByteMask = currColFound;
      }
      /* Determine which half shall be taken */
      if (reqHeadPtr[currColFound] < headEx[currColFound])
      {
        /* Avoid signed types */
        if(idx == 0)
        {
          break;
        }
        hiIdx = (DescSvcInstIndex)(idx - 1);
      }
      else
      {
        /* Message 'greater' than service instance: Use upper half of interval... */
        loIdx = (DescSvcInstIndex)(idx + 1);
      }
    }
  }
  while (loIdx <= hiIdx);
  /* Use 0x02, to skip the SID bit */
  *failedByteMask = (vuint8)(0x02 << *failedByteMask);
  /* return the search result 
   * place the error column number in the last 3 bits */
  return reqSvcInstHandle;
}
# endif
#endif

#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# if defined(DESC_ENABLE_LINEAR_SVCINST_SEARCH)
/******************************************************************************
* NAME:              DescFindSvcInst
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Linear search for service instance.
*
*******************************************************************************/
static DescSvcInstIndex DescFindSvcInst(DescConstPtr reqHeadPtr, V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * pSvcHead, vuint8_least* failedByteMask)
{
  DescSvcInstHeadExtIndex iter;
  DescSvcInstIndex        reqSvcInstHandle;
  DescSvcInstIndex        offset;
  vuint8_least            currColFound;
  vuint8_least            incStep;
  DescBool                isEqual;


  incStep = DescGetSvcInstHeadExtEntrySize(pSvcHead);

  /* Mark subserviceInstance handle as invalid */
  reqSvcInstHandle = kDescInvalidSvcInstHandle;
  /* No error still found */
  *failedByteMask = 0;
  offset = 0;

  for(iter = pSvcHead->svcInstHeadExtFirstItem;
      iter < (pSvcHead + 1)->svcInstHeadExtFirstItem;
      iter+= incStep)
  {
    currColFound = 0;
    do
    {
      isEqual = V_BOOL_EXPR(reqHeadPtr[currColFound] == g_descSvcInstHeadExt[iter + currColFound]);
      currColFound++;
    }
    while ((currColFound < pSvcHead->reqHeadExLen)&&(isEqual != kDescFalse));


    if(isEqual != kDescFalse)
    {
      reqSvcInstHandle = (DescSvcInstIndex)(offset + pSvcHead->svcInstFirstItem);
      break;
    }
    else
    {
      /* Compensate post increment */
      currColFound--;
      /* Check for deepest error column */
      if(currColFound > *failedByteMask)
      {
        /* Use 0x02, to skip the SID bit */
        *failedByteMask = currColFound;
      }
      /* Check if it makes sense to continue the search */
      if(reqHeadPtr[currColFound] < g_descSvcInstHeadExt[iter + currColFound])
      {
        /* That was it */
        break;
      }
    }
    /* Increment the reference */
    offset++;
  }

  /* Use 0x02, to skip the SID bit */
  *failedByteMask = (vuint8)(0x02 << *failedByteMask);
  return reqSvcInstHandle;
}
# endif
#endif

/******************************************************************************
* NAME:              DescFindSvc
*
* CALLED BY:         Dispatcher,FuncReception
* PRECONDITIONS:     
*
* DESCRIPTION:       Search a service ID.
*
*******************************************************************************/
static DescSvcHeadIndex DescFindSvc(DescMsgItem reqSvcId)
{
  DescSvcHeadIndex result  = kDescInvalidSvcHandle;
  vuint8_least     byteVar = 0;

  /* check if it is in the correct range (0x00-0x3f or 0x80-bf => bit2 must be 0) */
  /* check if it is not bigger that the maximum defined SID */
  if (((reqSvcId & kDescPosResIdOffset) == 0)&&
       (reqSvcId <= kDescMaxReqSid))
  {
    /* find in which response range is the request. */
    if ((reqSvcId & 0x80) != 0)
    {
      byteVar = kDescPosResIdOffset;
    }
    result = g_descSidMap[reqSvcId - byteVar];
  }
#if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
  if(result >= kDescInvalidSvcHandle)
  {
    /* Check if the application can recognize the SID */
    if(ApplDescCheckUserService(reqSvcId) == kDescOk)
    {
      /* The last service is the generic user one */
      result = (DescSvcHeadIndex)(kDescSvcHeadNumItems - 1);
    }
  }
#endif
  return result;
}

#if defined(DESC_ENABLE_GENERIC_USER_SERVICE_SUPPORT)
/******************************************************************************
* NAME:              DescGetServiceId
*
* CALLED BY:         Application user service
* PRECONDITIONS:     
*
* DESCRIPTION:       Returns the current request's SId.
*
*******************************************************************************/
DescMsgItem DESC_API_CALL_TYPE DescGetServiceId(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
# if defined(DESC_ENABLE_GENERIC_USER_POST_HANDLER_SUPPORT)
  /* Service Id can be reported only if not receive was active (post-handler are called in Idle mode) 
   * Removed since the condition is incomplete - if between the call of DescProcessingDOne and the PosHandler excution a new service will be requested,
   * it is still possible to evaluate the SID but the activity is set to ActiveRx.
   */
  /* DescAssertUser((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity != kDescContextActiveRx), kDescAssertNoSidCanBeReportedInIdleMode);*/
  /* Take from the backup */
  return g_descUserSIdBackup[DESC_CONTEXT_PARAM_VALUE];
# else
  /* Service Id can be reported only during request processing */
  DescAssertUser((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveProcess), kDescAssertNoSidCanBeReportedInIdleMode);
  /* Take from the current buffer */
  return g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr[0];
# endif
}
#endif

/*******************************************************************************
* NAME:              DescDispatcherIterInit
*
* CALLED BY:         DescInit
* PRECONDITIONS:     
*
* DESCRIPTION:       Initilizes the dispatcher subcomponent context specific data.
*
*******************************************************************************/
static void DescDispatcherIterInit(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
  /* Clear the multicall function pointer */
  g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE] = V_NULL;
#endif
#if (kDescNumContexts > 1)
  /* Init the context reference */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].iContext = DESC_CONTEXT_PARAM_VALUE;
#endif
  /* Delete the error registers */
  /* Done before the dispatcher will be called.
   * g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcNone;
   */
}

/*******************************************************************************
* NAME:              DescDispatcher
*
* CALLED BY:         DescTask
* PRECONDITIONS:     If there is at least one received request.
*
* DESCRIPTION:       Provides the kernel of the diagnostic
*
*******************************************************************************/
static void DescDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Code optimization */
  DescMsg msg;

  msg = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;

#if defined(DESC_ENABLE_GENERIC_USER_POST_HANDLER_SUPPORT)
  /* Store the SId for the case it is user SId */
  g_descUserSIdBackup[DESC_CONTEXT_PARAM_VALUE] = msg[0];
#endif
  /* Encapsulate the error handling for distinguishing if the PostHAndler has to
   * be called in error cases, handled by CANdesc 
   */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError = 0;
  /* Set default response on request type (phys - yes, func - no) */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = kDescDefaultResOnReq;
  /* Update the context phase */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveProcess;

  /*---------------------------------------------*/
  /*              Search service ID              */
  /*---------------------------------------------*/
  /* If service not supported */
  /* -------------------------*/
  g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE] = DescFindSvc(msg[0]);
  if(g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE] < kDescInvalidSvcHandle)
  {
    V_MEMROM1 DescSvcHead V_MEMROM2 V_MEMROM3 * refDescSvcHead;

    refDescSvcHead = &g_descSvcHead[g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE]];

    /* -----------------------------------------------*/
    /*      Set the default state for the response    */
    /* -----------------------------------------------*/
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = refDescSvcHead->resOnReq;

#if defined (DESC_ENABLE_ADDR_METHOD_CHECK_ON_SID)
    /*---------------------------------------------*/
    /*     Service ID addressing method check      */
    /*---------------------------------------------*/
    if ((refDescSvcHead->reqType &
         g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
#endif
    {
      /*------------------------------------*/
      /*     Service ID session check       */
      /*------------------------------------*/
      if ((refDescSvcHead->checkSessionState & g_descCurState.stateSession) != 0)
      {
        /*---------------------------------------------*/
        /*      The length of the request must be at   */
        /*    least the length of the requests header  */
        /*---------------------------------------------*/
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
# if defined (DESC_ENABLE_MIN_REQ_LEN_CHECK)
        if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen >= refDescSvcHead->minReqLength)
# else
        /* increment by 1 to include the SID byte also in the length of the header */
        if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen >= (refDescSvcHead->reqHeadExLen + 1))
# endif
#endif
        {
          vuint8_least supPosResBit;
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          vuint8_least svcInstFailedBytePosMask = 0;
#endif

          /* SID is no more of relevance - position to the first sub-service byte */
          msg++;
          /*---------------------------------------------*/
          /*   Suppress positive response bit calc       */
          /*---------------------------------------------*/
          supPosResBit = refDescSvcHead->suppPosRes;
          /* compose 0x80 or 0x00 depending on the CDD info */
          supPosResBit <<= 7;
          /* Extract the information to the application */
          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes = CANBITTYPE_CAST (((supPosResBit & *msg)!= 0)?0x01:0x00);
          /* Mask out the SPRMB */
          *msg &= (DescMsgItem)(~supPosResBit);/* compose 0x80 or 0x00 depending on the CDD info */

          /*---------------------------------------------*/
          /*              Search service instance        */
          /*---------------------------------------------*/
          /* if at least one instance is defined - check if it is valid */
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          if(refDescSvcHead->reqHeadExLen > 0)
          { /*lint -e{644}*/
            g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE] = (DescMemSvcInstIndex)DescFindSvcInst(msg, refDescSvcHead, &svcInstFailedBytePosMask);
          }
          else
#endif
          {
            g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE] = refDescSvcHead->svcInstFirstItem;
          }
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          if((g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]) < kDescInvalidSvcInstHandle)
#endif
          {
            V_MEMROM1 DescSvcInst V_MEMROM2 V_MEMROM3 * refDescSvcInst;

            refDescSvcInst = &g_descSvcInst[g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]];

            /* -----------------------------------------------*/
            /*      Set the default state for the response    */
            /* -----------------------------------------------*/
            /* Set service instance specific addressing information */
            g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = refDescSvcInst->msgAddInfo.resOnReq;

            /*---------------------------------------------*/
            /*  Service instance addressing method check   */
            /*---------------------------------------------*/
            if ((refDescSvcInst->msgAddInfo.reqType &
                 g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
            {
              /*---------------------------------------------*/
              /*      Service instance related checks        */
              /*---------------------------------------------*/
              /* Request length (top limit) check */

              /*---------------------------------------------*/
              /*      Service instance related checks        */
              /*---------------------------------------------*/
              /* Generated session check */
#if defined (DESC_ENABLE_SESSION_FORMAT_STATE_CHECK)
              if ((refDescSvcInst->checkState.stateSession & g_descCurState.stateSession) != 0)
#endif
              {
                /* Request length (top limit) check */
                /* If the table stored length is not zero - 
                check it for matching with the request length */
                if((refDescSvcInst->reqLen == 0) ||
                  (refDescSvcInst->reqLen == g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen))
                {
#if defined (DESC_ENABLE_AUTO_STATES)
                  /* Generated state checks */
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = DescCheckState(&(refDescSvcInst->checkState));

                  /* If any error was detected - go out */
                  if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
                  {
                    /* Release the PostHandler call feature */
                    g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError = 1;

                    /* OEM specific hook for pre-service execution */
                    DescOemOnValidService(DESC_CONTEXT_PARAM_VALUE);

                    /* If any error was detected - go out */
                    /* Do not use pre-processor encapsulation - since good compilers would optimize this check. */
                    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
                    {
#if defined (DESC_ENABLE_PREHANDLER_USAGE)
                      /*---------------------------------------------*/
                      /*    Application specific condition check     */
                      /*---------------------------------------------*/
                      /* Call the pre handler */
                      g_descPreHandlerTable[refDescSvcInst->preHandlerRef](DESC_CONTEXT_PARAM_ONLY);
                      /* If any error was detected - go out */
                      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
                      {
                        /* Prepare the application information */
                        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData    = (DescMsg)(msg + DescExtractReqExtHeadLen(refDescSvcHead->reqHeadExLen));
                        /* This is the extension of the response header (the header without the resposne SID), so for the complete length - add 1 */
                        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resData    = (DescMsg)(msg + DescExtractResExtHeadLen(refDescSvcHead->resHeadExLen));
                        /* The length contains up to now the whole request length, so just substract the header length */
                        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen -= (DescMsgLen)(DescExtractReqExtHeadLen(refDescSvcHead->reqHeadExLen) + 1);
                        /* Zero the response length - optimization for no data responses */
                        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = 0;

                        /*---------------------------------------------*/
                        /*      Call the main handler function         */
                        /*---------------------------------------------*/
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
                        /* If each service needs it - start always here to save ROM for the application */
                        _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, refDescSvcInst->mainHandler);
#endif
                        refDescSvcInst->mainHandler(&g_descMsgContext[DESC_CONTEXT_PARAM_VALUE]);

                        DescAssertContext((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].iContext == DESC_CONTEXT_PARAM_VALUE), kDescAssertContextIdWasModified);
                        DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts), kDescAssertInvalidContextId);
                        /* Skip the processing done call - let the application decide when */
                        return;
                      }
                    }/* else: error code already set - skip further processing */
                  }
#if defined (DESC_ENABLE_AUTO_STATES)
                  else
                  {
                    /* Correct the negative response code dependent on the sub-function instantiation */
                    if((g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcSubfunctionNotSupportedInActiveSession)
                      &&(refDescSvcHead->isSubFuncInstanced == 0))
                    {
                      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcParamIdNotSupportedInSession;
                    }

                    /* EXAMPLE: Additional activities may be necessary */
                    DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
                    DescOemOnInvalidEcuState(DESC_CONTEXT_PARAM_VALUE);
                  }
#endif
                }
                else
                {
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
                  /* EXAMPLE: Additional activities may be necessary */
                  DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
                  DescOemOnReqLengthNotMatched(DESC_CONTEXT_PARAM_VALUE);
                }
              }
#if defined (DESC_ENABLE_SESSION_FORMAT_STATE_CHECK)
              else
              {
                /* Correct the negative response code dependent on the sub-function instantiation */
                if(refDescSvcHead->isSubFuncInstanced == 0)
                {
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcParamIdNotSupportedInSession;
                }
                else
                {
                  g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcSubfunctionNotSupportedInActiveSession;
                }
                /* EXAMPLE: Additional activities may be necessary */
                DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
                DescOemOnInvalidEcuState(DESC_CONTEXT_PARAM_VALUE);
              }
#endif
            }
            else
            {
              g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
              /* EXAMPLE: Additional activities may be necessary */
              DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
              DescOemOnInvalidAddrMethod(DESC_CONTEXT_PARAM_VALUE);
            }
          }
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          else
          {
# if defined (DESC_ENABLE_SAME_NRC_ON_SUB_FUNC_AND_PARAM_ID)
            /* Send always NRC kDescNrcSubfunctionNotSupported */
# else
            /* Check which negative response shall be send (UnexpectedId/UnexpectedSubFunction)*/
            /*lint -e{644} (PClint can not know that this code will be reached only if the service is not found, and the variable is always initialized with 0)*/
            if((vuintx)(refDescSvcHead->reqHeadByteSpec & svcInstFailedBytePosMask) != (vuintx)0)
            {
              g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
            }
            else
# endif
            {
              g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcSubfunctionNotSupported;
            }
            /* Could be used in case when the instance is not found special init to be done*/
            DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
            DescOemOnSvcInstNotFound(DESC_CONTEXT_PARAM_VALUE);
          }
#endif
        }
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
        else
        {
          g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
          /* EXAMPLE: Additional activities may be necessary */
          DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
          DescOemOnReqLengthTooSmall(DESC_CONTEXT_PARAM_VALUE);
        }
#endif
      }
      else
      {
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcServiceNotSupportedInActiveSession;
        /* EXAMPLE: Additional activities may be necessary */
        DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
        DescOemOnInvalidSidSession(DESC_CONTEXT_PARAM_VALUE);
      }
    }
#if defined (DESC_ENABLE_ADDR_METHOD_CHECK_ON_SID)
    else
    {
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
      /* EXAMPLE: Additional activities may be necessary */
      DescOemOnInvalidRequest(DESC_CONTEXT_PARAM_VALUE);
      DescOemOnInvalidAddrMethod(DESC_CONTEXT_PARAM_VALUE);
    }
#endif
  }
  else
  {
    /* Could be used in case when the service is not found special init to be done*/
    DescOemOnSvcNotFound(DESC_CONTEXT_PARAM_VALUE);
#if defined(DESC_ENABLE_NEG_RES_ON_SID_WITH_SET_BIT6)
    /* Let always a response transmission */
#else
    if((msg[0] & 0x40) != 0)
    {
      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = 0;
    }
#endif
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcServiceNotSupported;
  }
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}

#if defined (DESC_ENABLE_PROCESSING_DONE_REDIRECTOR)
/*******************************************************************************
* NAME:              DescProcessingDone
*
* CALLED BY:         Dispatch,  any application function
* PRECONDITIONS: 
*
* DESCRIPTION:       Depending on the current situation, provides the right 
*                    action. 
*******************************************************************************/
void DESC_API_CALL_TYPE DescProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);

  switch(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode)
  {
    case kDescContextModeNormal:
      /* Finalize the request processing */
      DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# if defined (DESC_ENABLE_PID_LIST_MODE) || \
     defined (DESC_ENABLE_SIM_PID_LIST_MODE)
    case kDescContextModePidList:
      /* Current Pid list process finalization */
      DescPidProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# endif
# if defined (DESC_ENABLE_PERIODIC_MODE)
    case kDescContextModePeriodic:
      /* Current P-Pid list process finalization */
      DescSchedulerProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# endif
# if defined (DESC_ENABLE_ROUTINE_CONTROL_MODE)
    case kDescContextModeRoutineControl:
      /* The routine control service is ready - finalize it */
      DescRidProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# endif
# if defined (DESC_ENABLE_MEMORY_BY_ADDRESS_MODE)
    case kDescContextModeMemByAddr:
      /* The memory by address service is ready - finalize it */
      DescMemByAddrProcessingDone(DESC_CONTEXT_PARAM_ONLY);
      break;
# endif
    default:
      /* Unknown context mode */
      DescAssertCommonAlways(kDescAssertInvalidContextMode);
      break;
  }
}
#endif

/*******************************************************************************
* NAME:              DescFinalProcessingDone/DescProcessingDone
*
* CALLED BY:         DescProcessingDone/Appl(CANdesc)
* PRECONDITIONS: 
*
* DESCRIPTION:       Depending on the current situation, provides the right 
*                    action. 
*******************************************************************************/
#if defined (DESC_ENABLE_PROCESSING_DONE_REDIRECTOR)
static void DescFinalProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
#else
void DESC_API_CALL_TYPE DescProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
#endif
{
  DescMsg       msg;
  /* temporary variable to avoid multiple calculations */
  vuint8_least  resHeadLen;

  /* check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);
  /* check for correct time point of function call */
  DescAssertCommon((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveProcess),
                   kDescAssertProcessingDoneCallAfterResFlushing);
  /* Is ProcessingDone awaited */
  if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & kDescContextActiveProcess) != 0)
  {
#if defined (DESC_ENABLE_PROCESSING_DONE_REDIRECTOR)
    /* Set the CANdesc in a normal mode */
    g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;
#endif

    /* Specific actions which will be performed each time processing done with real response is called (timer management) */
    DescOemOnProcessingDone(DESC_CONTEXT_PARAM_VALUE);

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL) && \
    defined (DESC_ENABLE_RES_RINGBUFFER)
    /* If no ring buffer currently in use - stop multiple calls */
    if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0)
#endif
    {
      /* Deactivate the multicall mechanism */
      _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
    }

    /* Check if there will be a real response onto the bus */
    if ((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq &
         g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) !=0 )
    {
      /* Init with the current buffer location */
      msg = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;
      /* if there was an error detection - make negative response */
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
      {
        /*---------------------------------------------*/
        /*          Negative response section          */
        /*---------------------------------------------*/
        if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType & kDescFuncReq) != 0)
        {
#if defined (DESC_ENABLE_ALL_RES_AFTER_RCRRP)
          if(g_descRcrrpSent[DESC_CONTEXT_PARAM_VALUE] == kDescFalse)
#endif
          {
            /* In case of secured transmission - it is not possible to enter here!!! */
            switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
            {
              case 0x11:/* fall through */
              case 0x12:/* fall through */
              case 0x31:/* fall through */
              DESC_OEM_SUPPRESSED_FUNC_NRC
                /* fall through */
                /* Simulate success confirmation */
                DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
                return;/* Leave the function */
              default:break;/* Send negative response onto the comm bus */
            }
          }

#if defined (DESC_ENABLE_OBDII_NR_CONFORMANCE)
          /* Functional OBD requests (Sid =[0x00,...,0x0F]) */
          if(msg[0] < 0x10)
          {
            /* ...may support only NRCs: $21, $22 and $78 */
            switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
            {
              case 0x21:/* Fall through */
              case 0x22:/* Fall through */
              case 0x78:/* Fall through */
                /* These are allowed - continue processing */
                break;
              default:
                /* Simulate success confirmation */
                DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
                return;
            }
          }
#endif
        }

        /* Format and send negative response */
        msg[1] = msg[0]; /* Copy the SID */
        msg[0] = kDescNegResSId;/* Place 0x7F ...*/
        msg[2] = g_descNegResCode[DESC_CONTEXT_PARAM_VALUE];/*... and the current error code*/
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = kDescNegResLen;
      }
      else
      {
        /*---------------------------------------------*/
        /*          Positive response section          */
        /*---------------------------------------------*/
#if defined (DESC_ENABLE_POS_RES_ON_SET_SPRMIB)
        /* Do not consider the bit information - send always positive response */
#else
        /* Check if positive response shall be sent */
        if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes == 0)
#endif
        {
          /* Create response SID */
          msg[0] += kDescPosResIdOffset;
          msg++;
          /* Fill header of response */
          DescAssertCommon((g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE] < kDescSvcHeadNumItems),kDescAssertSvcTableIndexOutOfRange);
          /* optimize the loop - casting because it is sure that the header length is far below 254 bytes */
          /* This is the extension of the response header (the header without the resposne SID), so for the complete length - add 1 */
          resHeadLen = DescExtractResExtHeadLen((vuintx)(g_descSvcHead[g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE]].resHeadExLen));
#if defined(DESC_ENABLE_SUB_SVC_USAGE)
          DescMsgCopyRomToFarRam(msg,
                                 DescGetSvcInstResHeadExt(&g_descSvcHead[g_descCurReqSvc[DESC_CONTEXT_PARAM_VALUE]],
                                                           g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]),
                                 (vuint16)resHeadLen);
#endif
          /* Now consider the SID too */
          resHeadLen++;
          /* Making the total length of the response message 
          * (header + data) This macro is an optimization for adding a value: (X+=Y)*/
          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += (DescMsgLen)resHeadLen;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
          /*Set the write pointer for the ring buffer manager (resHeadLen + SIdByte) */
          g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex =    (DescMsgLen)resHeadLen;
          /* Protocol data are the response head data */
          g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen = (DescBitType)resHeadLen;
#endif
        }
#if defined (DESC_ENABLE_POS_RES_ON_SET_SPRMIB)
        /* Do not consider the bit information - send always positive response */
#else
        else
        {
          /* Simulate success confirmation */
          DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
          return;
        }
#endif
      }

#if defined (DESC_ENABLE_RES_RINGBUFFER)
      /* Mark that from now on a single response will be sent */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveProcessEnd;
      /* Set it for the copyToCan function */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex = 0;
      /* Init RingBuffer controller */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten = 0;

      /* Set the write pointer in case of RingBuffer usage and leave this function */
      if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0)
#endif
      {
        /* Set ready for transmit */
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTxReady;
      }
    }
    else
    {
      /* Simulate success confirmation */
      DescDoPostProcessing(DESC_CONTEXT_PARAM_FIRST kDescUsdtNetworkOk);
    }
  }
}

/*******************************************************************************
* NAME:              DescDoPostProcessing
*
* CALLED BY:         DescConfirmation, DescProcessingDone
* PRECONDITIONS: 
*
* DESCRIPTION:       Provides finalizing actions
*                    In case of secured Transmission
*******************************************************************************/
static void DescDoPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST t_descUsdtNetResult status)
{
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);

  /* Copy the state for task processing */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].txState = status;

  /* Deactivate the RCR-RP timer here for those services without response */
  DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
  DescDeactivateLimiter(DESC_CONTEXT_PARAM_VALUE);
  /* Activate the post processing */
  g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActivePostProcess;

  /* Predefined function */
  DescOemOnConfirmation(DESC_CONTEXT_PARAM_VALUE, status);

  /* Stop calling the application if set */
  _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
  /* Release context for next requests */
  DescReleaseContext(DESC_CONTEXT_PARAM_ONLY);
}

/*******************************************************************************
* NAME:              DescInitPowerOn
*
* CALLED BY:         Application
* PRECONDITIONS:     On system boot.
*
* DESCRIPTION:       Performs time consuming init/checks of the diag module.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescInitPowerOn(DescInitParam initParam)
{
  /******************************
  Subcomponent once InitPowerOn
  *******************************/
  DescSubcompOnceInitPowerOnDebug();
  DescSubcompOnceInitPowerOnNetwork();
  DescSubcompOnceInitPowerOnTiming();
  DescSubcompOnceInitPowerOnState();
  DescSubcompOnceInitPowerOnDispatcher();
  DescSubcompOnceInitPowerOnController();
  DescSubcompOnceInitPowerOnProcessor();
  DescSubcompOnceInitPowerOnFaultMemory();
  DescSubcompOnceInitPowerOnScheduled();
  DescSubcompOnceInitPowerOnSecurityAccess();
  DescSubcompOnceInitPowerOnPidManager();
  DescSubcompOnceInitPowerOnRidManager();
  DescSubcompOnceInitPowerOnPidListProcessor();
  DescSubcompOnceInitPowerOnDynDefinePid();
  DescSubcompOnceInitPowerOnDynDefineDpid();
  DescSubcompOnceInitPowerOnRoeProcessor();

  /* Generated function - DescInit must be here called because of init parameters */
  DescOemOnPowerOnInit(initParam);
  DescInit(initParam);
}

/*******************************************************************************
* NAME:              DescInit
*
* CALLED BY:         any application function, DescInitPowerOn
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs init of the diag module.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescInit(DescInitParam initParam)
{

  DESC_CONTEXT_PARAM_DEF_LOCAL

  /* Parameter may not be used - use dummy assignemt if necessary */
  DESC_IGNORE_UNREF_PARAM(initParam);

  /************************
  Subcomponent once init
  ************************/
  DescSubcompOnceInitDebug();
  DescSubcompOnceInitNetwork();
  DescSubcompOnceInitTiming();
  DescSubcompOnceInitState();
  DescSubcompOnceInitDispatcher();
  DescSubcompOnceInitController();
  DescSubcompOnceInitProcessor();
  DescSubcompOnceInitFaultMemory();
  DescSubcompOnceInitScheduled();
  DescSubcompOnceInitSecurityAccess();
  DescSubcompOnceInitPidManager();
  DescSubcompOnceInitRidManager();
  DescSubcompOnceInitPidListProcessor();
  DescSubcompOnceInitDynDefinePid();
  DescSubcompOnceInitDynDefineDpid();
  DescSubcompOnceInitRoeProcessor();

#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_VALUE = kDescNumContexts;
  while(DESC_CONTEXT_PARAM_VALUE != 0)
  {
    DESC_CONTEXT_PARAM_ONLY--;
#endif
    /************************
    Subcomponent context init
    ************************/
    DescSubcompIterInitDebug(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitNetwork(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitTiming(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitState(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitDispatcher(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitController(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitProcessor(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitFaultMemory(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitScheduled(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitSecurityAccess(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitPidManager(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitRidManager(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitPidListProcessor(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitDynDefinePid(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitDynDefineDpid(DESC_CONTEXT_PARAM_VALUE);
    DescSubcompIterInitRoeProcessor(DESC_CONTEXT_PARAM_VALUE);
#if(kDescNumContexts > 1)
  }
#endif
  /* Customized function */
  DescOemOnInit(initParam);
}

/*******************************************************************************
* NAME:              DescTimerTask
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescTimerTask(void)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL

  /* Check if desc is globally in idle mode */
#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_VALUE = kDescNumContexts;
  while(DESC_CONTEXT_PARAM_VALUE != 0)
  {
    DESC_CONTEXT_PARAM_ONLY--;
#endif
    /* RCR-RP only during processing (pprocessingEnd but not during transmission) */
    if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & (kDescContextActiveProcess|kDescContextActiveProcessEnd)) != 0)
    {
      DescResponseTimeoutTask(DESC_CONTEXT_PARAM_ONLY);
    }
#if(kDescNumContexts > 1)
  }
#endif

#if defined (DESC_ENABLE_DESCICN_SUPPORT)
  if(DescIsNoExtConnectionActive())
#else
  if(DescIsNoConnectionActive())
#endif
  {
#if defined (DESC_ENABLE_AUTO_STATES)
    /* ----------------*/
    /* Tester Timeout  */
    /* ----------------*/
    if(g_descS1Timer != 0)
    {
      if(g_descDoReloadS1Timer == kDescTrue)
      {
        /* This will clear the flag. No data loss possible, since the flag can be only set 
         * in interrupt, and only here will be cleared.
         */
        g_descDoReloadS1Timer = kDescFalse;
        DescReloadS1Timer();
      }
      /* Decrement timer */
      g_descS1Timer--;
      /* Check for timeout */
      if(g_descS1Timer == 0)
      {
        /* Simulate the same behavior as it would be done by requesting
         * default session 
         */
# if (kDescStateGroupNumTransition > 0)
        /* Patch the setstate function to simulate real request */
        DescSetState(kDescDefaultSessionSvcInstEntry);
# endif
# if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
        DescNpmSetSleepInd();
# endif
        /* Special handling in case of S1 timeout */
        DescOemOnS1Timeout();
      }
    }
    else
#endif
    {
#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
      DescOemNpmTimer();
#endif
      /* OEM specific timer during diag idle & default session) */
      DescOemDescIdleTimer();
    }
  }

#if defined(kDescSecureTimer) && defined(DESC_ENABLE_SECURITY_ACCESS)
# if (kDescSecureTimer != 0)
  DescSecurityAccessTimer();
# endif
#endif

  /* Custom timers */
  DescOemTaskTimer();
#if defined(DESC_ENABLE_PERIODIC_MODE)
  /* In case of periodic PIDs process them here */
  DescSchedulerTimerTask();
#endif
  /* Call the DescNet  tasks */
  DescUudtNetTimerTask();
  DescUsdtNetAbsTimerTask();
}

/*******************************************************************************
* NAME:              DescResponseTimeoutTask
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
static void DescResponseTimeoutTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
#if defined (DESC_ENABLE_RES_PENDING_TIME_LIMIT)
  /* --------------------------------------------------------*/
  /* Response pending time limitation -----------------      */
  /* --------------------------------------------------------*/
  /* Attention: Reenable interrupt after comparision against zero to avoid test-and-set problem. */
  if(g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE] != 0)
  {
    g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE]--;
    if(g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE] == 0)
    {
# if defined (DESC_ENABLE_FORCE_RCR_RP)
      /* Reset this flag if set */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpIdle;
# endif
# if defined(DESC_ENABLE_RES_RINGBUFFER)
      if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0)
      {
        DescRingBufferCancel(DESC_CONTEXT_PARAM_ONLY);
      }
      else
# endif
      {
        /* Stop sending of further $78 error codes */
        DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
        /* further call of processing done is illegal */
# if defined(DESC_ENABLE_OEM_HANDLING_ON_RCRRP_LIMIT_EXPIRATION)
        /* Custom action */
        DescOemOnResPendingOvertime(DESC_CONTEXT_PARAM_VALUE);
# else
        DescInterruptDisable();
        /* Set no response - just finalize the request */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = 0;
        /* Set an error so no complicatet checks to be performed and no PostHandler to be called */
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = (DescNegResCode)(~kDescNrcNone);

        /* Close the case :) */
        DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
        DescInterruptRestore();
# endif
      }
      /* Notify the application about timeout */
      ApplDescResponsePendingOvertimed(DESC_CONTEXT_PARAM_ONLY);
      return;
    }
  }
#endif
  /* --------------------------------------------------------*/
  /* Response Timeout ---------------------------------------*/
  /* --------------------------------------------------------*/
  if(g_descT2Timer[DESC_CONTEXT_PARAM_VALUE] != 0)
  {
#if defined (DESC_ENABLE_FORCE_RCR_RP)
    /* Check if the application needs RCR-RP right now */
    if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState == kDescForcedRcrRpCharged)
    {
      /* Check if the TX channel is free */
      if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType == kDescUsdtResponseNone)
      {
# if defined (DESC_ENABLE_SCHEDULER_USDT_TRANSMITTER)
        /* Catch situation: ongoing USDT periodic response and parallel main response 
         * check if other context wants to send or scheduler is not on sending */
        if((DESC_CONTEXT_PARAM_VALUE != kDescPrimContext)
            ||((g_descInterruptContextCtrl[kDescSchedulerContext].activity & kDescContextActiveTx) == 0))
# endif
        {
          /* reserve the TX channel for single frame */
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType = kDescUsdtResponseNegativeApplRCR_RP;
          /* reset RCR-RP state */
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpIdle;

          /* Ignore the SPRMB value and send always positive response if at least one RCR-RP has been sent */
          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes = 0;

          DescTransmitRcrRp(DESC_CONTEXT_PARAM_WRAPPER_ONLY(DESC_CONTEXT_PARAM_VALUE));
        }
      }
      else
      { /* Force timeout */
        g_descT2Timer[DESC_CONTEXT_PARAM_VALUE] = 1;
      }
    }
    else
#endif
    {
      /* TimeoutT2 unequal to 0 means running */
      g_descT2Timer[DESC_CONTEXT_PARAM_VALUE]--;
      /*Timeout reached?*/
      if(g_descT2Timer[DESC_CONTEXT_PARAM_VALUE] == 0)
      {
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
        if(g_descRcrrpLimitCounter[DESC_CONTEXT_PARAM_VALUE] != 0)
#endif
        {
          /* Check for request with response required */
          if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq &
              g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
          {
            /* Ignore the SPRMB value and send always positive response if P2 time has expired */
            g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes = 0;
            /* Check if the TX channel is free */
            if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType == kDescUsdtResponseNone)
            {
#if defined (DESC_ENABLE_SCHEDULER_USDT_TRANSMITTER)
              /* Catch situation: ongoing USDT periodic response and parallel main response 
               * check if other context wants to send or scheduler is not on sending */
              if((DESC_CONTEXT_PARAM_VALUE != kDescPrimContext)
                  ||((g_descInterruptContextCtrl[kDescSchedulerContext].activity & kDescContextActiveTx) == 0))
#endif
              {
                /* reserve the TX channel for single frame */
                g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType = kDescUsdtResponseNegativeRCR_RP;

                DescTransmitRcrRp(DESC_CONTEXT_PARAM_WRAPPER_ONLY(DESC_CONTEXT_PARAM_VALUE));
              }
            }
            else
            {
              /* Retry again */
              g_descT2Timer[DESC_CONTEXT_PARAM_VALUE]++;
            }
          }
          else
          {
            /* Run into assertion to show during development that the application can not fulfill
             * the timing requirements for the tester.
             */
            DescAssertUserAlways(kDescAssertApplLackOfConfirmation);
          }
        }
#if defined (DESC_ENABLE_RES_PENDING_COUNT_LIMIT)
        else
        {
# if defined (DESC_ENABLE_FORCE_RCR_RP)
          /* Reset this flag if set */
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].forcedRcrRpState = kDescForcedRcrRpIdle;
# endif
# if defined(DESC_ENABLE_RES_RINGBUFFER)
          if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0)
          {
            DescRingBufferCancel(DESC_CONTEXT_PARAM_ONLY);
          }
          else
# endif
          {
# if defined(DESC_ENABLE_OEM_HANDLING_ON_RCRRP_LIMIT_EXPIRATION)
            /* Custom action */
            DescOemOnResPendingOverrun(DESC_CONTEXT_PARAM_VALUE);
# else
            DescInterruptDisable();
            /* Set no response - just finalize the request */
            g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = 0;
            /* Set an error so no complicatet checks to be performed and no PostHandler to be called */
            g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = (DescNegResCode)(~kDescNrcNone);

            /* Close the case :) */
            DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
            DescInterruptRestore();
# endif
          }
          /* Notify the application about timeout */
          ApplDescResponsePendingOverrun(DESC_CONTEXT_PARAM_ONLY);
        }
#endif
      }/* T2 timeout case */
    }/* T2 timer running check */
  }
}


/*******************************************************************************
* NAME:              DescTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescTask(void)
{
#if defined(DESC_ENABLE_HIPERFORMANCE_DYNDID_MODE)
  /* Do not call the state task again to avoid CPU overload - the do-while loop will do this job */
#else
  DescStateTask();
#endif
  DescTimerTask();
}


/*******************************************************************************
* NAME:              DescStateTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescStateTask(void)
{
  DESC_CONTEXT_PARAM_DEF_LOCAL

  /*Postprocess UUDT confirmation*/
  DescUudtNetStateTask();

  /*-------------------------*/
  /* Global tasks processing */
  /*-------------------------*/
#if defined(DESC_ENABLE_PERIODIC_MODE)
  DescSchedulerTask();
#endif
#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE)
  DescDynDidTask();
#endif
#if defined (DESC_ENABLE_ROE_SUPPORT)
  DescRoeStateTask();
#endif
  /*--------------------------*/
  /* Context tasks processing */
  /*--------------------------*/
#if(kDescNumContexts > 1)
  DESC_CONTEXT_PARAM_VALUE = kDescNumContexts;
  while(DESC_CONTEXT_PARAM_VALUE != 0)
  {
    DESC_CONTEXT_PARAM_ONLY--;
#endif
    /* Check pending post-processing */
    if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity != kDescContextIdle)
    {
      DescContextStateTask(DESC_CONTEXT_PARAM_ONLY);
    }
#if(kDescNumContexts > 1)
  }
#endif

  /*-------------------------*/
  /* Global tasks processing */
  /*-------------------------*/

#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  DescNpmProcessQueue();
#endif
  /* Call the DescNet  tasks */
  DescUudtNetStateTask();
  DescUsdtNetAbsStateTask();
}

/*******************************************************************************
* NAME:              DescContextStateTask
*
* CALLED BY:         any application function
* PRECONDITIONS:     
*
* DESCRIPTION:       Performs cyclic tasking for diagnostic purpouse.
*
*******************************************************************************/
static void DescContextStateTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /*------------------------*/
  /*  Post processing task  */
  /*------------------------*/
  if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & kDescContextActivePostProcess) != 0)
  {
    vuint8  postProcessState;

    DescInterruptDisable();
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity &= (DescContextActivity)(~kDescContextActivePostProcess);
    DescInterruptRestore();

    /* By default - ok */
    postProcessState = kDescPostHandlerStateOk;

    /* Check the status of the response */
    if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].txState != kDescUsdtNetworkOk)
    {
      /* Clear ok, set error type */
      postProcessState = kDescPostHandlerStateTxFailed;
    }

    /* Add type of the response */
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
    {
      /* Clear ok, set error type */
      postProcessState &= (vuint8)(~kDescPostHandlerStateOk);
      postProcessState |= kDescPostHandlerStateNegResSent;
    }

#if defined (DESC_ENABLE_RES_RINGBUFFER)
    /**********************
    * RingBuffer handling
    **********************/
    /* Ring buffer relevant states reset */
    DescRingBufferStateReset(DESC_CONTEXT_PARAM_ONLY);
#endif

    ApplDescGenericServiceConfirmation(postProcessState);
#if defined (DESC_ENABLE_POSTHANDLER_USAGE)
    /* Call the post handler only if application error was active */
    if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].isApplError != 0)
    {
      /* Call the post handler */
      g_descPostHandlerTable[g_descSvcInst[g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]].postHandlerRef](DESC_CONTEXT_PARAM_FIRST postProcessState);
    }
#endif

#if defined (DESC_ENABLE_AUTO_STATES) && (kDescStateGroupNumTransition > 0)
    /*----------------------------*/
    /*        Modify state        */
    /*----------------------------*/
    /* Called only in successfully finished 
     * request processing */
    if((postProcessState & kDescPostHandlerStateOk) != 0)
    {
      DescSetState(g_descCurReqSvcInst[DESC_CONTEXT_PARAM_VALUE]);
    }
#endif
  }

  /*-------------------------*/
  /*    Rx processing task   */
  /*-------------------------*/
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveRxEnd)
  {
    /* Switch to process state */
    g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveProcess;

#if defined (DESC_ENABLE_DESCICN_SUPPORT)
    /* Check if this instance is a internal request */
    if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqType != kDescUsdtNetReqTypeInternal)
#endif
    {
      /* transfer addressing information from infoPool into MsgContext */
      if (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqType == kDescUsdtNetReqTypeFunctional)
      {
        /* Specify that the current request was actually a functional one */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType = kDescFuncReq;
      }
      else
      {
        /* Set request addressing method */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType = kDescPhysReq;
      }
      /* Copy the SID for RCR-RP response. 
       * necessary for multi session diag to know which one will be sent
       */
      g_descRcrrpBuffer[DESC_CONTEXT_PARAM_VALUE][1] = *g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;

      /* Activate always the T2 timer. Once the timeout occurs, 
       * there will be decision about sending a response or not.
       */
      DescActivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
      DescActivateLimiter(DESC_CONTEXT_PARAM_VALUE);

#if defined(DESC_ENABLE_ALL_RES_AFTER_RCRRP)
      /*Reset Rcr-Rp Flag*/
      g_descRcrrpSent[DESC_CONTEXT_PARAM_VALUE] = kDescFalse;
#endif
    }
#if defined (DESC_ENABLE_DESCICN_SUPPORT)
    else
    {
      /* Set request addressing method always to simulate physical reception */
      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType = kDescPhysReq;
    }
#endif
    /* Stores the length */
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength;

    /* Clear the error code */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcNone;
    /* Process the dispatcher */
    DescDispatcher(DESC_CONTEXT_PARAM_ONLY);
  }

  /*------------------------------*/
  /*    Process processing task   */
  /*------------------------------*/
#if defined (DESC_ENABLE_MAINHANDLER_MULTICALL) || defined (DESC_ENABLE_PID_LIST_MODE)
  /*--------------------------------------*/
  /*    Repeated Main-Handler Call task   */
  /*--------------------------------------*/
  if((g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity & (kDescContextActiveProcess |
                                                                       kDescContextActiveTxReady |
                                                                       kDescContextActiveTx |
                                                                       kDescContextActiveProcessEnd)) != 0)
  {
    /*--------------------------------------*/
    /*    Repeated Main-Handler Call task   */
    /*--------------------------------------*/
# if defined (DESC_ENABLE_MAINHANDLER_MULTICALL)
    if(g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE] != V_NULL)
    {
#  if defined(DESC_ENABLE_PID_LIST_MODE)
      /* If list mode service - process using its context */
      if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode == kDescContextModePidList)
      {
        g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE](&g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE]);
      }
      else
#  endif
      {
        g_descRecallHandler[DESC_CONTEXT_PARAM_VALUE](&g_descMsgContext[DESC_CONTEXT_PARAM_VALUE]);
      }
    }
# endif
# if defined (DESC_ENABLE_PID_LIST_MODE)
    DescPidProcessorTask(DESC_CONTEXT_PARAM_ONLY);
# endif
  }
#endif

  /*-------------------------*/
  /*    Tx processing task   */
  /*-------------------------*/
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveTxReady)
  {
    /* Check if the TX channel is free */
#if defined (DESC_ENABLE_SCHEDULER_USDT_TRANSMITTER)
    /* Catch situation: ongoing USDT periodic response and parallel main response 
     * check if other context wants to send or scheduler is not on sending */
    if((DESC_CONTEXT_PARAM_VALUE != kDescPrimContext)
        ||((g_descInterruptContextCtrl[kDescSchedulerContext].activity & kDescContextActiveTx) == 0))
#endif
    {
      if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType == kDescUsdtResponseNone)
      {
        /* Deactivate the RCR-RP timer here:
         * - equivalent to stopping it into ProcessingDone
         * - reduces code complexity to distinguish the different use cases 
         */
        DescDeactivateT2Timer(DESC_CONTEXT_PARAM_VALUE);
        DescDeactivateLimiter(DESC_CONTEXT_PARAM_VALUE);

        /* Set the new state of CANdesc */
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTx;

        /* reserve the TX channel and set the confirmation type to be expected */
        g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength = g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
        if (g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive != 0)
        {
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType    = kDescUsdtResponseRingBuffer;
        }
        else
#endif
        {
          /* Check if the negative response code is set */
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resType    = (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)?kDescUsdtResponsePositive:kDescUsdtResponseNegative;
        }
#if defined (DESC_USDTNET_ENABLE_VECTOR_ISO_TP)
    /* Save code */
#else
        if (g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr == V_NULL)
        {
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = DescUsdtNetGetTransmissionPtr(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
          memcpy(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr,g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr,g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->dataLength);
        }
        else
#endif
        {
          g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->resDataPtr = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr;
        }
        DescUsdtNetAbsTransmitResponse(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr);
      }
    }
  }
}

/*  ********************************************************************************
 * Function name:DescOemControlDefault_Session
 * Description:Processes the session change request, parametrizing the common processing
 * function.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemControlDefault_Session(DescMsgContext* pMsgContext)
{
  DescOemPrepareSessionControl(pMsgContext, kDescStateSessionDefault);
}


/*  ********************************************************************************
 * Function name:DescOemControlProgramming_Session
 * Description:Processes the session change request, parametrizing the common processing
 * function.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemControlProgramming_Session(DescMsgContext* pMsgContext)
{
  DescOemPrepareSessionControl(pMsgContext, kDescStateSessionProgramming);
}


/*  ********************************************************************************
 * Function name:DescOemControlExtended_Diagnostic_Session
 * Description:Processes the session change request, parametrizing the common processing
 * function.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemControlExtended_Diagnostic_Session(DescMsgContext* pMsgContext)
{
  DescOemPrepareSessionControl(pMsgContext, kDescStateSessionExtended);
}


/*  ********************************************************************************
 * Function name:DescOemControlRemote_Access_Session
 * Description:Processes the session change request, parametrizing the common processing
 * function.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemControlRemote_Access_Session(DescMsgContext* pMsgContext)
{
  DescOemPrepareSessionControl(pMsgContext, kDescStateSessionRemote);
}


/*  ********************************************************************************
 * Function name:DescOemControlNxtr_Session
 * Description:Processes the session change request, parametrizing the common processing
 * function.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemControlNxtr_Session(DescMsgContext* pMsgContext)
{
  DescOemPrepareSessionControl(pMsgContext, kDescStateSessionNxtr);
}


/*  ********************************************************************************
 * Function name:DescOemControlEnableRxAndTx
 * Description:reception and transmission of messages shall be enabled for the specified
 * communicationType
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemControlEnableRxAndTx(DescMsgContext* pMsgContext)
{
  DescOemCommonCommCtrlProcess(DescMakeCommCtrlParam(kDescCommControlStateEnable, kDescCommControlStateEnable), pMsgContext);
}


/*  ********************************************************************************
 * Function name:DescOemControlEnableRxAndDisableTx
 * Description:reception of messages shall be enabled and the transmission shall be disabled for
 * the specified communicationType.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext:
 *       - Contains all request properties.
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescOemControlEnableRxAndDisableTx(DescMsgContext* pMsgContext)
{
  DescOemCommonCommCtrlProcess(DescMakeCommCtrlParam(kDescCommControlStateDisable, kDescCommControlStateEnable), pMsgContext);
}


/*  ********************************************************************************
 * Function name:DescGenSendTesterPresent
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid and sub-parameters are excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescReqTypePhys or kDescReqTypeFunc).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 * Particularitie(s) and limitation(s): none
 ********************************************************************************  */
static void DESC_API_CALLBACK_TYPE DescGenSendTesterPresent(DescMsgContext* pMsgContext)
{
  DESC_IGNORE_UNREF_PARAM(pMsgContext);
  DescProcessingDone();
}


#if defined (DESC_ENABLE_ANY_PREHANDLER_USAGE)
/*******************************************************************************
* NAME:              DescDummyPreHandler
*
* CALLED BY:         DESCDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Used instead of V_NULL pointer
*
*******************************************************************************/
static void DESC_API_CALL_TYPE DescDummyPreHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;
}
#endif

#if defined (DESC_ENABLE_ANY_POSTHANDLER_USAGE)
/*******************************************************************************
* NAME:              DescDummyPostHandler
*
* CALLED BY:         DESCDispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Used instead of V_NULL pointer
*
*******************************************************************************/
static void DESC_API_CALL_TYPE DescDummyPostHandler(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;
  DESC_IGNORE_UNREF_PARAM(status);
}
#endif

/*******************************************************************************
* NAME:              DescSessionGetSuppressPosBit
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Will return the current value of the SPRMIB.
*
*******************************************************************************/
DescBool DESC_API_CALL_TYPE DescIsSuppressPosResBitSet(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  return V_BOOL_EXPR(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.suppPosRes != 0);
}

#if defined (DESC_ENABLE_DYN_COM_CTRL_PARAM)
/*******************************************************************************
* NAME:              DescOemCheckAndExtractCommTypeParam
*
* CALLED BY:         Default/CommunicationControl is activated
* PRECONDITIONS:     
*
* DESCRIPTION:       Checks if the msg type is APPL or NM.
*
*******************************************************************************/
static DescBool DescOemCheckAndExtractCommTypeParam(DescOemCommControlInfo * pCommControlInfo, DescMsgItem comType)
{
  DescBool returnValue = kDescFalse;

  if(((comType & 0x0F) <= kDescCommControlMsgTypeAll) &&
     ((comType & 0x0F) != 0))
  {
    /* Extract ComType parameter values */
    pCommControlInfo->msgTypes = (DescBitType)(comType & 0x03);
    pCommControlInfo->subNetNumber = (DescBitType)((comType & 0xF0) >> 4);

    returnValue = kDescTrue;
  }
  return returnValue;
}
#endif

/*******************************************************************************
* NAME:              DescEnableCommunication
*
* CALLED BY:         Application/DescInit/Session fall
* PRECONDITIONS:     
*
* DESCRIPTION:       Enables the communciation for all messages on all channels.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescEnableCommunication(void)
{
  /* Prepare for "TxEnable on ALL channels" */
  g_descCommControlInfo.subNetNumber   = kDescCommControlSubNetNumAll;
  g_descCommControlInfo.txPathState    = kDescCommControlStateEnable;
#if defined (DESC_ENABLE_RX_COMM_CONTROL)
  g_descCommControlInfo.rxPathState    = kDescCommControlStateEnable;
#endif
  g_descCommControlInfo.msgTypes       = kDescCommControlMsgTypeAll;

  /* Context parameter doesn't mean anything - use zero.*/
  DescOemPostCommonCommCtrlProcess(DESC_CONTEXT_PARAM_WRAPPER_FIRST(0) kDescPostHandlerStateOk);
}

/*******************************************************************************
* NAME:              DescOemCommonCommCtrlProcess
*
* CALLED BY:         DescOemCommCtrl_XXXableRxAndXXXableTx
* PRECONDITIONS:     
*
* DESCRIPTION:       Central communciation control processing.
*
*******************************************************************************/
static void DescOemCommonCommCtrlProcess(vuint8 reqInfo, DescMsgContext *pMsgContext)
{
  DescNegResCode errorCode = kDescNrcNone;

#if defined (DESC_ENABLE_DYN_COM_CTRL_PARAM)
  DescBool result;
#endif

  DESC_IGNORE_UNREF_PARAM(pMsgContext);

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  if(g_descIsOemMainHdlrAlreadyCalled == kDescFalse)
#endif
  {
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
    g_descIsOemMainHdlrAlreadyCalled = kDescTrue;
#endif
    /* Optimize the pointer operation (only the first 4 bits are relevant)*/
#if defined (DESC_ENABLE_DYN_COM_CTRL_PARAM)
    /* Check control parameter type */
    result = DescOemCheckAndExtractCommTypeParam(&g_descCommControlInfo, pMsgContext->reqData[0]);
    if(kDescFalse == result)
    {
      errorCode = kDescNrcRequestOutOfRange;
    }
#else /*No Dynamic Communication Control Parameter*/
# if defined(DESC_ENABLE_COM_CTRL_PARAM_CHECK)
    if(pMsgContext->reqData[0] != (vuint8)kDescComParam)
    {
      errorCode = kDescNrcRequestOutOfRange;
    }
    else
# endif
    {
      g_descCommControlInfo.msgTypes = (DescBitType)((kDescComParam)& 0x03);
      g_descCommControlInfo.subNetNumber = (DescBitType)(((kDescComParam) & 0xF0) >> 4);
    }
#endif
    if(kDescNrcNone == errorCode)
    {
      /* Set the TX communication state */
      g_descCommControlInfo.txPathState = reqInfo;
#if defined (DESC_ENABLE_RX_COMM_CONTROL)
      /* Set the TX communication state */
      g_descCommControlInfo.rxPathState = (DescBitType)(reqInfo >> 2);
#endif
#if defined(DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
      g_descCommControlInfo.reqCommChannel = g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_WRAPPER_INDEX(pMsgContext->iContext)].infoPoolPtr->busInfo.comChannel;
#endif

      /* make customized parameter interpretation */
      DescOemCustomizeComTypeParam(&g_descCommControlInfo);

#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
      /* Let the application decide which sub-network to which CAN channel is mapped */
#else
      if((g_descCommControlInfo.subNetNumber == kDescCommControlSubNetNumAll) ||
        (g_descCommControlInfo.subNetNumber == kDescCommControlSubNetNumRx))
      {
        /* Legal parameter values both for single and multi channel systems */
      }
      else
      {
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
        /* Assume 1:1 mapping subNetNumber:CAN (on multi channel system) */
        g_descCommControlInfo.commCtrlChannel = g_descCommControlInfo.subNetNumber;
        /* Convert subnetNum1 -> CAN0, etc.*/
        g_descCommControlInfo.commCtrlChannel--;
        /* If an invalid subnetwork (CAN channel) is requested - reject */
        if(g_descCommControlInfo.commCtrlChannel > (kDescNumCommChannels - 1))
        {
          errorCode = kDescNrcRequestOutOfRange;
        }
# else
        /* No sub-networks => no subnetwork number can be requested */
        errorCode = kDescNrcRequestOutOfRange;
# endif
      }
#endif

      /* Prepare the response length for positive response 
      * done by Dispatcher  (set to zero)
      */
    }
  }

  if(errorCode == kDescNrcNone)
  {
    /* Call the application for request data evaluation */
    ApplDescCheckCommCtrl(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) &g_descCommControlInfo);
  }
  else
  {
    /* Only out of range is used - use the constant */
    DescSetNegResponse(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) kDescNrcRequestOutOfRange);
    DescProcessingDone(DESC_CONTEXT_PARAM_WRAPPER_ONLY(pMsgContext->iContext));
  }
}

/*******************************************************************************
* NAME:              DescOemPostCommonCommCtrlProcess
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Processes the request after the positive response was sent.
*
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescOemPostCommonCommCtrlProcess(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
  DESC_COMM_CHANNEL_LOCAL_PARAM_DEF

  /* If you intend to use the context parameter don't forget the DescEnableCommunication API!!! */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  if((status & kDescPostHandlerStateOk) != 0)
  {
    switch(g_descCommControlInfo.subNetNumber)
    {
      case kDescCommControlSubNetNumAll:/* Disable all comm channels (CAN, LIN, etc.)*/
        DESC_COMM_CHANNEL_PARAM_VALUE_INIT;
        DESC_COMM_CHANNEL_LOOP
        {
          DESC_COMM_CHANNEL_PARAM_VALUE_DEC;
          DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_PARAM_ONLY);
        }
#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
        /* Manipulate application channels */
        ApplDescSetCommMode(&g_descCommControlInfo);
#endif
        break;
      case kDescCommControlSubNetNumRx:/* Disable only the request RX comm channel (CAN)*/
        DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_PARAM_WRAP_ONLY(g_descCommControlInfo.reqCommChannel));
        break;
      default:
        if(g_descCommControlInfo.commCtrlChannel != kDescCommControlCanChNone)
        {
          DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_PARAM_WRAP_ONLY(g_descCommControlInfo.commCtrlChannel));
        }
#if defined (DESC_ENABLE_COMM_CTRL_SUBNET_SUPPORT)
        else
        {
          /* Only application specific communication busses (no CAN) */
          ApplDescSetCommMode(&g_descCommControlInfo);
        }
#endif
    }

    if((g_descCommControlInfo.txPathState & kDescCommControlStateEnable) != 0)
    {
      /* Notify the application about the enabling communication */
      ApplDescOnCommunicationEnable();
    }
    else
    {
      /* Notify the application about the disabling communication */
      ApplDescOnCommunicationDisable();
    }
  }
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  /* Always clear the flag */
  g_descIsOemMainHdlrAlreadyCalled = kDescFalse;
#endif
}

/*******************************************************************************
* NAME:              DescCommCtrlManipulateCAN
*
* CALLED BY:         DescOemPostCommonCommCtrlProcess
* PRECONDITIONS:     
*
* DESCRIPTION:       Processes requested action.
*
*******************************************************************************/
static void DescCommCtrlManipulateCAN(DESC_COMM_CHANNEL_FORMAL_PARAM_DEF_ONLY)
{
  if((g_descCommControlInfo.txPathState & kDescCommControlStateEnable) != 0)
  {
    DescCommSetTxOnline(DESC_COMM_CHANNEL_PARAM_VALUE, g_descCommControlInfo.msgTypes);
  }
  else
  {
    DescCommSetTxOffline(DESC_COMM_CHANNEL_PARAM_VALUE, g_descCommControlInfo.msgTypes);
  }

#if defined (DESC_ENABLE_RX_COMM_CONTROL)
# if defined (DESC_ENABLE_MULTI_CHANNEL_SUPPORT)
  /* Reinit the comm channel in case of multi CAN */
  g_descCommControlInfo.commCtrlChannel = DESC_COMM_CHANNEL_PARAM_VALUE;
# endif
  /* let the application to manipulate the RX path */
  ApplDescSetCommModeOnRxPath(&g_descCommControlInfo);
#endif
}

/*******************************************************************************
* NAME:              DescOemPrepareSessionControl
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       Prepares the response for DiagnosticSessionControl.
*
*******************************************************************************/
static void DescOemPrepareSessionControl(DescMsgContext *pMsgContext, DescStateGroup targetSession)
{
#if defined (DESC_ENABLE_P2_TIME_REPORT)
  DescMsg   resData;
  vuint16   p2Time, p2ExTime;
#endif

  DESC_IGNORE_UNREF_PARAM(pMsgContext);/* Not always used - ignore per default! */

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  if(g_descIsOemMainHdlrAlreadyCalled == kDescFalse)
#endif
  {
#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
    g_descIsOemMainHdlrAlreadyCalled = kDescTrue;
#endif
#if defined (DESC_ENABLE_P2_TIME_REPORT)
    resData = pMsgContext->resData;
    /* Set the new response length */
    pMsgContext->resDataLen = 4;

    DescGetSessionTimings(targetSession, &p2Time, &p2ExTime);
    /* Set P2 Time for the response */
    resData[0] = DescGetHiByte(p2Time);
    resData[1] = DescGetLoByte(p2Time);
    /* Set P2* Time for the response */
    resData[2] = DescGetHiByte(p2ExTime);
    resData[3] = DescGetLoByte(p2ExTime);
#endif
#if defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
    /* Store the CAN channel here, since there during the session transition there can be another request */
    DescSetNpmOnCanChannelActive(pMsgContext->busInfo.comChannel, g_descCanChannelMapQueue);
#endif
  }

  /* Ask the application for permission to accept the session transition */
  ApplDescCheckSessionTransition(DESC_CONTEXT_PARAM_WRAPPER_FIRST(pMsgContext->iContext) targetSession, g_descCurState.stateSession);
}

#if defined (DESC_ENABLE_COMMON_OEM_POST_HANDLER)
/*******************************************************************************
* NAME:              DescOemCommonSessionPostProcessing
*
* CALLED BY:         Dispatcher
* PRECONDITIONS:     
*
* DESCRIPTION:       Common DiagnosticSessionControl session post handler.
*                    Workaround for session self-transitioning.
*
*******************************************************************************/
static void DescOemCommonSessionPostProcessing(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status, DescStateGroup newSession)
{
  /* Avoid warnings */
  DESC_CONTEXT_PARAM_DUMMY_USE;

  DESC_IGNORE_UNREF_PARAM(status);
  DESC_IGNORE_UNREF_PARAM(newSession);
# if defined (DESC_ENABLE_SESSION_SELFTRANSITION_SIM) || \
     defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  /* If ok ( no negative response, no transmission failure) */
  if((status & kDescPostHandlerStateOk) != 0)
  {
#  if defined (DESC_ENABLE_SESSION_SELFTRANSITION_SIM)
    /* Simulate session self-transition into default one */
    if((((DescStateGroup)g_descCurState.stateSession) & newSession) != 0)
    {
      DescSetStateSession(newSession);
    }
#  endif
  }
#  if defined (DESC_ENABLE_NODE_POWER_CONTROL) && !defined (DESC_ENABLE_DEFAULT_SESSION_SLEEP_PREVENTION)
  else
  {
    /* Reset the queue if error */
    g_descCanChannelMapQueue = 0;
  }
#  endif
# endif
}
#endif

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
/*******************************************************************************
* NAME:              DescSessionTransitionChecked
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Session transition check finished.
*
*******************************************************************************/
void DESC_API_CALL_TYPE DescSessionTransitionChecked(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* Clear always the flag */
  g_descIsOemMainHdlrAlreadyCalled = kDescFalse;
  DescProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}
#endif

#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || \
    defined(DESC_ENABLE_PID_LIST_MODE)        || \
    defined(DESC_ENABLE_DYN_DEFINED_DPID_MODE)
/*******************************************************************************
* NAME:              DescPmGetPidResponseLen
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescMsgLen DescPmGetPidResponseLen(DescPidInstIndex pidHandle)
{
  DescMsgLen result;

  result = DescPmClientGetResLength(pidHandle);

  /* If client didn't recognize it as own DID */
  if(result == 0)
  {
    result = g_descPIDInfo[pidHandle].resDataLen;
  }

  return result;
}
#endif

/*******************************************************************************
* NAME:              DescAnalysePid
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
* 
*******************************************************************************/
static DescPidAnalyseFailureReason DescPmAnalysePid(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST V_MEMROM1 DescPidTinyInfo V_MEMROM2 V_MEMROM3 * pRefTinyInfo)
{
  DescPidAnalyseFailureReason reason = pmAnalyseReasonOther;
  /*---------------------------------------------*/
  /*     Service ID addressing method check      */
  /*---------------------------------------------*/
  if ((pRefTinyInfo->msgAddInfo.reqType &
       g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType) != 0)
  {
#if defined (DESC_ENABLE_AUTO_STATES)
    /* Generated state checks */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = DescCheckState(&(pRefTinyInfo->checkState));
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
#endif
    {
#if defined (DESC_ENABLE_PID_PREHANDLER_USAGE)
      /*---------------------------------------------*/
      /*    Application specific condition check     */
      /*---------------------------------------------*/
      /* Call the pre handler */
      g_descPreHandlerTable[pRefTinyInfo->preHandlerRef](DESC_CONTEXT_PARAM_ONLY);
#endif
    }
#if defined (DESC_ENABLE_AUTO_STATES)
    else
    {
      /* Correct the negative response code dependent on the sub-function availability */
# if defined (DESC_ENABLE_PROTOCOL_KWP)
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcServiceNotSupportedInActiveMode)
# else
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcSubfunctionNotSupportedInActiveSession)
# endif
      {
        reason = pmAnalyseReasonSession;
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcParamIdNotSupportedInSession;
      }

      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] ==  kDescOemNrcParamIdNotSupportedInSecurityState)
      {
        reason = pmAnalyseReasonSecurityState;
      }
    }
#endif
  }
  else
  {
    /* EXAMPLE: Additional activities may be necessary */
    /*DescOemOnInvalidAddrMethod(DESC_CONTEXT_PARAM_ONLY);*/
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcInvalidAddrMethod;
  }
  return reason;
}

#if defined(DESC_ENABLE_DYN_DEFINED_DID_MODE) || defined(DESC_ENABLE_PERIODIC_MODE)
/******************************************************************************
* NAME:              DescPmGetPidClientHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static DescPidInstIndex DescPmGetPidClientHandle(DescPidInstIndex pidInfoHandle, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable)
{
  DescPidInstIndex result;
  DescPidInstIndex iter;

  result = kDescInvalidPidHandle;
  iter = topOfTable;
  while(iter != 0)
  {
    iter--;
    if(pClientInfoTbl[iter].pidHandle == pidInfoHandle)
    {
      result = iter;
      /* Break */
      iter = 0;
    }
  }

  return result;
}
#endif

/******************************************************************************
* NAME:              DescPmGetAvailablePidHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static DescPidInstIndex DescPmGetAvailablePidHandle(vuint16 pid)
{
  DescPidInstIndex result;

  result = DescPmGetPidPoolHandle(pid);
  result = DescPmClientCheckPid(result, pid);

  return result;
}

#if defined(DESC_ENABLE_PERIODIC_MODE)
/******************************************************************************
* NAME:              DescPmGetSupportedPidClientHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:    Returns a reference of the DID in the client specific info table
*
*******************************************************************************/
static DescPidInstIndex DescPmGetSupportedPidClientHandle(vuint16 pid, V_MEMROM1 DescPidClientInfo V_MEMROM2 V_MEMROM3 * pClientInfoTbl, DescPidInstIndex topOfTable)
{
  DescPidInstIndex result;
  result = DescPmGetAvailablePidHandle(pid);
  /* No check needed for invalidity since all the functions are protected by such checks */
  result = DescPmGetPidClientHandle(result, pClientInfoTbl, topOfTable);
  return result;
}
#endif

/******************************************************************************
* NAME:              DescPmGetPidPoolHandle
*
* CALLED BY:         
* PRECONDITIONS:     
*
* DESCRIPTION:       
*
*******************************************************************************/
static DescPidInstIndex DescPmGetPidPoolHandle(vuint16 pid)
{
  DescPidInstIndex  loIdx;
  DescPidInstIndex  hiIdx;
  DescPidInstIndex  idx;

  /* Init look-up */
  loIdx= 0;
  hiIdx= (DescPidInstIndex)(kDescNumPids - 1);

  do
  {
    /* Examine one concrete serviceInstanceHeader */
    /* ------------------------------------------ */
    idx = (DescPidInstIndex)(((vuint16)((vuint16)hiIdx + (vuint16)loIdx)) >> 1);

    /* Check for matching element */
    if(g_descPIDInfo[idx].reqPid == pid)
    {
#if defined (DESC_ENABLE_MULTI_CFG_SUPPORT)
      DescBool isSupported = ApplDescIsDataIdSupported(pid);
      if(isSupported == kDescFalse)
      {
        /* Nothing more to look for */
        break;
      }
      else
#endif
      {
#if defined (DESC_ENABLE_PID_SECURITY_FILTER)
        DescBool isAllowed = DescPmCheckPidSecurityAccess(&(g_descPIDInfo[idx].tinyInfo.checkState));
        if(isAllowed == kDescFalse)
        {
          /* Nothing more to look for */
          break;
        }
        else
#endif
        {
          /* Bingoooo :) */
          return idx;
        }
      }
    }
    /* Determine which half shall be taken */
    if (pid < g_descPIDInfo[idx].reqPid)
    {
      /* Avoid use of signed types */
      if(idx == 0)
      {
        break;
      }
      hiIdx = (DescPidInstIndex)(idx - 1);
    }
    else
    {
      /* Message 'greater' than service instance: Use upper half of interval... */
      loIdx = (DescPidInstIndex)(idx + 1);
    }
  }
  while (loIdx <= hiIdx);
  /* return the search result */
  return kDescInvalidPidHandle;
}

/*******************************************************************************
* NAME:              DescIterInitPidListProcessor
*
* CALLED BY:         CANdesc
* PRECONDITIONS:     
*
* DESCRIPTION:       Subcomponent initialization
*******************************************************************************/
static void DescIterInitPidListProcessor(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* These are initilized each time a request has been received */
  /*g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount = 0;
   *g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid = 0;
    g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidProcessed = 0;*/
  /* No PID to be processed */
  g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady = 0;

}

/*******************************************************************************
* NAME:              DescPidProcessingDone
*
* CALLED BY:         Application
* PRECONDITIONS:     
*
* DESCRIPTION:       Subcomponent processing done for a single PID 
* iContext for the main response is also the same for the DID 
*******************************************************************************/
static void DescPidProcessingDone(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  /* check for correct context */
  DescAssertContext((DESC_CONTEXT_PARAM_VALUE < kDescNumContexts),kDescAssertInvalidContextId);

#if defined (DESC_ENABLE_RES_RINGBUFFER)
  /********************************************************/
  /*        Mixed mode (Ring buffer || Linear)            */
  /********************************************************/
  /* The length will be composed in the PidDispatcher */
# if defined (DESC_ENABLE_DEBUG_USER )
  {
    DescMsgLen expectedPidLen;
#  if defined(DESC_ENABLE_UNIFIED_PID_MGR)
    /* Check for dynamic response length and multiple PID request */
    expectedPidLen = ApplDescGetPidDataLength(pidTypeReadOnce, g_descPidList[DESC_CONTEXT_PARAM_VALUE][g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid]);
    /* Add the PID itself */
    expectedPidLen+=2;
#  else
    expectedPidLen = DescPmGetPidResponseLen(g_descPidList[DESC_CONTEXT_PARAM_VALUE][g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid]);
#  endif

#  if defined (DESC_ENABLE_DYN_DID_RES_LENGTH)
    /* Check for non-dynamic length */
    if(expectedPidLen != 0)
#  endif
    {
      DescAssertUser(((g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen == expectedPidLen)||
                      (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)), kDescAssertPidResLenToCddDefNotMatched);
    }/* else: for dynamic length - no validation */
  }
# endif
  /* PID processing finished */
  g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidProcessed = 1;

# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  /* If no ring buffer currently in use 
   * OR
   * the transmission has been started AND current PID does not support ring-buffer
   * -> stop multiple calls 
   */
  if((g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0) ||
    ((g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferTxActive != 0) &&
     (g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferReactivated == 0)))
# endif
  {
    /* Deactivate the multicall mechanism */
    _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
  }

  /* Check if a response transmission has been started */
  if(g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity == kDescContextActiveProcess)
  {
    /* if there was an error detection - make negative response */
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
    {
      /* Go on with the response */
      DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
    }
    else
    {
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].infoPoolPtr->reqDataPtr[0] += kDescPosResIdOffset;
# if defined (DESC_ENABLE_DYN_DID_RES_LENGTH)
      /* Handling of DID with dynamic data length */
      if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen == 2)
      {
        /* If no response length set - the only PID is with dynamic length - use the application length */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
      }
# endif
      /* Set response length (add the Sid byte length) */
      g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += 1;
      /* No transmission started yet and RingBuffer active means: first RingBuffer PID */
      if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive == 0)
      {
        DescLinearResponseProcessing(DESC_CONTEXT_PARAM_ONLY);
      }
      /* Set ring buffer is under transmission */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferTxActive = 1;
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferActive = 1;

      /* Mark that from now on a single response will be sent */
      g_descInterruptContextCtrl[DESC_CONTEXT_PARAM_VALUE].activity = kDescContextActiveTxReady;
    }
  }
  else
  {
    /* Check if there is still a positive response */
    if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] != kDescNrcNone)
    {
      /* Force buffer underrun in the RingBufferCopy function */
      g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;
    }
    else
    {
      /* Check if this is a linear response */
      if(g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferReactivated == 0)
      {
        /* -- Linear -- */
        DescLinearResponseProcessing(DESC_CONTEXT_PARAM_ONLY);
      }
    }
  }
#else
  /********************************************************/
  /*                  Pure linear mode                    */
  /********************************************************/
    /* Stop always the current main-handler cyclic call */
  _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);

  /* Check positive or negative responses */
  if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
  {
    /* Calculate the common length up to now (including the PID previosely placed) */
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen + kDescReservedBytesForPid;

    /* Check BUS's buffer overflow */
    if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen > (DescMsgLen)(4095 - 1))
    {
      /* Accept only bus specific length */
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcResponseTooLong;
    }
    else
    {
      g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData += g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen;
      /* Process next PID */
      g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid++;

      if(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid <
         g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount)
      {
        /* No transmission up to now initiated, no ring buffer used - only linear buffer usage - take immediatelly the next PID */
        g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady = 1;
        /* Skip the final response activation */
        return;
      }
    }
  }
  /* Go on with the response */
  DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
#endif
}

/*******************************************************************************
* NAME:              DescPidProcessorTask
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Subcomponent task functionality. Polling mode.
* 
*******************************************************************************/
static void DescPidProcessorTask(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  DescPidInstIndex pidHandle;

  /* Active task only if PID list mode active */
  if(g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode == kDescContextModePidList)
  {
    /* Process next PID? */
    if(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady !=0)
    {
      g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady = 0;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
      /* Reset the temporary state (may be the next PID will use linear buffer who knows :o) ) */
      g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].isRingBufferReactivated = 0;
#endif
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
      /* Set post handler to be called */
      DescPidDoQueuePostHandlerAt(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid);
#endif
      /*---------------------*/
      /* Execute main handler*/
      /*---------------------*/
      /* Cache the reference */
      pidHandle = g_descPidList[DESC_CONTEXT_PARAM_VALUE][g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid];
      {
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
        /* Use the global service id $22 preferences */

        /* Copy the PID again */
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData = g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData;
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData[0] = DescGetHiByte(pidHandle);
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData[1] = DescGetLoByte(pidHandle);
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen = 2;
#else
        /* Copy the response information */
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = g_descPIDInfo[pidHandle].tinyInfo.msgAddInfo.resOnReq;
        /* Put the PID inside */
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData[0] = DescGetHiByte(g_descPIDInfo[pidHandle].reqPid);
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData[1] = DescGetLoByte(g_descPIDInfo[pidHandle].reqPid);
#endif
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData += kDescReservedBytesForPid;

        /* Copy this location into the original context to be able to use the free linear space calculation function */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resData = g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resData;

        /* Zero the response length */
        g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = 0;
#if defined (DESC_ENABLE_RES_RINGBUFFER)
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex += kDescReservedBytesForPid;
        /* Once started transmission - there are no data rather than the PID inside */
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten = 0;
        /* Initiate the none application data length - PID is 2 Byte or the first time 3Byte*/
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen += kDescReservedBytesForPid;
#endif

#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
        /* If each service needs it - start always here to save ROM for the application */
        _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, ApplDescReadDataByIdentifier);
# endif
        /* Call the only available main-handler for PID read: Sid $22's one.*/
        ApplDescReadDataByIdentifier(&g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE]);
#else
# if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
        /* If each service needs it - start always here to save ROM for the application */
        _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, g_descPIDInfo[pidHandle].mainHandler);
# endif
        /* Give the control to the application */
        g_descPIDInfo[pidHandle].mainHandler(&g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE]);
#endif
      }
    }
  }
}

/*******************************************************************************
* NAME:              DescPidDispatcher
*
* CALLED BY:         PidTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Processes a single PID with dispatcher functionality.
* 
*******************************************************************************/
static void DescPidDispatcher(DESC_CONTEXT_FORMAL_PARAM_DEF_ONLY)
{
  vuint8_least     iter;
  DescPidInstIndex pidHandle;

#if defined(DESC_ENABLE_PID_NRC_ALL_ON_WRONG_SESSION)
  vuint8_least     numPidsNotSuppInSession = 0;
#endif

  /* No data to be send to the application */
  g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen = 0;
  /* Init the counter */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen >>= 1; /* (length div 2), since the PID are 2 Byte */
  /* Already initialized in DescDispatcher */
  /* g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = 0; */

#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
  /* Clear the post-handler queue */
  iter = (vuint8_least)kDescNumPostHdlrQueueBytes;
  while(iter > 0)
  {
    iter--;
    g_descPidPostHdlrQueue[iter] = 0;
  }
#endif
  g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount = 0;
  /* Initialize the current PID ref to be processed */
  g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].curPid = 0;

  /* Req data len contains still the count of the PIDs */
  /* Process all PIDs until an error has been detected */
  iter = g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen;
  while((iter != 0)&&
        (g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone))
  {
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
    DescBool isSupported;
    pidHandle = DescMake16Bit(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[0],
                              g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[1]);
    isSupported = ApplDescIsPidSupported(pidTypeReadOnce, pidHandle);
#else
    /* Find PID (use main pool since each read-able PID is accessible by $22)*/
    pidHandle = DescPmGetAvailablePidHandle(DescMake16Bit(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[0],
                                                          g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData[1]));
#endif
    /* Decrement counter (already divided by 2) */
    iter--;
    /* Next PID prepare */
    g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqData +=2;

    /* If found */
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
    if(isSupported != kDescFalse)
#else
    if(pidHandle < kDescInvalidPidHandle)
#endif
    {
      /* Found - Jepiiii */
      DescMsgLen pidResLen;
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
      /* Check for dynamic response length and multiple PID request */
      pidResLen = ApplDescGetPidDataLength(pidTypeReadOnce, pidHandle);
#else
      /* Check for dynamic response length and multiple PID request */
      pidResLen = DescPmGetPidResponseLen(pidHandle);
#endif

#if defined (DESC_ENABLE_DYN_DID_RES_LENGTH)
      /* Only in single PID mode and if last PID in the list, a PID with dynamic length will be accepted */
      if((pidResLen != 0)||
# if defined (DESC_ENABLE_RES_RINGBUFFER)
        /* Ringbuffer: with dynamic length may be only single PID request */
        (g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen == 1)
# else
        /* Linear: with dynamic length may be only the last PID or single PID request */
        (iter == 0)
# endif
        )/* end if expr */
#endif
      {
#if !defined(DESC_ENABLE_UNIFIED_PID_MGR) &&  defined(DESC_ENABLE_SKIP_PID)
        DescPidAnalyseFailureReason analyseReason;
#endif
        g_descPidList[DESC_CONTEXT_PARAM_VALUE][g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount] = (DescMemPidInstIndex)pidHandle;
        /* Do dispatch the PID */
#if defined(DESC_ENABLE_UNIFIED_PID_MGR)
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = ApplDescVerifyPidAccessConditions(pidTypeReadOnce, pidHandle);
#else
# if defined(DESC_ENABLE_SKIP_PID)
        analyseReason = DescPmAnalysePid(DESC_CONTEXT_PARAM_FIRST &g_descPIDInfo[pidHandle].tinyInfo);
# else
        (void)DescPmAnalysePid(DESC_CONTEXT_PARAM_FIRST &g_descPIDInfo[pidHandle].tinyInfo);
# endif
#endif
        {
          /* if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone) -> PostHandler has to be called in any case */
#if defined(DESC_ENABLE_SKIP_PID)
# if defined(DESC_ENABLE_UNIFIED_PID_MGR)
          switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
# else
          switch(analyseReason)
# endif
#endif
          {
#if defined(DESC_ENABLE_SKIP_PID)
# if defined(DESC_ENABLE_UNIFIED_PID_MGR)
#  if defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION)
          case kDescOemNrcParamIdNotSupportedInSession:
          /*Fall Through*/
#  endif
#  if defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SECURITY_STATE)
          case kDescOemNrcParamIdNotSupportedInSecurityState:
          /*Fall Through*/
#  endif
# else
#  if defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SESSION)
          case pmAnalyseReasonSession:
          /*Fall Through*/
#  endif
#  if defined(DESC_ENABLE_SKIP_PID_ON_WRONG_SECURITY_STATE)
          case pmAnalyseReasonSecurityState:
#  endif
# endif
              /* Just treat it as "not supported" - undo the registered NRC */
            g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcNone;
# if defined(DESC_ENABLE_PID_NRC_ALL_ON_WRONG_SESSION)
            ++numPidsNotSuppInSession;
# endif
            break;
         default:
#endif /*DESC_ENABLE_SKIP_PID*/
#if defined (DESC_ENABLE_PID_PREHANDLER_USAGE) && \
    defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
            /* Check for non-dummy pre-handler */
            if(g_descPIDInfo[pidHandle].tinyInfo.preHandlerRef != 0)
            {
              /* Set post handler to be called */
              DescPidDoQueuePostHandlerAt(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount);
            }
#endif
            /* One PID found - set it here because it will be used also for the post handler call */
            g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount++;
            /* Add the current PID response dataLen to the total response */
            g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen += (DescMsgLen)(pidResLen + 2);

          } /*switch*/
        }
      }
#if defined (DESC_ENABLE_DYN_DID_RES_LENGTH)
      else
      {
        /* A PID with non constant length is illegally used */
        g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcRequestOutOfRange;
      }
#endif
    }
  }
  /* If not found - no more elements */
  if(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount == 0)
  {
#if defined(DESC_ENABLE_PID_NRC_ALL_ON_WRONG_SESSION)
    if(numPidsNotSuppInSession != 0)
    {
      /* Set the session NRC only if the supported PIDs were not supported in the session */
      DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescOemNrcParamIdNotSupportedInSession);
    }
    else
#endif
    {
      /* May be no PID found - negative response */
      /* Important : use the function call to avoid overwriting of the NRC if previously set */
      DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescNrcRequestOutOfRange);
    }
  }

  /* Check bus's buffer overflow */
  if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen > (DescMsgLen)(4095 - 1)
#if !defined (DESC_ENABLE_RES_RINGBUFFER)
    /* If linear buffer - check for overflow */
     || g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen > (DescMsgLen)(DescGetAvailBufferLenByMsgContext(&g_descMsgContext[DESC_CONTEXT_PARAM_VALUE]) - 1)
#endif
    )
  {
    /* Accept only bus specific length */
    /* Important : use the function call to avoid overwriting of the NRC if previously set */
    DescSetNegResponse(DESC_CONTEXT_PARAM_FIRST kDescOemNrcResponseTooLong);
  }
#if !defined (DESC_ENABLE_RES_RINGBUFFER)
  /* If linear buffer - build the total length iteractively (assume dynamic length signals) */
  g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].resDataLen = 0;
#endif
}

/*******************************************************************************
* NAME:              DescPostReadDataByIdentifier
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Post handler for PID list handling.
* 
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescPostReadDataByIdentifier(DESC_CONTEXT_FORMAL_PARAM_DEF_FIRST vuint8 status)
{
#if defined (DESC_ENABLE_PID_POSTHANDLER_USAGE)
  DescPidInstIndex localPidInfoRef;


  localPidInfoRef = 0;
  /* Merge the main response status with the applications */
  while(g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount != 0)
  {
    /* Check if the post handler may be called */
    if(DescPidIsPostHandlerQueuedAt(localPidInfoRef))
    {
      /* Call the post handler */
      g_descPostHandlerTable[g_descPIDInfo[g_descPidList[DESC_CONTEXT_PARAM_VALUE][localPidInfoRef]].postHandlerRef](DESC_CONTEXT_PARAM_FIRST status);
    }
    /* Decrement queued count */
    g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].pidCount--;
    /* Take the next post handler */
    localPidInfoRef++;
  }
#endif
#if defined (DESC_ENABLE_RES_RINGBUFFER)
  /* If no ring buffer active -> the transmission will start through DescFinalProcessingDone() which sets the context back to normal */
  /* Set the CANdesc in a normal mode */
  g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModeNormal;
#endif
  DESC_IGNORE_UNREF_PARAM(status);
#if (kDescNumContexts > 1)
  DESC_IGNORE_UNREF_PARAM(DESC_CONTEXT_PARAM_VALUE);
#endif
}

/*******************************************************************************
* NAME:              DescReadDataByIdentifier
*
* CALLED BY:         DescTask
* PRECONDITIONS:     
*
* DESCRIPTION:       Main handler for PID list handling.
* 
*******************************************************************************/
static void DESC_API_CALLBACK_TYPE DescReadDataByIdentifier(DescMsgContext *pMsgContext)
{
  /* Use iContext when necessary */
  DESC_CONTEXT_PARAM_DEF_LOCAL

#if (kDescNumContexts > 1)
  /* Use iContext as name to be able to use the DESC_CONTEXT_PARAM_VALUE macro */
  DESC_CONTEXT_PARAM_VALUE = pMsgContext->iContext;
#endif

#if defined (DESC_ENABLE_PERMANENT_MAINHANDLER_MULTICALL)
  /* Disable this multiple service call */
  _DescStartRepeatedServiceCall(DESC_CONTEXT_PARAM_VALUE, V_NULL);
#endif
  /* The length for this service shall be ZERO to allow the application (CANdesc) 
   * to check it */
  /* Check if at least one PID is available (at least 2 Byte) */
  /* Check if the length is multiple of 2, since each PID is 2 Byte.*/
  if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen > 1)&&
    ((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen & 0x01) == 0))
  {
    /* Also the capacity of the ECU shall not be exceeded */
    if((g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].reqDataLen >> 1) <= kDescNumMaxPidList)
    {
      /* Set the CANdesc in a PID List mode */
      g_descContextCtrl[DESC_CONTEXT_PARAM_VALUE].contextMode = kDescContextModePidList;
      /* Copy the original structure */
      g_descPidMsgContext[DESC_CONTEXT_PARAM_VALUE] = *pMsgContext;
      /* Dispatch all PID */
      DescPidDispatcher(DESC_CONTEXT_PARAM_ONLY);
      /* Check if any error was found */
      if(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] == kDescNrcNone)
      {
        /* Prepare for datat processing */
#if defined (DESC_ENABLE_RES_RINGBUFFER)
        /* Start from the begining */
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txReadIndex = 0;
        /* Write after the SID */
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].txWriteIndex = 1;
        /* Once started transmission - there are no data rather than the PID inside (will be written later) */
        /* g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].bytesWritten = 0;*/
        /* Initiate the none application data length - 1Byte SID*/
        g_descRingBufferCtrl[DESC_CONTEXT_PARAM_VALUE].protocolDataLen = 1;
        g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidProcessed = 0;
#endif
        /* Process the first PID 
        * stack utilization optimization */
        g_descPidProcessorState[DESC_CONTEXT_PARAM_VALUE].isPidReady = 1;
        return;
      }
    }
    else
    {
      /* Too many PIDs */
      g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescOemNrcTooManyPIDs;
    }
  }
  else
  {
    /* Invalid length */
    g_descNegResCode[DESC_CONTEXT_PARAM_VALUE] = kDescNrcInvalidFormat;
  }
#if defined (DESC_ENABLE_PROTOCOL_KWP)
  /* KWP shall not respond on failed functionally requested service $22 with NR $31 ($33 is mapped to $31)*/
  if(g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.reqType == kDescFuncReq)
  {
    switch(g_descNegResCode[DESC_CONTEXT_PARAM_VALUE])
    {
      case kDescNrcRequestOutOfRange:
        /* Fall through */
      case kDescNrcAccessDenied:
        /* Suppress response */
        g_descMsgContext[DESC_CONTEXT_PARAM_VALUE].msgAddInfo.resOnReq = 0;
        break;
      default:/* Normal processing */ break;
    }
  }
#endif
  /* Reaching this point means diagnostic error was found */
  DescFinalProcessingDone(DESC_CONTEXT_PARAM_ONLY);
}



