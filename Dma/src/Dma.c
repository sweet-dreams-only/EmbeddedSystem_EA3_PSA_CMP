/*****************************************************************************
* Copyright 2015 Nxtr 
* Nxtr Confidential
*
* Module File Name  : Dma.c
* Module Description: DMA Peripheral
* Product           : CBD
* Author            : Owen Tosh
*****************************************************************************
* Version Control:
* Date Created:      Tue Mar 11 12:00:00 2014
* %version:          4 %
* %derived_by:       nz63rn %
******************************************************************************
**********************************************************************************************************************
* Change History:
* Date      Rev      Author    Change Description                                                                CR#
* --------  -------  --------  --------------------------------------------------------------------------------- -----
* 04/08/14   1       OT        Initial version
* 04/29/14   2       OT        Enabled parity, updated data integrity scheme                                     11855
* 05/02/14   3       OT        Updated to FDD 52 v002 (removed slow SPI integrity check scheme)                  11871
* 01/31/15   4       KMC       Added test for Dma fail to exit reset fault per ES 52 v004                        CR12749 
*                              Added more restrictive MPU settings when only FLSTST use is configured
***********************************************************************************************************************/


#include "dma_regs.h"
#include "Dma.h"

#if (D_FASTSPIGROUPENABLED_CNT_ENUM == STD_ON) || \
	(D_FASTADCGROUPENABLED_CNT_ENUM == STD_ON) || \
	(D_SLOWADCGROUPENABLED_CNT_ENUM == STD_ON) || \
	(D_FASTPWMGROUPENABLED_CNT_ENUM == STD_ON)

#define DMA_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "MemMap.h" /* PRQA S 5087 */
volatile VAR(DMADataType_Str, DMA_VAR) DMAData_G_str;
#define DMA_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "MemMap.h" /* PRQA S 5087 */

#endif

#define DMA_START_SEC_VAR_CLEARED_BOOLEAN
#include "MemMap.h" /* PRQA S 5087 */
/* global variable required for output from Dma_Init function which runs before the RTE is started */
VAR(boolean, DMA_VAR) Dma_DmaRstFail_Cnt_G_lgc;
#define DMA_STOP_SEC_VAR_CLEARED_BOOLEAN
#include "MemMap.h" /* PRQA S 5087 */

/******************************************************************************
  * Name:        Dma_Init
  * Description: Initialization of the DMA peripheral
  * Inputs:      NONE    
  * Outputs:     NONE 
  * Usage Notes:  Called in ECU Startup; see integration manual 
  ****************************************************************************/
FUNC(void, DMA_CODE) Dma_Init(void)
{
	
	/*** DMA Core Configuration ***/
	
	/* DMA initialization - start  */
	
	/* check for DMA reset bit not cleared during reset */
	if (( DMACTRLREG->GCTRL & 1UL ) == 1UL)
	{
		/* Set DMA Reset Failed flag */
		Dma_DmaRstFail_Cnt_G_lgc = TRUE;
	}
	else
	{
		/* Clear DMA Reset Failed flag */
		Dma_DmaRstFail_Cnt_G_lgc = FALSE;

		/* Set Up Memory Protection */
		/* Note lower numbered regions take precedence (i.e region 0 takes precedence over 1 where they overlap) */
		
		/* If DMA used only for FlsTst, use most restrictive MPU settings */
		#if (D_DMAFLSTSTENABLED_CNT_ENUM == STD_ON) && \
		    (D_FASTSPIGROUPENABLED_CNT_ENUM == STD_OFF) && \
			(D_FASTADCGROUPENABLED_CNT_ENUM == STD_OFF) && \
			(D_SLOWADCGROUPENABLED_CNT_ENUM == STD_OFF) && \
			(D_FASTPWMGROUPENABLED_CNT_ENUM == STD_OFF)
		
			/* Provide write access to CRC PSA Register and expected CRC Register, which are contiguous memory */
			DMACTRLREG->DMAMPR0S =  (uint32)&(CRCCTRLREG->PSA_SIGREGL1); 					/* DMA MPU start address */
			DMACTRLREG->DMAMPR0E =  DMACTRLREG->DMAMPR0S + (uint32)((2U * D_DMACRCSIGWRITELEN_CNT_U16) - 1U);	/* DMA MPU end address for a 16 byte write covering the 2 required CRC regs */
	
			/* Provide no access to peripheral memory region to avoid side effects generated by reading registers */
			DMACTRLREG->DMAMPR1S =  0xF0800000UL;	/* DMA MPU start address */
			DMACTRLREG->DMAMPR1E =  0xFFFFFFFFUL;	/* DMA MPU end address */
	
			/* Provide read-only access to entire memory map */
			DMACTRLREG->DMAMPR2S =  0x00000000UL;	/* DMA MPU start address */
			DMACTRLREG->DMAMPR2E =  0xFFFFFFFFUL;	/* DMA MPU end address */
	
			/* Enable memory protection regions 0(write-only), 1(no access), 2(read-only).  Enable the interrupt on violation flags for these regions. */
			DMACTRLREG->DMAMPCTRL =
				(0ul << 28U) | /*INT3AB*/
				(0ul << 27U) | /*INT3ENA*/ /* not enabled */
				(0ul << 25U) | /*REG3AP*/
				(0ul << 24U) | /*REG3ENA*/ /* not enabled */
				(0ul << 20U) | /*INT2AB*/
				(1ul << 19U) | /*INT2ENA*/ /* enabled */
				(1ul << 17U) | /*REG2AP*/  /* read only */
				(1ul << 16U) | /*REG2ENA*/ /* enabled */
				(0ul << 12U) | /*INT1AB*/
				(1ul << 11U) | /*INT1ENA*/ /* enabled */
				(3ul << 9U) | /*REG1AP*/   /* no access */
				(1ul << 8U) | /*REG1ENA*/  /* enabled */
				(0ul << 4U) | /*INT0AB*/
				(1ul << 3U) | /*INT0ENA*/  /* enabled */
				(2ul << 1U) | /*REG0AP*/   /* write only */
				(1ul << 0U) ; /*REG0ENA*/  /* enabled */
		
		#else  /*DMA used for more than just FlsTst; set up MPU as needed */
		
			DMACTRLREG->DMAMPCTRL = (0ul)
		#if (D_FASTSPIGROUPENABLED_CNT_ENUM == STD_ON) || \
			(D_FASTADCGROUPENABLED_CNT_ENUM == STD_ON) || \
			(D_SLOWADCGROUPENABLED_CNT_ENUM == STD_ON) || \
			(D_FASTPWMGROUPENABLED_CNT_ENUM == STD_ON)
								  | (1ul)			/* Region 0 enable:		enabled */
		#endif
								  | (0ul << 1)		/* Region 0 access:		read/write */
								  | (1ul << 3)		/* Region 0 interrupt:	enabled */
		#if (D_DMAFLSTSTENABLED_CNT_ENUM == STD_ON) || \
			(D_FASTPWMGROUPENABLED_CNT_ENUM == STD_ON)
								  | (1ul << 8)		/* Region 1 enable:		enabled */
		#endif
								  | (0ul << 9)		/* Region 1 access:		read/write */
								  | (1ul << 11)		/* Region 1 interrupt:	enabled */
		#if (D_FASTSPIGROUPENABLED_CNT_ENUM == STD_ON) || \
			(D_FASTADCGROUPENABLED_CNT_ENUM == STD_ON) || \
			(D_SLOWADCGROUPENABLED_CNT_ENUM == STD_ON) || \
			(D_FASTPWMGROUPENABLED_CNT_ENUM == STD_ON)
								  | (1ul << 16)		/* Region 2 enable:		enabled */
		#endif
								  | (0ul << 17)		/* Region 2 access:		read/write */
								  | (1ul << 19)		/* Region 2 interrupt:	enabled */
								  | (1ul << 24)		/* Region 3 enable:		enabled */
								  | (3ul << 25)		/* Region 3 access:		no access */
								  | (1ul << 27);	/* Region 3 interrupt:	enabled */
			
			DMACTRLREG->DMAMPR0S = 0xFF0A0000ul;			/* Region 0 - peripherals */
			DMACTRLREG->DMAMPR0E = 0xFF473FFFul;
			DMACTRLREG->DMAMPR1S = 0xFCF78C00ul;			/* Region 1 - peripherals */
			DMACTRLREG->DMAMPR1E = 0xFE0001FFul;
		#if (D_FASTSPIGROUPENABLED_CNT_ENUM == STD_ON) || \
			(D_FASTADCGROUPENABLED_CNT_ENUM == STD_ON) || \
			(D_SLOWADCGROUPENABLED_CNT_ENUM == STD_ON) || \
			(D_FASTPWMGROUPENABLED_CNT_ENUM == STD_ON)
			DMACTRLREG->DMAMPR2S = (uint32)&DMAData_G_str;	/* Region 2 - RAM */
			DMACTRLREG->DMAMPR2E = (((uint32)&DMAData_G_str) + sizeof(DMAData_G_str)) - 1u;
		#endif
			DMACTRLREG->DMAMPR3S = 0x00200000ul;			/* Region 3 - everything but flash */
			DMACTRLREG->DMAMPR3E = 0xFFFFFFFFul;
			
		#endif 
		
			/* Enable Parity */
		#if (DMA_PARITY_ENABLE == STD_ON)
			DMACTRLREG->DMAPCR = 0x0Aul;	/* enable parity */
		#endif
			
			
			/* Enable DMA */
			DMACTRLREG->GCTRL = (3ul << 8)		/* Debug mode:	immediate halt */
							  | (1ul << 16);	/* DMA enable:	enabled */

	}	
}


/******************************************************************************
  * Name:        Dma_SlowADCGroupValidity
  * Description: Callback to check the slow ADC DMA data validity
  * Inputs:      NONE     
  * Outputs:     NONE 
  * Usage Notes:  See integration manual 
  ****************************************************************************/
FUNC(boolean, DMA_CODE) Dma_SlowADCGroupValidity(void)
{
	VAR(uint16, AUTOMATIC) i;
	VAR(boolean, AUTOMATIC) RetValue_Cnt_T_lgc;
	
	RetValue_Cnt_T_lgc = TRUE;
	
#if (D_SLOWADCGROUPENABLED_CNT_ENUM == STD_ON)
	for( i = 0u; i < D_NUMSLOWADCCHANNELS_CNT_U16; i++ )
	{
		if( DMAData_G_str.SlowADC_Cnt_u16[i] == 0xFFFFu )
		{
			RetValue_Cnt_T_lgc = FALSE;
			DMA_REPORTERRORSTATUS(NTC_Num_PerDiag_DMAFlt, 0x20u, NTC_STATUS_FAILED);
		}
	}
#endif
	
	return RetValue_Cnt_T_lgc;
}

/******************************************************************************
  * Name:        Dma_InvalidateSlowADCGroup
  * Description: callback to invalidate the slow ADC DMA data
  * Inputs:      NONE     
  * Outputs:     NONE 
  * Usage Notes:  See integration manual 
  ****************************************************************************/
FUNC(void, DMA_CODE) Dma_InvalidateSlowADCGroup(void)
{
	VAR(uint16, AUTOMATIC) i;
	
#if (D_SLOWADCGROUPENABLED_CNT_ENUM == STD_ON)
	for( i = 0u; i < D_NUMSLOWADCCHANNELS_CNT_U16; i++ )
	{
		DMAData_G_str.SlowADC_Cnt_u16[i] = 0xFFFFu;
	}
#endif
	
}

/******************************************************************************
  * Name:        Dma_SetupMtrCtrlGroups
  * Description: Perform DMA peripheral initialization for the motor control groups
  *              as configured.
  * Inputs:      NONE     
  * Outputs:     NONE 
  * Usage Notes:  Called from ECU Startup; see integration manual
  ****************************************************************************/
FUNC(void, DMA_CODE) Dma_SetupMtrCtrlGroups(void)
{
#if (D_FASTSPIGROUPENABLED_CNT_ENUM == STD_ON)
	/* Group 2 - SPI Reads (SPI3, fast loop) */
	
	DMACTRLPKT02->ISADDR = (uint32)(D_FASTSPISTARTADDR_CNT_U32);
	DMACTRLPKT02->IDADDR = (uint32)&(DMAData_G_str.FastSPI_Cnt_u16[0]);
	
	DMACTRLPKT02->ITCOUNT = (D_NUMFASTSPIWORDS_CNT_U16)		/* Element count:	configurable */
						  | (1ul << 16);					/* Frame count:		1 */
	
	DMACTRLPKT02->CHCTRL = (1ul)		/* Auto-init:				enabled */
						 | (3ul << 1)	/* Addressing mode (write):	indexed */
						 | (3ul << 3)	/* Addressing mode (read):	indexed */
						 | (1ul << 8)	/* Transfer type:			block transfer */
						 | (1ul << 12)	/* Write element size:		16 bit */
						 | (1ul << 14)	/* Read element size:		16 bit */
						 | (0ul << 16);	/* Next channel:			none */
	
	DMACTRLPKT02->EIOFF = (4ul)			/* Source element offset:		4 bytes - SPI read register data are 4 bytes apart */
						| (2ul << 16);	/* Destination element offset:	2 bytes - sizeof(uint16) */
	
	DMACTRLPKT02->FIOFF = (0ul)			/* Source frame offset:			0 bytes */
						| (0ul << 16);	/* Destination frame offset:	0 bytes */
	
	DMACTRLREG->DREQASI0_CH2ASI = 14u;	/* Trigger on MIBSPI3[1] */
	
	DMACTRLREG->PAR0 |= (4ul << 20);	/* Channel 2:	Port B */
	
	DMACTRLREG->CHPRIOS |= (1ul << 2);	/* Channel 2:	high priority */
#endif
	
	
#if (D_FASTADCGROUPENABLED_CNT_ENUM == STD_ON)
	/* Group 3 - ADC Reads (ADC2, fast loop) */
	
	DMACTRLPKT03->ISADDR = (uint32)(D_FASTADCSTARTADDR_CNT_U32);
	DMACTRLPKT03->IDADDR = (uint32)&(DMAData_G_str.FastADC_Cnt_u16[0]);
	
	DMACTRLPKT03->ITCOUNT = (D_NUMFASTADCCHANNELS_CNT_U16)	/* Element count:	configurable */
						  | (1ul << 16);					/* Frame count:		1 */
	
	DMACTRLPKT03->CHCTRL = (1ul)		/* Auto-init:				enabled */
						 | (3ul << 1)	/* Addressing mode (write):	indexed */
						 | (3ul << 3)	/* Addressing mode (read):	indexed */
						 | (1ul << 8)	/* Transfer type:			block transfer */
						 | (1ul << 12)	/* Write element size:		16 bit */
						 | (1ul << 14)	/* Read element size:		16 bit */
						 | (0ul << 16);	/* Next channel:			none */
	
	DMACTRLPKT03->EIOFF = (4ul)			/* Source element offset:		4 bytes - ADC result data are 4 bytes apart */
						| (2ul << 16);	/* Destination element offset:	2 bytes - sizeof(uint16) */
	
	DMACTRLPKT03->FIOFF = (0ul)			/* Source frame offset:			0 bytes */
						| (0ul << 16);	/* Destination frame offset:	0 bytes */
	
	DMACTRLREG->DREQASI0_CH3ASI = 16u;	/* Trigger on ADC2 G1 EOC */
	
	DMACTRLREG->PAR0 |= (4ul << 16);	/* Channel 3:	Port B */
	
	DMACTRLREG->CHPRIOS |= (1ul << 3);	/* Channel 3:	high priority */
#endif
	
	
#if (D_FASTPWMGROUPENABLED_CNT_ENUM == STD_ON)
	/* Group 5 - NHET Writes */
	
	DMACTRLPKT05->ISADDR = (uint32)&(DMAData_G_str.PWMPeriod_Cnt_u32);
	DMACTRLPKT05->IDADDR = (uint32)(D_DMANHETPERIODADDR_CNT_U32);
	
	DMACTRLPKT05->ITCOUNT = (1ul)			/* Element count:	1 */
						  | (1ul << 16);	/* Frame count:		1 */
	
	DMACTRLPKT05->CHCTRL = (1ul)		/* Auto-init:				enabled */
						 | (0ul << 1)	/* Addressing mode (write):	fixed */
						 | (0ul << 3)	/* Addressing mode (read):	fixed */
						 | (1ul << 8)	/* Transfer type:			block transfer */
						 | (2ul << 12)	/* Write element size:		32 bit */
						 | (2ul << 14)	/* Read element size:		32 bit */
						 | (7ul << 16);	/* Next channel:			channel 6 */
	
	DMACTRLPKT05->EIOFF = (0ul)			/* Source element offset:		0 bytes */
						| (0ul << 16);	/* Destination element offset:	0 bytes */
	
	DMACTRLPKT05->FIOFF = (0ul)			/* Source frame offset:			0 bytes */
						| (0ul << 16);	/* Destination frame offset:	0 bytes */
	
	DMACTRLREG->DREQASI1_CH5ASI = 20u;	/* Trigger on NHET1 DMAREQ[4] */
	
	DMACTRLREG->PAR0 |= (4ul << 8);		/* Channel 5:	Port B */
	
	DMACTRLREG->CHPRIOS |= (1ul << 5);	/* Channel 5:	high priority */
	
	
	/* Group 6 - ePWM Writes */
	
	DMACTRLPKT06->ISADDR = (uint32)&(DMAData_G_str.PWMCmp_Cnt_u16[0][0]);
	DMACTRLPKT06->IDADDR = (uint32)(D_EPWMSTARTADDR_CNT_U32);
	
	DMACTRLPKT06->ITCOUNT = (2ul)			/* Element count:	2 */
						  | (4ul << 16);	/* Frame count:		4 */
	
	DMACTRLPKT06->CHCTRL = (1ul)		/* Auto-init:				enabled */
						 | (3ul << 1)	/* Addressing mode (write):	indexed */
						 | (3ul << 3)	/* Addressing mode (read):	indexed */
						 | (1ul << 8)	/* Transfer type:			block transfer */
						 | (1ul << 12)	/* Write element size:		16 bit */
						 | (1ul << 14)	/* Read element size:		16 bit */
						 | (0ul << 16);	/* Next channel:			none */
	
	DMACTRLPKT06->EIOFF = (2ul)			/* Source element offset:		2 bytes - sizeof(uint16) */
						| (6ul << 16);	/* Destination element offset:	6 bytes - difference of EPWMx->CMPA and EPWMx->CMPB */
	
	DMACTRLPKT06->FIOFF = (4ul)			/* Source frame offset:			4 bytes - sizeof(uint16) * 2 elements per frame */
						| (256ul << 16);/* Destination frame offset:	256 bytes - difference of EPWM1 and EPWM2 addresses */
	
	DMACTRLREG->DREQASI1_CH6ASI = 28u;	/* Unused hardware trigger */
	
	DMACTRLREG->PAR0 |= (4ul << 4);		/* Channel 6:	Port B */
	
	DMACTRLREG->CHPRIOS |= (1ul << 6);	/* Channel 6:	high priority */
#endif
	
	
#if (D_SLOWADCGROUPENABLED_CNT_ENUM == STD_ON)
	/* Group 9 - ADC Reads (ADC1, slow loop) */
	
	DMACTRLPKT09->ISADDR = (uint32)(D_SLOWADCSTARTADDR_CNT_U32);
	DMACTRLPKT09->IDADDR = (uint32)&(DMAData_G_str.SlowADC_Cnt_u16[0]);
	
	DMACTRLPKT09->ITCOUNT = (D_NUMSLOWADCCHANNELS_CNT_U16)	/* Element count:	configurable */
						  | (1ul << 16);					/* Frame count:		1 */
	
	DMACTRLPKT09->CHCTRL = (1ul)		/* Auto-init:				enabled */
						 | (3ul << 1)	/* Addressing mode (write):	indexed */
						 | (3ul << 3)	/* Addressing mode (read):	indexed */
						 | (1ul << 8)	/* Transfer type:			block transfer */
						 | (1ul << 12)	/* Write element size:		16 bit */
						 | (1ul << 14)	/* Read element size:		16 bit */
						 | (0ul << 16);	/* Next channel:			none */
	
	DMACTRLPKT09->EIOFF = (4ul)			/* Source element offset:		4 bytes - ADC result data are 4 bytes apart */
						| (2ul << 16);	/* Destination element offset:	2 bytes - sizeof(uint16) */
	
	DMACTRLPKT09->FIOFF = (0ul)			/* Source frame offset:			0 bytes */
						| (0ul << 16);	/* Destination frame offset:	0 bytes */
	
	DMACTRLREG->DREQASI2_CH9ASI = 11u;	/* Trigger on ADC1 G2 EOC */
	
	DMACTRLREG->PAR1 |= (4ul << 24);	/* Channel 9:	Port B */
	
	DMACTRLREG->CHPRIOS |= (1ul << 9);	/* Channel 9:	high priority */
#endif
	
	
#if (D_FASTSPIGROUPENABLED_CNT_ENUM == STD_ON)
	/* Group 12 - SPI Reads (SPI5, slow loop) */
	
	DMACTRLPKT12->ISADDR = (uint32)(D_SLOWSPISTARTADDR_CNT_U32);
	DMACTRLPKT12->IDADDR = (uint32)&(DMAData_G_str.SlowSPI_Cnt_u16[0]);
	
	DMACTRLPKT12->ITCOUNT = (D_NUMSLOWSPIWORDS_CNT_U16)		/* Element count:	configurable */
						  | (1ul << 16);					/* Frame count:		1 */
	
	DMACTRLPKT12->CHCTRL = (1ul)		/* Auto-init:				enabled */
						 | (3ul << 1)	/* Addressing mode (write):	indexed */
						 | (3ul << 3)	/* Addressing mode (read):	indexed */
						 | (1ul << 8)	/* Transfer type:			block transfer */
						 | (1ul << 12)	/* Write element size:		16 bit */
						 | (1ul << 14)	/* Read element size:		16 bit */
						 | (0ul << 16);	/* Next channel:			none */
	
	DMACTRLPKT12->EIOFF = (4ul)			/* Source element offset:		4 bytes - SPI read register data are 4 bytes apart */
						| (2ul << 16);	/* Destination element offset:	2 bytes - sizeof(uint16) */
	
	DMACTRLPKT12->FIOFF = (0ul)			/* Source frame offset:			0 bytes */
						| (0ul << 16);	/* Destination frame offset:	0 bytes */
	
	DMACTRLREG->DREQASI3_CH12ASI = 30u;	/* Trigger on MIBSPI5[1] */
	
	DMACTRLREG->PAR1 |= (4ul << 12);	/* Channel 12:	Port B */
	
	DMACTRLREG->CHPRIOS |= (1ul << 12);	/* Channel 12:	high priority */
#endif
	
	
	
	/* Enable Interrupts */
#if (D_FASTADCGROUPENABLED_CNT_ENUM == STD_ON)
	DMACTRLREG->GCHIENAS = (1ul << 3);		/* Enable Channel 3 interrupt */
	DMACTRLREG->BTCINTENAS = (1ul << 3);	/* Enable Channel 3 block transfer complete interrupt */
#endif
	
	
	/* Enable Channels */
	DMACTRLREG->HWCHENAS = (0ul)
#if (D_FASTSPIGROUPENABLED_CNT_ENUM == STD_ON)
						 | (1ul << 2)	/* Channel 2:	enabled */
#endif
#if (D_FASTADCGROUPENABLED_CNT_ENUM == STD_ON)
						 | (1ul << 3)	/* Channel 3:	enabled */
#endif
#if (D_FASTPWMGROUPENABLED_CNT_ENUM == STD_ON)
						 | (1ul << 5)	/* Channel 5:	enabled */
						 | (1ul << 6)	/* Channel 6:	enabled */
#endif
#if (D_SLOWADCGROUPENABLED_CNT_ENUM == STD_ON)
						 | (1ul << 9)	/* Channel 9:	enabled */
#endif
#if (D_FASTSPIGROUPENABLED_CNT_ENUM == STD_ON)
						 | (1ul << 12)	/* Channel 12:	enabled */
#endif
						 ;
	
}

/******************************************************************************
  * Name:        Dma_SetupFlsTstBlock
  * Description: Performs DMA register settings needed to set up a block for the 
  *              FlsTst Flash CRC Test
  * Inputs:      CRCAddr_Cnt_T_u32 
  *              FlsAddr_Cnt_T_u32
  *              DmaFrameCount_Cnt_T_u16 
  *              DmaElementCount_Cnt_T_u16  
  * Outputs:     NONE 
  * Usage Notes:  Called by the FlsTst Flash CRC Test component (part of TMS570_uDiag)
  *               Disable the FlsTst block by calling Dma_DisableFlsTstBlock before
  *               calling this function.  
  ****************************************************************************/
FUNC(void, DMA_CODE) Dma_SetupFlsTstBlock( VAR(uint32, AUTOMATIC) CRCAddr_Cnt_T_u32,
										   VAR(uint32, AUTOMATIC) FlsAddr_Cnt_T_u32,
										   VAR(uint16, AUTOMATIC) DmaFrameCount_Cnt_T_u16,
										   VAR(uint16, AUTOMATIC) DmaElementCount_Cnt_T_u16 )
{
#if (D_DMAFLSTSTENABLED_CNT_ENUM == STD_ON)
	
	/* Group 0 - Expected CRC Signature Load */
	
	DMACTRLPKT00->ISADDR = CRCAddr_Cnt_T_u32;
	DMACTRLPKT00->IDADDR = (uint32)(D_CRCCTRLREGSTART_CNT_U32);
	
	DMACTRLPKT00->ITCOUNT = (1ul)			/* Element count:	1 */
						  | (1ul << 16);	/* Frame count:		1 */
	
	DMACTRLPKT00->CHCTRL = (0ul)		/* Auto-init:				disabled */
						 | (0ul << 1)	/* Addressing mode (write):	constant */
						 | (0ul << 3)	/* Addressing mode (read):	constant */
						 | (0ul << 8)	/* Transfer type:			frame transfer */
						 | (3ul << 12)	/* Write element size:		64 bit */
						 | (3ul << 14)	/* Read element size:		64 bit */
						 | (0ul << 16);	/* Next channel:			none */
	
	DMACTRLPKT00->EIOFF = 0ul;			/* Initialize EIOFF for parity */
	
	DMACTRLPKT00->FIOFF = 0ul;			/* Initialize FIOFF for parity */
	
	DMACTRLREG->DREQASI0_CH0ASI = 26u;	/* Trigger on CRC DMAREQ[0] */
	
	DMACTRLREG->PAR0 |= (4ul << 28);	/* Channel 0:	Port B */
	
	
	/* Group 1 - Signature Data Block Load */
	
	DMACTRLPKT01->ISADDR = FlsAddr_Cnt_T_u32;
	DMACTRLPKT01->IDADDR = (uint32)(D_CRCPSASIGREGSTART_CNT_U32);
	
	DMACTRLPKT01->ITCOUNT = ((uint32)DmaElementCount_Cnt_T_u16)			/* Element count:	configurable */
						  | ((uint32)DmaFrameCount_Cnt_T_u16 << 16);	/* Frame count:		configurable */
	
	DMACTRLPKT01->CHCTRL = (0ul)		/* Auto-init:				disabled */
						 | (0ul << 1)	/* Addressing mode (write):	constant */
						 | (1ul << 3)	/* Addressing mode (read):	post-increment */
						 | (1ul << 8)	/* Transfer type:			block transfer */
						 | (3ul << 12)	/* Write element size:		64 bit */
						 | (3ul << 14)	/* Read element size:		64 bit */
						 | (0ul << 16);	/* Next channel:			none */
	
	DMACTRLPKT01->EIOFF = 0ul;			/* Initialize EIOFF for parity */
	
	DMACTRLPKT01->FIOFF = 0ul;			/* Initialize FIOFF for parity */
	
	DMACTRLREG->DREQASI0_CH1ASI = 28u;	/* Unused hardware trigger */
	
	DMACTRLREG->PAR0 |= (4ul << 24);	/* Channel 1:	Port B */
	
#endif
}

/******************************************************************************
  * Name:        Dma_EnableFlsTstBlock
  * Description: Enables the DMA channels used for the Flash CRC Test
  * Inputs:      NONE     
  * Outputs:     NONE 
  * Usage Notes:  Called by the FlsTst Flash CRC Test component (part of TMS570_uDiag) 
  ****************************************************************************/
  FUNC(void, DMA_CODE) Dma_EnableFlsTstBlock(void)
{
#if (D_DMAFLSTSTENABLED_CNT_ENUM == STD_ON)
	
	/* Enable Channels */
	DMACTRLREG->HWCHENAS = 1ul;
	
	/* Start DMA on Group 1 */
	DMACTRLREG->SWCHENAS = (1ul << 1);
	
#endif
}

/******************************************************************************
  * Name:        Dma_DisableFlsTstBlock
  * Description: Disables the DMA channels used for the Flash CRC Test
  * Inputs:      NONE     
  * Outputs:     NONE 
  * Usage Notes:  Called by the FlsTst Flash CRC Test component (part of TMS570_uDiag) 
  ****************************************************************************/
FUNC(void, DMA_CODE) Dma_DisableFlsTstBlock(void)
{
#if (D_DMAFLSTSTENABLED_CNT_ENUM == STD_ON)
	
	/* Disable Channels */
	DMACTRLREG->HWCHENAR = 1ul;
	DMACTRLREG->SWCHENAR = (1ul << 1);
	
#endif
}

